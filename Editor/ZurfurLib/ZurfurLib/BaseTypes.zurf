// Define the simple types:
//     I8, Byte, I16, U16, I32, U32, Int, U64, F32, F64, Decimal
//

mod Zurfur

pragma AllowUnderscoreDefinitions

// Blank function
[pub] fun get nop() extern
[pub] fun get todo() require(false) extern

// These implement throw and require reserved words
[pub] fun __throw(code ErrorCode, message Str) extern
[pub] fun __throw(condition Bool, code ErrorCode, message Str) extern
[pub] fun __require(condition Bool) extern
[pub] fun __require(condition Bool, message Str) extern
[pub] fun assert(condition Bool) extern
[pub] fun assert(condition Bool, message Str) extern

// Return type of functions that don't return anything
[pub]
type Void passcopy { }

// Empty value for pointers and optionals
[pub]
type Nil passcopy { }

// Maybe<T> is the same as ?T.  Pointer and reference types are always
// optimized so that `?ref T`, `*T`, and `^T` are just one pointer.
[pub]
type Maybe<T>
    value T
    hasValue Bool

[pub]
fun Maybe.new<T>(value T)
    my.value = value
    my.hasValue = true


[pub]
type Error ro interface
    fun get code() ErrorCode
    fun get message() Str


// Result<T> - Same as !T
[pub]
type Result<T> union
    ok T
    error ro Error

// This will probably be a specially recognized error code type
[pub]
type ErrorCode enum
    Success = 0 

    

// a UTF8 encoded character, same as I32
[pub]
type Rune = I32

// Base interface for all types
[pub]
type Object interface { }


// All types have a unique `id`, but other non-essential metadata is opt-in.
// This must always be 32 bits, even on 64 bit machines, so as not to change
// the `GcHeapObject` footprint.
[pub]
type Type ro passcopy
    id U32


// Swap two items
[pub] fun swap<T>(a mut ref T, b mut ref T)
    extern

// Bool (true or false)
[pub]
type Bool ro passcopy
    const __size Int = 1

[pub static] fun Bool.getHash(a Bool) Int extern
[pub static] fun Bool._opEq(a Bool, b Bool) Bool extern

// TBD: These operators must be restricted to Bool
[pub static] fun Bool._opLogicalAnd(a Bool, b Bool) Bool extern
[pub static] fun Bool._opLogicalOr(a Bool, b Bool) Bool extern
[pub static] fun Bool._opLogicalNot(a Bool) Bool extern

// I8 (-128..127)
[pub]
type I8 ro passcopy
    const __size Int = 1
    const __align Int = 1
    const Zero I8 = 0
    const One I8 = 1
    const MinValue I8 = -128
    const MaxValue I8 = 127
    const NanOrMin I8 = MinValue
    
[pub] fun get I8.toStr() Str extern
[pub] fun get I8.toByte() ?Byte extern
[pub] fun get I8.toByteMask() Byte extern
[pub] fun get I8.toI16() I16 extern
[pub] fun get I8.toI32() I32 extern
[pub] fun get I8.toInt() Int extern
[pub] fun get I8.toF32() F32 extern
[pub] fun get I8.toF64() F64 extern
[pub] fun get I8.toDecimal() Decimal extern

[pub static] fun I8.getHash(a I8) Int extern
[pub static] fun I8._opEq(a I8, b I8) Bool extern
[pub static] fun I8._opCmp(a I8, b I8) I32 extern


// Byte (0..255)
[pub] type Byte ro passcopy
    const __size Int = 1
    const __align Int = 1    
    const Zero Byte = 0
    const One Byte = 1
    const MinValue Byte = 0
    const MaxValue Byte = 255
    const NanOrMin Byte = MinValue
    
[pub] fun get Byte.toStr() Str extern
[pub] fun get Byte.toI8() ?I8 extern
[pub] fun get Byte.toI8Mask() I8 extern
[pub] fun get Byte.toI16() I16 extern
[pub] fun get Byte.toU16() U16 extern
[pub] fun get Byte.toI32() I32 extern
[pub] fun get Byte.toU32() U32 extern
[pub] fun get Byte.toInt() Int extern
[pub] fun get Byte.toU64() U64 extern
[pub] fun get Byte.toF32() F32 extern
[pub] fun get Byte.toF64() F64 extern
[pub] fun get Byte.toDecimal() Decimal extern

[pub static] fun Byte.getHash(a Byte) Int extern
[pub static] fun Byte._opEq(a Byte, b Byte) Bool extern
[pub static] fun Byte._opCmp(a Byte, b Byte) I32 extern


// I16 (-32768..32768)
[pub] type I16 ro passcopy
    const __size Int = 2
    const __align Int = 2    
    const Zero I16 = 0
    const One I16 = 1
    const MinValue I16 = -32768
    const MaxValue I16 = 32767
    const NanOrMin I16 = MinValue

[pub] fun get I16.toStr() Str extern
[pub] fun get I16.toI8() ?I8 extern
[pub] fun get I16.toByte() ?Byte extern
[pub] fun get I16.toU16() ?U16 extern
[pub] fun get I16.toI32() I32 extern
[pub] fun get I16.toInt() Int extern
[pub] fun get I16.toF32() F32 extern
[pub] fun get I16.toF64() F64 extern
[pub] fun get I16.toDecimal() Decimal extern    
[pub] fun get I16.toI8Mask() I8 extern
[pub] fun get I16.toByteMask() Byte extern
[pub] fun get I16.toU16Mask() U16 extern    

[pub static] fun I16.getHash(a I16) Int extern
[pub static] fun I16._opEq(a I16, b I16) Bool extern
[pub static] fun I16._opCmp(a I16, b I16) I32 extern



// U16 (0..65535)
[pub] type U16 ro passcopy
    const __size Int = 2
    const __align Int = 2    
    const Zero U16 = 0
    const One U16 = 1
    const MinValue U16 = 0
    const MaxValue U16 = 65535
    const NanOrMin U16 = MinValue
    

[pub] fun get U16.toStr() Str extern
[pub] fun get U16.toI8() ?I8 extern
[pub] fun get U16.toByte() ?Byte extern
[pub] fun get U16.toI16() ?I16 extern
[pub] fun get U16.toI32() I32 extern
[pub] fun get U16.toU32() U32 extern
[pub] fun get U16.toInt() Int extern
[pub] fun get U16.toU64() U64 extern
[pub] fun get U16.toF32() F32 extern
[pub] fun get U16.toF64() F64 extern
[pub] fun get U16.toDecimal() Decimal extern
[pub] fun get U16.toI8Mask() I8 extern
[pub] fun get U16.toByteMask() Byte extern
[pub] fun get U16.toI16Mask() I16 extern

[pub static] fun U16.getHash(a U16) Int extern
[pub static] fun U16._opEq(a U16, b U16) Bool extern
[pub static] fun U16._opCmp(a U16, b U16) I32 extern

// A 32 bit integer
[pub] type I32 ro passcopy
    const __size Int = 4
    const __align Int = 4    
    const Zero I32 = 0
    const One I32 = 1
    const MinValue I32 = -2147483648
    const MaxValue I32 = 2147483647
    const NanOrMin I32 = MinValue
    

[pub] fun get I32.toStr() Str extern
[pub] fun get I32.toI8() ?I8 extern
[pub] fun get I32.toByte() ?Byte extern
[pub] fun get I32.toI16() ?I16 extern
[pub] fun get I32.toU16() ?U16 extern
[pub] fun get I32.toU32() ?U32 extern
[pub] fun get I32.toInt() Int extern
[pub] fun get I32.toF32() F32 extern
[pub] fun get I32.toF64() F64 extern
[pub] fun get I32.toDecimal() Decimal extern    
[pub] fun get I32.toI8Mask() I8 extern
[pub] fun get I32.toByteMask() Byte extern
[pub] fun get I32.toI16Mask() I16 extern
[pub] fun get I32.toU16Mask() U16 extern
[pub] fun get I32.toU32Mask() U32 extern

[pub static] fun I32.getHash(a I32) Int extern
[pub static] fun I32._opEq(a I32, b I32) Bool extern
[pub static] fun I32._opCmp(a I32, b I32) I32 extern
[pub static] fun I32._opIn(a I32, b Range<I32>) Bool extern
[pub static] fun I32._opRange(a I32, b I32) Range<I32> extern // TBD: Generic function on range?
[pub static] fun I32._opAdd(a I32, b I32) I32 extern
[pub static] fun I32._opSub(a I32, b I32) I32 extern
[pub static] fun I32._opNeg(a I32) I32 extern
[pub static] fun I32._opMul(a I32, b I32) I32 extern
[pub static] fun I32._opDiv(a I32, b I32) I32 extern
[pub static] fun I32._opRem(a I32, b I32) I32 extern
[pub static] fun I32._opBitNot(a I32) I32 extern
[pub static] fun I32._opBitAnd(a I32, b I32) I32 extern
[pub static] fun I32._opBitOr(a I32, b I32) I32 extern
[pub static] fun I32._opBitXor(a I32, b I32) I32 extern
[pub static] fun I32._opBitShl(a I32, b Int) I32 extern
[pub static] fun I32._opBitShr(a I32, b Int) I32 extern

[pub] fun get I32.iterator() RangeIterator<I32>
    return RangeIterator<I32>(0 I32, my)


// 32 bit unsigned integer
[pub] type U32 ro passcopy
    const __size Int = 4
    const __align Int = 4    
    const Zero U32 = 0
    const One U32 = 1
    const MinValue U32 = 0
    const MaxValue U32 = 4294967295
    const NanOrMin U32 = MinValue
    

[pub] fun get U32.toStr() Str extern
[pub] fun get U32.toI8() ?I8 extern
[pub] fun get U32.toByte() ?Byte extern
[pub] fun get U32.toI16() ?I16 extern
[pub] fun get U32.toU16() ?U16 extern
[pub] fun get U32.toI32() ?I32 extern        
[pub] fun get U32.toInt() Int extern
[pub] fun get U32.toU64() U64 extern
[pub] fun get U32.toF32() F32 extern
[pub] fun get U32.toF64() F64 extern
[pub] fun get U32.toDecimal() Decimal extern        
[pub] fun get U32.toI8Mask() I8 extern
[pub] fun get U32.toByteMask() Byte extern
[pub] fun get U32.toI16Mask() I16 extern
[pub] fun get U32.toU16Mask() U16 extern
[pub] fun get U32.toI32Mask() I32 extern

[pub static] fun U32.getHash(a U32) Int extern
[pub static] fun U32._opEq(a U32, b U32) Bool extern
[pub static] fun U32._opCmp(a U32, b U32) I32 extern
[pub static] fun U32._opIn(a U32, b Range<U32>) Bool extern
[pub static] fun U32._opRange(a U32, b U32) Range<U32> extern // TBD: Generic function on range?
[pub static] fun U32._opAdd(a U32, b U32) U32 extern
[pub static] fun U32._opSub(a U32, b U32) U32 extern
[pub static] fun U32._opNeg(a U32) U32 extern
[pub static] fun U32._opMul(a U32, b U32) U32 extern
[pub static] fun U32._opDiv(a U32, b U32) U32 extern
[pub static] fun U32._opRem(a U32, b U32) U32 extern
[pub static] fun U32._opBitNot(a U32) U32 extern
[pub static] fun U32._opBitAnd(a U32, b U32) U32 extern
[pub static] fun U32._opBitOr(a U32, b U32) U32 extern
[pub static] fun U32._opBitXor(a U32, b U32) U32 extern
[pub static] fun U32._opBitShl(a U32, b Int) U32 extern
[pub static] fun U32._opBitShr(a U32, b Int) U32 extern

[pub] fun get U32.iterator() RangeIterator<U32>
    return RangeIterator<U32>(0 U32, my)


// A 64 bit integer (same as Int)
[pub] type Int ro passcopy
    const __size Int = 8
    const __align Int = 8    
    const Zero Int = 0
    const One Int = 1
    const MinValue Int = -9223372036854775808
    const MaxValue Int = 9223372036854775807
    const NanOrMin Int = MinValue    

[pub] fun get Int.toStr() Str extern
[pub] fun get Int.toI8() ?I8 extern
[pub] fun get Int.toByte() ?Byte extern
[pub] fun get Int.toI16() ?I16 extern
[pub] fun get Int.toU16() ?U16 extern
[pub] fun get Int.toI32() ?I32 extern
[pub] fun get Int.toU32() ?U32 extern
[pub] fun get Int.toU64() ?U64 extern    
[pub] fun get Int.toF32() F32 extern
[pub] fun get Int.toF64() F64 extern
[pub] fun get Int.toDecimal() Decimal extern
[pub] fun get Int.toI8Mask() I8 extern
[pub] fun get Int.toByteMask() Byte extern
[pub] fun get Int.toI16Mask() I16 extern
[pub] fun get Int.toU16Mask() U16 extern
[pub] fun get Int.toI32Mask() I32 extern
[pub] fun get Int.toU32Mask() U32 extern
[pub] fun get Int.toU64Mask() U64 extern


[pub static] fun Int.getHash(a Int) Int extern
[pub static] fun Int._opEq(a Int, b Int) Bool extern
[pub static] fun Int._opCmp(a Int, b Int) I32 extern
[pub static] fun Int._opIn(a Int, b Range<Int>) Bool extern
[pub static] fun Int._opRange(a Int, b Int) Range<Int> extern // TBD: Generic function on range?
[pub static] fun Int._opAdd(a Int, b Int) Int extern
[pub static] fun Int._opSub(a Int, b Int) Int extern
[pub static] fun Int._opNeg(a Int) Int extern
[pub static] fun Int._opMul(a Int, b Int) Int extern
[pub static] fun Int._opDiv(a Int, b Int) Int extern
[pub static] fun Int._opRem(a Int, b Int) Int extern
[pub static] fun Int._opBitNot(a Int) Int extern
[pub static] fun Int._opBitAnd(a Int, b Int) Int extern
[pub static] fun Int._opBitOr(a Int, b Int) Int extern
[pub static] fun Int._opBitXor(a Int, b Int) Int extern
[pub static] fun Int._opBitShl(a Int, b Int) Int extern
[pub static] fun Int._opBitShr(a Int, b Int) Int extern


[pub] fun get Int.iterator() RangeIterator<Int>
    return RangeIterator<Int>(0, my)

// 64 bit unsigned integer
[pub] type U64 ro passcopy
    const __size Int = 8
    const __align Int = 8    
    const Zero U64 = 0
    const One U64 = 1
    const MinValue U64 = 0
    const MaxValue U64 = 18446744073709551615
    const NanOrMin U64 = MinValue

[pub] fun get U64.toStr() Str extern
[pub] fun get U64.toI8() ?I8 extern
[pub] fun get U64.toByte() ?Byte extern
[pub] fun get U64.toI16() ?I16 extern
[pub] fun get U64.toU16() ?U16 extern
[pub] fun get U64.toI32() ?I32 extern
[pub] fun get U64.toU32() ?U32 extern
[pub] fun get U64.toInt() ?Int extern
[pub] fun get U64.toF32() F32 extern
[pub] fun get U64.toF64() F64 extern
[pub] fun get U64.toDecimal() Decimal extern
[pub] fun get U64.toI8Mask() I8 extern
[pub] fun get U64.toByteMask() Byte extern
[pub] fun get U64.toI16Mask() I16 extern
[pub] fun get U64.toU16Mask() U16 extern
[pub] fun get U64.toI32Mask() I32 extern
[pub] fun get U64.toU32Mask() U32 extern
[pub] fun get U64.toIntMask() Int extern

[pub static] fun U64.getHash(a U64) Int extern
[pub static] fun U64._opEq(a U64, b U64) Bool extern
[pub static] fun U64._opCmp(a U64, b U64) I32 extern
[pub static] fun U64._opIn(a U64, b Range<U64>) Bool extern
[pub static] fun U64._opRange(a U64, b U64) Range<U64> extern // TBD: Generic function on range?
[pub static] fun U64._opAdd(a U64, b U64) U64 extern
[pub static] fun U64._opSub(a U64, b U64) U64 extern
[pub static] fun U64._opNeg(a U64) U64 extern
[pub static] fun U64._opMul(a U64, b U64) U64 extern
[pub static] fun U64._opDiv(a U64, b U64) U64 extern
[pub static] fun U64._opRem(a U64, b U64) U64 extern
[pub static] fun U64._opBitNot(a U64) U64 extern
[pub static] fun U64._opBitAnd(a U64, b U64) U64 extern
[pub static] fun U64._opBitOr(a U64, b U64) U64 extern
[pub static] fun U64._opBitXor(a U64, b U64) U64 extern
[pub static] fun U64._opBitShl(a U64, b Int) U64 extern
[pub static] fun U64._opBitShr(a U64, b Int) U64 extern
[pub static] fun U64._opBitShr(a U64, b U64) U64 extern
[pub static] fun U64._opBitShl(a U64, b U64) U64 extern



[pub] fun get U64.iterator() RangeIterator<U64>
    return RangeIterator<U64>(0 U64, my)

[pub] type I128 ro passcopy
    const __size Int = 16
    const __align Int = 16

[pub] type U128 ro passcopy
    const __size Int = 16
    const __align Int = 16


[pub] type F32 ro passcopy
    const __size Int = 4
    const __align Int = 4    
    const Zero F32 = 0
    const One F32 = 1
    const MinValue F32 = -3.40282347E+38F
    const MaxValue F32 = 3.40282347E+38F
    const NanOrMin F32 = MinValue    
    const epsilon F32 = 1.401298E-45F
    const infinity F32 = 1F/0F
    const negativeInfinity F32 = -1F/0F
    const nan F32 = 0f32/0f32
    const PI F32 = 3.141592653589793238
    const E F32 = 2.718281828459045235

[pub] fun get F32.isInfinity() Bool extern
[pub] fun get F32.isNan() Bool extern
[pub] fun get F32.isNegInfinity() Bool extern
[pub] fun get F32.isPosInfinity() Bool extern        

[pub] fun get F32.toStr() Str extern
[pub] fun get F32.toByte() ?Byte extern
[pub] fun get F32.toInt() ?Int extern
[pub] fun get F32.toU64() ?U64 extern
[pub] fun get F32.toF64() F64 extern
[pub] fun get F32.toDecimal() Decimal extern    
[pub] fun get F32.toByteMask() Byte extern
[pub] fun get F32.toIntMask() Int extern
[pub] fun get F32.toU64Mask() U64 extern
        
[pub static] fun F32.getHash(a F32) Int extern
[pub static] fun F32._opEq(a F32, b F32) Bool extern
[pub static] fun F32._opCmp(a F32, b F32) I32 extern
[pub static] fun F32._opEqUnordered(a F32, b F32) Bool extern
[pub static] fun F32._opGtUnordered(a F32, b F32) Bool extern
[pub static] fun F32._opGeUnordered(a F32, b F32) Bool extern
[pub static] fun F32._opLtUnordered(a F32, b F32) Bool extern
[pub static] fun F32._opLeUnordered(a F32, b F32) Bool extern
[pub static] fun F32._opIn(a F32, b Range<F32>) Bool extern
[pub static] fun F32._opRange(a F32, b F32) Range<I32> extern // TBD: Generic function on range?
[pub static] fun F32._opAdd(a F32, b F32) F32 extern
[pub static] fun F32._opSub(a F32, b F32) F32 extern
[pub static] fun F32._opNeg(a F32) F32 extern
[pub static] fun F32._opMul(a F32, b F32) F32 extern
[pub static] fun F32._opDiv(a F32, b F32) F32 extern
[pub static] fun F32._opRem(a F32, b F32) F32 extern


[pub] type F64 ro passcopy
    const __size Int = 8
    const __align Int = 8    
    const Zero F64 = 0
    const One F64 = 1
    const MinValue F64 = -1.7976931348623157E+308
    const MaxValue F64 = 1.7976931348623157E+308
    const NanOrMin F64 = MinValue    
    const epsilon F64 = 4.94065645841247E-324
    const infinity F64 = 1.0/0.0
    const negativeInfinity F64 = -1.0/0.0
    const nan F64 = 0f64/0f64
    const PI F64 = 3.141592653589793238
    const E F64 = 2.718281828459045235

[pub] fun get F64.isInfinity() Bool extern
[pub] fun get F64.isNan() Bool extern
[pub] fun get F64.isNegInfinity() Bool extern
[pub] fun get F64.isPosInfinity() Bool extern        

[pub] fun get F64.toStr() Str extern
[pub] fun get F64.toByte() ?Byte extern
[pub] fun get F64.toInt() ?Int extern
[pub] fun get F64.toU64() ?U64 extern
[pub] fun get F64.toDecimal() Decimal extern
[pub] fun get F64.toByteMask() Byte extern
[pub] fun get F64.toIntMask() Int extern
[pub] fun get F64.toU64Mask() U64 extern
[pub] fun get F64.toF32Clamp() F32 extern

[pub static] fun F64.getHash(a F64) Int extern
[pub static] fun F64._opEq(a F64, b F64) Bool extern
[pub static] fun F64._opCmp(a F64, b F64) I32 extern
[pub static] fun F64._opEqUnordered(a F64, b F64) Bool extern
[pub static] fun F64._opGtUnordered(a F64, b F64) Bool extern
[pub static] fun F64._opGeUnordered(a F64, b F64) Bool extern
[pub static] fun F64._opLtUnordered(a F64, b F64) Bool extern
[pub static] fun F64._opLeUnordered(a F64, b F64) Bool extern
[pub static] fun F64._opIn(a F64, b Range<F64>) Bool extern
[pub static] fun F64._opRange(a F64, b F64) Range<F64> extern // TBD: Generic function on range?
[pub static] fun F64._opAdd(a F64, b F64) F64 extern
[pub static] fun F64._opSub(a F64, b F64) F64 extern
[pub static] fun F64._opNeg(a F64) F64 extern
[pub static] fun F64._opMul(a F64, b F64) F64 extern
[pub static] fun F64._opDiv(a F64, b F64) F64 extern
[pub static] fun F64._opRem(a F64, b F64) F64 extern


// 128 bit decimal integer.  This will support nan, infinity, and
// exponents covering the entire range of F64 with more precision.
[pub] type Decimal ro passcopy
    const __size Int = 16
    const __align Int = 16
    const Zero Decimal = 0
    const One Decimal = 1
    const MinValue Decimal = -1E+1000M
    const MaxValue Decimal = 1E+1000M
    const NanOrMin Decimal = MinValue    
    const infinity Decimal = 1.0/0.0
    const negativeInfinity Decimal = -1.0/0.0
    const nan Decimal = 0.0/0.0
    
[pub] fun get Decimal.isInfinity() Bool extern
[pub] fun get Decimal.isNan() Bool extern
[pub] fun get Decimal.isNegInfinity() Bool extern
[pub] fun get Decimal.isPosInfinity() Bool extern

[pub] fun get Decimal.toStr() Str extern
[pub] fun get Decimal.toByte() ?Byte extern
[pub] fun get Decimal.toInt() ?Int extern
[pub] fun get Decimal.toU64() ?U64 extern
[pub] fun get Decimal.toByteMask() Byte extern
[pub] fun get Decimal.toIntMask() Int extern
[pub] fun get Decimal.toU64Mask() U64 extern
[pub] fun get Decimal.toIntClamp() Int extern
[pub] fun get Decimal.toF32Clamp() F32 extern
[pub] fun get Decimal.toF64Clamp() F64 extern

[pub static] fun Decimal.getHash(a Decimal) Int extern
[pub static] fun Decimal._opEq(a Decimal, b Decimal) Bool extern
[pub static] fun Decimal._opCmp(a Decimal, b Decimal) I32 extern
[pub static] fun Decimal._opEqUnordered(a Decimal, b Decimal) Bool extern
[pub static] fun Decimal._opGtUnordered(a Decimal, b Decimal) Bool extern
[pub static] fun Decimal._opGeUnordered(a Decimal, b Decimal) Bool extern
[pub static] fun Decimal._opLtUnordered(a Decimal, b Decimal) Bool extern
[pub static] fun Decimal._opLeUnordered(a Decimal, b Decimal) Bool extern
[pub static] fun Decimal._opIn(a Decimal, b Range<Decimal>) Bool extern
[pub static] fun Decimal._opRange(a Decimal, b Decimal) Range<I32> extern // TBD: Generic function on range?
[pub static] fun Decimal._opAdd(a Decimal, b Decimal) Decimal extern
[pub static] fun Decimal._opSub(a Decimal, b Decimal) Decimal extern
[pub static] fun Decimal._opNeg(a Decimal) Decimal extern
[pub static] fun Decimal._opMul(a Decimal, b Decimal) Decimal extern
[pub static] fun Decimal._opDiv(a Decimal, b Decimal) Decimal extern
[pub static] fun Decimal._opRem(a Decimal, b Decimal) Decimal extern