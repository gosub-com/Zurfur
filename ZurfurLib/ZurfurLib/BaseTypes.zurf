// Define the simple types:
//     i8, byte, i16, u16, i32, u32, int, u64, f32, float, Decimal
//

mod Zurfur

pragma AllowUnderscoreDefinitions

// These implement throw and require reserved words
[pub] fun assert(condition bool) todo
[pub] fun assert(condition bool, message str) todo
[pub] fun require(condition bool) todo
[pub] fun require(condition bool, message str) todo

// Return type of functions that don't return anything
[pub]
type void ro { }

// Empty value for pointers and optionals
[pub]
type Nil ro { }

// Maybe<T> is the same as ?T.  Pointer and reference types are always
// optimized so that `?&T`, `?*T`, `?^T`, and `?Box<T>` are just one pointer.
[pub]
type Maybe<T>
    // TBD: Assigning to `Maybe<T>` can change the type of `value` to nil.
    //      If we allow returning a reference to `T`, it must be in a box.
    //      For reference types, we can optimize to remove one box.
    //      For non-reference types, the compiler can probably optimize.
    //      Will have the same problem for sum types.
    value Box<T>
    hasValue bool

[pub]
fun Maybe.new<T>(value own T)
    my.value = Box<T>(value)
    my.hasValue = true

type Box<T>
    const __size int = 1

fun Box<T>.new<T>(value own T)
    nop

[pub]
type Error ro interface
    fun get code() ErrorCode
    fun get message() str


// Result<T> - Same as !T
[pub]
type Result<T> union
    ok T
    error ro Error

// This will probably be a specially recognized error code type
[pub]
type ErrorCode enum
    Success = 0 

    

// a UTF8 encoded character, same as i32
[pub]
type Rune = i32

// Base interface for all types
[pub]
type Object interface { }


// All types have a unique `id`, but other non-essential metadata is opt-in.
// This must always be 32 bits, even on 64 bit machines, so as not to change
// the `GcHeapObject` footprint.
[pub]
type Type ro
    id u32


// Swap two items
[pub]
fun swap<T>(a mut &T, b mut &T)
    todo

// bool (true or false)
[pub]
type bool ro
    const __size int = 1

[pub] fun bool.getHash() int extern
[pub] fun bool._opEq(b bool) bool extern

// TBD: These operators must be restricted to bool
[pub] fun bool._opLogicalAnd(b bool) bool extern
[pub] fun bool._opLogicalOr(b bool) bool extern
[pub] fun bool._opLogicalNot() bool extern

// i8 (-128..127)
[pub]
type i8 ro
    const __size int = 1
    const __align int = 1
    const Zero i8 = 0
    const One i8 = 1
    const MinValue i8 = -128
    const MaxValue i8 = 127
    const NanOrMin i8 = MinValue
    
[pub] fun i8.getHash() int extern
[pub] fun i8._opEq(b i8) bool extern
[pub] fun i8._opCmp(b i8) int extern

[pub] fun i8.toStr() str extern
[pub] fun i8.toByte() ?byte extern
[pub] fun i8.toByteMask() byte extern
[pub] fun i8.toI16() i16 extern
[pub] fun i8.toI32() i32 extern
[pub] fun i8.toInt() int extern
[pub] fun i8.toF32() f32 extern
[pub] fun i8.toFloat() float extern
[pub] fun i8.toDecimal() Decimal extern



// byte (0..255)
[pub]
type byte ro
    const __size int = 1
    const __align int = 1    
    const Zero byte = 0
    const One byte = 1
    const MinValue byte = 0
    const MaxValue byte = 255
    const NanOrMin byte = MinValue
    
[pub] fun byte.getHash() int extern
[pub] fun byte._opEq(b byte) bool extern
[pub] fun byte._opCmp(b byte) int extern

[pub] fun byte.toStr() str extern
[pub] fun byte.toI8() ?i8 extern
[pub] fun byte.toI8Mask() i8 extern
[pub] fun byte.toI16() i16 extern
[pub] fun byte.toU16() u16 extern
[pub] fun byte.toI32() i32 extern
[pub] fun byte.toU32() u32 extern
[pub] fun byte.toInt() int extern
[pub] fun byte.toU64() u64 extern
[pub] fun byte.toF32() f32 extern
[pub] fun byte.toFloat() float extern
[pub] fun byte.toDecimal() Decimal extern

// i16 (-32768..32768)
[pub]
type i16 ro
    const __size int = 2
    const __align int = 2    
    const Zero i16 = 0
    const One i16 = 1
    const MinValue i16 = -32768
    const MaxValue i16 = 32767
    const NanOrMin i16 = MinValue

[pub] fun i16.getHash() int extern
[pub] fun i16._opEq(b i16) bool extern
[pub] fun i16._opCmp(b i16) int extern

[pub] fun i16.toStr() str extern
[pub] fun i16.toI8() ?i8 extern
[pub] fun i16.toByte() ?byte extern
[pub] fun i16.toU16() ?u16 extern
[pub] fun i16.toI32() i32 extern
[pub] fun i16.toInt() int extern
[pub] fun i16.toF32() f32 extern
[pub] fun i16.toFloat() float extern
[pub] fun i16.toDecimal() Decimal extern    
[pub] fun i16.toI8Mask() i8 extern
[pub] fun i16.toByteMask() byte extern
[pub] fun i16.toU16Mask() u16 extern    

// u16 (0..65535)
[pub]
type u16 ro
    const __size int = 2
    const __align int = 2    
    const Zero u16 = 0
    const One u16 = 1
    const MinValue u16 = 0
    const MaxValue u16 = 65535
    const NanOrMin u16 = MinValue
    
[pub] fun u16.getHash() int extern
[pub] fun u16._opEq(b u16) bool extern
[pub] fun u16._opCmp(b u16) int extern

[pub] fun u16.toStr() str extern
[pub] fun u16.toI8() ?i8 extern
[pub] fun u16.toByte() ?byte extern
[pub] fun u16.toI16() ?i16 extern
[pub] fun u16.toI32() i32 extern
[pub] fun u16.toU32() u32 extern
[pub] fun u16.toInt() int extern
[pub] fun u16.toU64() u64 extern
[pub] fun u16.toF32() f32 extern
[pub] fun u16.toFloat() float extern
[pub] fun u16.toDecimal() Decimal extern
[pub] fun u16.toI8Mask() i8 extern
[pub] fun u16.toByteMask() byte extern
[pub] fun u16.toI16Mask() i16 extern

// A 32 bit integer
[pub]
type i32 ro
    const __size int = 4
    const __align int = 4    
    const Zero i32 = 0
    const One i32 = 1
    const MinValue i32 = -2147483648
    const MaxValue i32 = 2147483647
    const NanOrMin i32 = MinValue
    
[pub] fun i32.getHash() int extern
[pub] fun i32._opEq(b i32) bool extern
[pub] fun i32._opCmp(b i32) int extern
[pub] fun i32._opIn(b Range<i32>) bool extern
[pub] fun i32._opRange(b i32) Range<i32> extern // TBD: Generic function on range?
[pub] fun i32._opAdd(b i32) i32 extern
[pub] fun i32._opSub(b i32) i32 extern
[pub] fun i32._opNeg() i32 extern
[pub] fun i32._opMul(b i32) i32 extern
[pub] fun i32._opDiv(b i32) i32 extern
[pub] fun i32._opRem(b i32) i32 extern
[pub] fun i32._opBitNot() i32 extern
[pub] fun i32._opBitAnd(b i32) i32 extern
[pub] fun i32._opBitOr(b i32) i32 extern
[pub] fun i32._opBitXor(b i32) i32 extern
[pub] fun i32._opBitShl(b int) i32 extern
[pub] fun i32._opBitShr(b int) i32 extern

[pub] fun i32.toStr() str extern
[pub] fun i32.toI8() ?i8 extern
[pub] fun i32.toByte() ?byte extern
[pub] fun i32.toI16() ?i16 extern
[pub] fun i32.toU16() ?u16 extern
[pub] fun i32.toU32() ?u32 extern
[pub] fun i32.toInt() int extern
[pub] fun i32.toF32() f32 extern
[pub] fun i32.toFloat() float extern
[pub] fun i32.toDecimal() Decimal extern    
[pub] fun i32.toI8Mask() i8 extern
[pub] fun i32.toByteMask() byte extern
[pub] fun i32.toI16Mask() i16 extern
[pub] fun i32.toU16Mask() u16 extern
[pub] fun i32.toU32Mask() u32 extern

[pub]
fun i32.iterator() RangeIterator<i32>
    ret RangeIterator<i32>(0 i32, my)


// 32 bit unsigned integer
[pub]
type u32 ro
    const __size int = 4
    const __align int = 4    
    const Zero u32 = 0
    const One u32 = 1
    const MinValue u32 = 0
    const MaxValue u32 = 4294967295
    const NanOrMin u32 = MinValue
    
[pub] fun u32.getHash() int extern
[pub] fun u32._opEq(b u32) bool extern
[pub] fun u32._opCmp(b u32) int extern
[pub] fun u32._opIn(b Range<u32>) bool extern
[pub] fun u32._opRange(b u32) Range<u32> extern // TBD: Generic function on range?
[pub] fun u32._opAdd(b u32) u32 extern
[pub] fun u32._opSub(b u32) u32 extern
[pub] fun u32._opNeg() u32 extern
[pub] fun u32._opMul(b u32) u32 extern
[pub] fun u32._opDiv(b u32) u32 extern
[pub] fun u32._opRem(b u32) u32 extern
[pub] fun u32._opBitNot() u32 extern
[pub] fun u32._opBitAnd(b u32) u32 extern
[pub] fun u32._opBitOr(b u32) u32 extern
[pub] fun u32._opBitXor(b u32) u32 extern
[pub] fun u32._opBitShl(b int) u32 extern
[pub] fun u32._opBitShr(b int) u32 extern

[pub] fun u32.toStr() str extern
[pub] fun u32.toI8() ?i8 extern
[pub] fun u32.toByte() ?byte extern
[pub] fun u32.toI16() ?i16 extern
[pub] fun u32.toU16() ?u16 extern
[pub] fun u32.toI32() ?i32 extern        
[pub] fun u32.toInt() int extern
[pub] fun u32.toU64() u64 extern
[pub] fun u32.toF32() f32 extern
[pub] fun u32.toFloat() float extern
[pub] fun u32.toDecimal() Decimal extern        
[pub] fun u32.toI8Mask() i8 extern
[pub] fun u32.toByteMask() byte extern
[pub] fun u32.toI16Mask() i16 extern
[pub] fun u32.toU16Mask() u16 extern
[pub] fun u32.toI32Mask() i32 extern

[pub] fun u32.iterator() RangeIterator<u32>
    ret RangeIterator<u32>(0 u32, my)


// A 64 bit integer (same as int)
[pub]
type int ro
    const __size int = 8
    const __align int = 8    
    const Zero int = 0
    const One int = 1
    const MinValue int = -9223372036854775808
    const MaxValue int = 9223372036854775807
    const NanOrMin int = MinValue    

[pub] fun int.getHash() int extern
[pub] fun int._opEq(b int) bool extern
[pub] fun int._opCmp(b int) int extern
[pub] fun int._opIn(b Range<int>) bool extern
[pub] fun int._opRange(b int) Range<int> extern // TBD: Generic function on range?
[pub] fun int._opAdd(b int) int extern
[pub] fun int._opSub(b int) int extern
[pub] fun int._opNeg() int extern
[pub] fun int._opMul(b int) int extern
[pub] fun int._opDiv(b int) int extern
[pub] fun int._opRem(b int) int extern
[pub] fun int._opBitNot() int extern
[pub] fun int._opBitAnd(b int) int extern
[pub] fun int._opBitOr(b int) int extern
[pub] fun int._opBitXor(b int) int extern
[pub] fun int._opBitShl(b int) int extern
[pub] fun int._opBitShr(b int) int extern

[pub] fun int.toStr() str extern
[pub] fun int.toI8() ?i8 extern
[pub] fun int.toByte() ?byte extern
[pub] fun int.toI16() ?i16 extern
[pub] fun int.toU16() ?u16 extern
[pub] fun int.toI32() ?i32 extern
[pub] fun int.toU32() ?u32 extern
[pub] fun int.toU64() ?u64 extern    
[pub] fun int.toF32() f32 extern
[pub] fun int.toFloat() float extern
[pub] fun int.toDecimal() Decimal extern
[pub] fun int.toI8Mask() i8 extern
[pub] fun int.toByteMask() byte extern
[pub] fun int.toI16Mask() i16 extern
[pub] fun int.toU16Mask() u16 extern
[pub] fun int.toI32Mask() i32 extern
[pub] fun int.toU32Mask() u32 extern
[pub] fun int.toU64Mask() u64 extern

[pub]
fun int.iterator() RangeIterator<int>
    ret RangeIterator<int>(0, my)

// 64 bit unsigned integer
[pub]
type u64 ro
    const __size int = 8
    const __align int = 8    
    const Zero u64 = 0
    const One u64 = 1
    const MinValue u64 = 0
    const MaxValue u64 = 18446744073709551615
    const NanOrMin u64 = MinValue

[pub] fun u64.getHash() int extern
[pub] fun u64._opEq(b u64) bool extern
[pub] fun u64._opCmp(b u64) int extern
[pub] fun u64._opIn(b Range<u64>) bool extern
[pub] fun u64._opRange(b u64) Range<u64> extern // TBD: Generic function on range?
[pub] fun u64._opAdd(b u64) u64 extern
[pub] fun u64._opSub(b u64) u64 extern
[pub] fun u64._opNeg() u64 extern
[pub] fun u64._opMul(b u64) u64 extern
[pub] fun u64._opDiv(b u64) u64 extern
[pub] fun u64._opRem(b u64) u64 extern
[pub] fun u64._opBitNot() u64 extern
[pub] fun u64._opBitAnd(b u64) u64 extern
[pub] fun u64._opBitOr(b u64) u64 extern
[pub] fun u64._opBitXor(b u64) u64 extern
[pub] fun u64._opBitShl(b int) u64 extern
[pub] fun u64._opBitShr(b int) u64 extern
[pub] fun u64._opBitShr(b u64) u64 extern
[pub] fun u64._opBitShl(b u64) u64 extern

[pub] fun u64.toStr() str extern
[pub] fun u64.toI8() ?i8 extern
[pub] fun u64.toByte() ?byte extern
[pub] fun u64.toI16() ?i16 extern
[pub] fun u64.toU16() ?u16 extern
[pub] fun u64.toI32() ?i32 extern
[pub] fun u64.toU32() ?u32 extern
[pub] fun u64.toInt() ?int extern
[pub] fun u64.toF32() f32 extern
[pub] fun u64.toFloat() float extern
[pub] fun u64.toDecimal() Decimal extern
[pub] fun u64.toI8Mask() i8 extern
[pub] fun u64.toByteMask() byte extern
[pub] fun u64.toI16Mask() i16 extern
[pub] fun u64.toU16Mask() u16 extern
[pub] fun u64.toI32Mask() i32 extern
[pub] fun u64.toU32Mask() u32 extern
[pub] fun u64.toIntMask() int extern

[pub]
fun u64.iterator() RangeIterator<u64>
    ret RangeIterator<u64>(0 u64, my)

[pub]
type I128 ro
    const __size int = 16
    const __align int = 16

[pub]
type U128 ro
    const __size int = 16
    const __align int = 16


[pub]
type f32 ro
    const __size int = 4
    const __align int = 4    
    const Zero f32 = 0
    const One f32 = 1
    const MinValue f32 = -3.40282347E+38F
    const MaxValue f32 = 3.40282347E+38F
    const NanOrMin f32 = MinValue    
    const epsilon f32 = 1.401298E-45F
    const infinity f32 = 1F/0F
    const negativeInfinity f32 = -1F/0F
    const nan f32 = 0f32/0f32
    const PI f32 = 3.141592653589793238
    const E f32 = 2.718281828459045235

[pub] fun f32.getHash() int extern
[pub] fun f32._opEq(b f32) bool extern
[pub] fun f32._opCmp(b f32) int extern
[pub] fun f32._opEqUnordered(b f32) bool extern
[pub] fun f32._opGtUnordered(b f32) bool extern
[pub] fun f32._opGeUnordered(b f32) bool extern
[pub] fun f32._opLtUnordered(b f32) bool extern
[pub] fun f32._opLeUnordered(b f32) bool extern
[pub] fun f32._opIn(b Range<f32>) bool extern
[pub] fun f32._opRange(b f32) Range<i32> extern // TBD: Generic function on range?
[pub] fun f32._opAdd(b f32) f32 extern
[pub] fun f32._opSub(b f32) f32 extern
[pub] fun f32._opNeg() f32 extern
[pub] fun f32._opMul(b f32) f32 extern
[pub] fun f32._opDiv(b f32) f32 extern
[pub] fun f32._opRem(b f32) f32 extern

[pub] fun f32.isInfinity() bool extern
[pub] fun f32.isNan() bool extern
[pub] fun f32.isNegInfinity() bool extern
[pub] fun f32.isPosInfinity() bool extern        

[pub] fun f32.toStr() str extern
[pub] fun f32.toByte() ?byte extern
[pub] fun f32.toInt() ?int extern
[pub] fun f32.toU64() ?u64 extern
[pub] fun f32.toFloat() float extern
[pub] fun f32.toDecimal() Decimal extern    
[pub] fun f32.toByteMask() byte extern
[pub] fun f32.toIntMask() int extern
[pub] fun f32.toU64Mask() u64 extern

[pub]
type float ro
    const __size int = 8
    const __align int = 8    
    const Zero float = 0
    const One float = 1
    const MinValue float = -1.7976931348623157E+308
    const MaxValue float = 1.7976931348623157E+308
    const NanOrMin float = MinValue    
    const epsilon float = 4.94065645841247E-324
    const infinity float = 1.0/0.0
    const negativeInfinity float = -1.0/0.0
    const nan float = 0Float/0Float
    const PI float = 3.141592653589793238
    const E float = 2.718281828459045235

[pub] fun float.getHash() int extern
[pub] fun float._opEq(b float) bool extern
[pub] fun float._opCmp(b float) int extern
[pub] fun float._opEqUnordered(b float) bool extern
[pub] fun float._opGtUnordered(b float) bool extern
[pub] fun float._opGeUnordered(b float) bool extern
[pub] fun float._opLtUnordered(b float) bool extern
[pub] fun float._opLeUnordered(b float) bool extern
[pub] fun float._opIn(b Range<float>) bool extern
[pub] fun float._opRange(b float) Range<float> extern // TBD: Generic function on range?
[pub] fun float._opAdd(b float) float extern
[pub] fun float._opSub(b float) float extern
[pub] fun float._opNeg() float extern
[pub] fun float._opMul(b float) float extern
[pub] fun float._opDiv(b float) float extern
[pub] fun float._opRem(b float) float extern

[pub] fun float.isInfinity() bool extern
[pub] fun float.isNan() bool extern
[pub] fun float.isNegInfinity() bool extern
[pub] fun float.isPosInfinity() bool extern        

[pub] fun float.toStr() str extern
[pub] fun float.toByte() ?byte extern
[pub] fun float.toInt() ?int extern
[pub] fun float.toU64() ?u64 extern
[pub] fun float.toDecimal() Decimal extern
[pub] fun float.toByteMask() byte extern
[pub] fun float.toIntMask() int extern
[pub] fun float.toU64Mask() u64 extern
[pub] fun float.toF32Clamp() f32 extern

// 128 bit decimal integer.  This will support nan, infinity, and
// exponents covering the entire range of float with more precision.
[pub]
type Decimal ro
    const __size int = 16
    const __align int = 16
    const Zero Decimal = 0
    const One Decimal = 1
    const MinValue Decimal = -1E+1000M
    const MaxValue Decimal = 1E+1000M
    const NanOrMin Decimal = MinValue    
    const infinity Decimal = 1.0/0.0
    const negativeInfinity Decimal = -1.0/0.0
    const nan Decimal = 0.0/0.0
    
[pub] fun Decimal.getHash() int extern
[pub] fun Decimal._opEq(b Decimal) bool extern
[pub] fun Decimal._opCmp(b Decimal) int extern
[pub] fun Decimal._opEqUnordered(b Decimal) bool extern
[pub] fun Decimal._opGtUnordered(b Decimal) bool extern
[pub] fun Decimal._opGeUnordered(b Decimal) bool extern
[pub] fun Decimal._opLtUnordered(b Decimal) bool extern
[pub] fun Decimal._opLeUnordered(b Decimal) bool extern
[pub] fun Decimal._opIn(b Range<Decimal>) bool extern
[pub] fun Decimal._opRange(b Decimal) Range<i32> extern // TBD: Generic function on range?
[pub] fun Decimal._opAdd(b Decimal) Decimal extern
[pub] fun Decimal._opSub(b Decimal) Decimal extern
[pub] fun Decimal._opNeg() Decimal extern
[pub] fun Decimal._opMul(b Decimal) Decimal extern
[pub] fun Decimal._opDiv(b Decimal) Decimal extern
[pub] fun Decimal._opRem(b Decimal) Decimal extern

[pub] fun Decimal.isInfinity() bool extern
[pub] fun Decimal.isNan() bool extern
[pub] fun Decimal.isNegInfinity() bool extern
[pub] fun Decimal.isPosInfinity() bool extern

[pub] fun Decimal.toStr() str extern
[pub] fun Decimal.toByte() ?byte extern
[pub] fun Decimal.toInt() ?int extern
[pub] fun Decimal.toU64() ?u64 extern
[pub] fun Decimal.toByteMask() byte extern
[pub] fun Decimal.toIntMask() int extern
[pub] fun Decimal.toU64Mask() u64 extern
[pub] fun Decimal.toIntClamp() int extern
[pub] fun Decimal.toF32Clamp() f32 extern
[pub] fun Decimal.toFloatClamp() float extern

