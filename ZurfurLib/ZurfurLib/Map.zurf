
mod Zurfur

use Zurfur[Iterator, Iterable, OpEq]


// Entries in the bucket list
type MapEntry(index u32, hash u32)


// Key value pair
[pub]
type KvPair<K,V>
        where K has OpEq<K>
    key K pub ref
    value V pub mut

// A map is a hash table
[pub]
type Map<K,V>
        where K has OpEq<K>
    _items List<KvPair<K,V>>
    _buckets List<MapEntry>



// TBD: Need this: fun (kv Map<K,V>.Pair) ...
[pub]
fun new<K,V>(kv KvPair<K,V>, key own K, value own V)
    kv.key = key
    kv.value = value


[pub]
fun new<K,V>(m Map<K,V>, capacity int)
    extern
    
[pub]
fun new<K,V>(m Map<K,V>, keyValues Iterator<KvPair<K, V>>)
    extern
    
[pub]
fun get len<K,V>(my m Map<K,V>) int
    extern

// TBD: Figure out map["Hello"] += 1
[pub]
fun _opIndex<K,V>(my static m Map<K,V>, map Map<K, V>, key K) mut ?&V
    extern

// TBD: An indexer with 3 inputs???
[pub]
fun _opIndex<K,V>(my static m Map<K,V>, map Map<K, V>, key K, item V)
    extern

[pub]
fun contains<K,V>(my m Map<K,V>, key K) bool
    extern

// TBD: Return Iterable<(K, V)>???
[pub]
fun get iterator<K,V>(my m Map<K,V>) mut Iterator<KvPair<K, V>>
    extern

[pub]
fun get keys<K,V>(my m Map<K,V>) Iterator<K>
    extern

[pub]
fun get values<K,V>(my m Map<K,V>) mut Iterator<V>
    extern

[pub]
fun clear<K,V>(my m mut Map<K,V>)
    extern

[pub]
fun add<K,V>(my m mut Map<K,V>, item KvPair<K, V>)
    extern

[pub]
fun add<K,V>(my m mut Map<K,V>, items Iterator<KvPair<K, V>>)
    extern

[pub]
fun remove<K,V>(my m mut Map<K,V>, key K) bool
    extern

    