

mod Zurfur

use Zurfur[OpEq]

// []T is converted to Span<T>
[pub]
type Span<T> ref copy
    data ro mut &T
    len ro int


[pub]
type SpanIterator<T> ref copy
    data ro mut &T
    _len ro int
    _count ro int
    
[pub]
fun _opIndex<T>(my static st Span<T>, s Span<T>, i int) mut &T
    require(i in 0..s.len)
    todo // Implementation TBD

[pub]
fun _opIndex<T>(my static st Span<T>, s Span<T>, range Range<int>) mut Span<T>
    require(range.low in 0..s.len)
    require(range.high in 0..s.len)
    require(range.low <= range.high)
    todo // Implementation TBD

[pub]
fun sort<T>(my st mut Span<T>, compare fun(a T, b T)bool)
    todo

// Set the span to `item` (or default if not specified)
[pub]
fun clear<T>(my s mut Span<T>, item T = default)
    todo
    
// Find index of the sequence `seq`.
// Returns -1 if not found, or 0 if `seq` is empty.
[pub]
fun find<T>(my s Span<T>, seq Span<T>) int
        where T has OpEq<T>
    todo

// Find the index of the `item`.  Returns -1 if not found.
[pub]
fun find<T>(my s Span<T>, item T) int
        where T has OpEq<T>
    todo
    
// Find the index of the `item` when `eq` returns true.
// Returns -1 if not found.
[pub]
fun find<T>(my s Span<T>, eq fun(item T) bool) int
    todo

        