//pragma ShowParse        // Show the parse tree (hover over a symbol)
//pragma ShowMeta       // Show parser symbols
//pragma NoParse
//pragma RequireBraces

// Press F4 to see header file report


// http://zurfur.com
mod TestExample

use Zurfur
use Zurfur[Decimal, Log, Iterator, NumOps]
use Zurfur.Math[cos,sin]
use Zurfur.ConvertBytes[bytesToHex]

// Simple types have public fields:
[pub] type SimpleType(firstName Str, lastName Str)
[pub] type SimpleImmutableType ro(firstName Str, fastName Str)

// Define a type
[pub]
type MyType
    text Str                // Public
    _misc Str               // Private
    _list List<Int> pub ref // Private with pub ro

// Declare a method to multiply and add three keys on Map<K,V>.
// Return Nan (or MinValue for integer types) if any key is missing.
fun Map.madd<K,V>(mul1 K, mul2 K, add K) V
        where V has NumOps<V>
    if my[mul1]@mul1Val and my[mul2]@mul2Val and my[add]@addVal
        ret mul1Val * mul2Val + addVal
    ret V.NanOrMin        

// Method
[pub]
fun MyType.countToTen()
    Log.info("Hello world.  Let's count to 10.")
    for @i in 1..+10
        Log.info("Count={i}, text={my.text}")

// Setter for list, which is already public read-only
[pub]
fun set MyType.list(v own List<Int>)
    my._list = v
    my.mapChangedEvent()

fun MyType.mapChangedEvent() {}

fun hello() {}

fun test_HelloWorld()
    Log.info("Hello World.  Let's count from 1 to 10.")
    for @i in 1..11
        Log.info("Count={a}")

    @a = "Regular string literal"       // No interpolation
    @b = "Column 1{\t}Column 2{\n}"     // Containing a tab, ending with \n
    @c = tr"Translated string"          // Translated at runtime
    @d = "Hello world, a+b={a+b}{\n}"   // Interpolated with \n at the end
    @e = tr"Hello world, X={X}!{\n}"    // Translated, interpolated, \n at end
    @g = """{"X":1,"Y":2}"""            // Containing quote
    @h = """{"X":${x},"Y":2}"""         // Containing quote and interpolated

    @t1 = circle2(1, 2.0)
    @t1r1 = t1.x
    @t1r2 = t1.y

            
[pub]
fun circle(a Float, r Float)(x Float, y Float)
    @q = circle(1.0,2.0)
    @p = q.x
    ret (cos(a)*r, sin(a)*r)

fun circle2<T0, T1>(a T0, r T1)(x T0, y T1)
    ret (T0(), T1())

[pub] type Example
    
    a1 Str
    a2 Str = "Hello"
    a3 List<Str> = ["Hello", "World"]
    a4 List<Int> = [1,2]
    a5 List<Int> pub ref
    a6 List<Int> pub mut
    a7 List<Int> pub mut
    //pub a8 List<Int>
    //pub a9 private set List<Int>
    //pub private set a9 List<Int>

    map1 ro Map<Str,Int> = ["A":1,"B":2]        // Immutable map
    map2 ro mut Map<Str,Int> = ["A":1,"B":2]    // Can't be assigned, can be mutated
    map3 ro Map<Str,Int> pub init               // Read only, init in constructor or allow public init
    
    a Zim<Void>
    c Zim<I8>
    e Zim<Byte>
    f Zim<I16>
    g Zim<U16>
    h Zim<I32>
    i Zim<U32>
    j Zim<Int>
    m Zim<Float>
    n Zim<F32>
    o Zim<Str>
    p Zim<Decimal>

[pub]
type Zim<T>
    q T pub mut

// Type test for test_main
type Token(a Int)
fun AcceptMatch(m Str) ?Token
    ret nil

// This is a public documentation comment.  Do not use XML.
// Use `name` to refer to variables in the code.
[pub]
fun test_Main(args Array<Str>, stream Zurfur.Io.Reader)

    // This is a regular private comment
    Log.info("Hello World, 2+2={2+2}")

    @v = ""
    //@myStrings = ["a", "b", "c"]
    @myStrings = Array<Str>()

    if myStrings[1]@q == "x"
        v = "x"
    elif q == "y" or q=="z"
        v = "y or z"
    elif q >= "a" or q <= "z"
        v = "lower"
    elif q >= "A" or q <= "Z"
        v = "upper"
    else
        v = "none"
    
    @a = tr"Column 1{\t}Column 2{\rn}"
    @data = "Name:{name}{\t}Occupation:{lastName}{\rn}"
    @buffer = Buffer<Byte>()
    
    while stream.read(buffer[0..4])!@size == 4
        @bytes = buffer[0..4].bytesToHex(false) // TBD: Scan use statements for extension methods

    // AcceptMatch returns ?Token = (Bool, Token)
    // @Token captures the token, leaving the Bool
    if AcceptMatch("(")@Token
    {
        // We got a token
    }


    ret

