using a.b.c;
using system.gosub.p;

namespace zurfur.example;


// Test class
class Example 
{ 
	static func main(args array<string>)
	{
	}
}

/// Implement IHashable on any object that can be stored in a Map.
/// This is different than implementing just Equals
/// in that NAN must compare to itself as true.
interface IHashable<in T>
{
	static func GetHashCode(a T) uint;
	static func Equals(a T, b T) bool;
}

/// Implement ISortable on any object that can be sorted.
/// This is different than implementing just Compare
/// in that NAN must have a valid sort order.
interface ISortable<in T>
{
	static func Compare(a T, b T) int;
}

/// bool (true or false), implemented by the compiler
struct bool
{
	pub static extern func GetHashCode(a bool) uint;
	pub static extern func Equals(a bool, b bool) bool;
	pub static extern func Compare(a bool, b bool) int;

    // Not overloadable, but these are supplied specially for this type
    //pub static extern func operator!(a bool);
    //pub static extern func operator||(a bool, b bool);
    //pub static extern func operator&&(a bool, b bool);
}

/// int8 (-128..127), implemented by the compiler
struct int8
{
    pub extern func new(from uint8);
    pub extern func new(from int16);
    pub extern func new(from uint16);
    pub extern func new(from int32);
    pub extern func new(from uint32);
    pub extern func new(from int64);
    pub extern func new(from uint64);
    pub extern func new(from float32);
    pub extern func new(from float64);
    pub extern func new(from decimal);
    // TBD: Implicit conversion to int (and assign to int16, etc.)

	pub static ro MaxValue = int8(127);	
    pub static ro MinValue = int8(-128);
	pub static extern func GetHashCode(a int8) uint;
	pub static extern func Equals(a int8, b int8) bool;
	pub static extern func Compare(a int8, b int8) int;
}

/// byte (0..255) same as uint8, implemented by the compiler
struct byte = uint8;

/// uint8 (0..255) same as byte, implemented by the compiler
struct uint8
{
    pub extern func new(from int8);
    pub extern func new(from int16);
    pub extern func new(from uint16);
    pub extern func new(from int32);
    pub extern func new(from uint32);
    pub extern func new(from int64);
    pub extern func new(from uint64);
    pub extern func new(from float32);
    pub extern func new(from float64);
    pub extern func new(from decimal);
    // TBD: Implicit conversion to int (and assign to int16, etc.)

	pub static ro MaxValue = uint8(255);	
    pub static ro MinValue = uint8(0);
	pub static extern func GetHashCode(a uint8) uint;
	pub static extern func Equals(a uint8, b uint8) bool;
	pub static extern func Compare(a uint8, b uint8) int;
}

/// int16 (-32768..32768), implemented by the compiler
struct int16
{
    pub extern func new(from int8);
    pub extern func new(from uint8);
    pub extern func new(from uint16);
    pub extern func new(from int32);
    pub extern func new(from uint32);
    pub extern func new(from int64);
    pub extern func new(from uint64);
    pub extern func new(from float32);
    pub extern func new(from float64);
    pub extern func new(from decimal);
    // TBD: Implicit conversion to int, etc.

	pub static ro MaxValue = int16(32767);	
    pub static ro MinValue = int16(-32768);
	pub static extern func GetHashCode(a int16) uint;
	pub static extern func Equals(a int16, b int16) bool;
	pub static extern func Compare(a int16, b int16) int;
}


/// uint16 (0..65535), implemented by the compiler
struct uint16
{
    pub extern func new(from int8);
    pub extern func new(from uint8);
    pub extern func new(from int16);
    pub extern func new(from int32);
    pub extern func new(from uint32);
    pub extern func new(from int64);
    pub extern func new(from uint64);
    pub extern func new(from float32);
    pub extern func new(from float64);
    pub extern func new(from decimal);
    // TBD: Implicit conversion to int, etc.

	pub static ro MaxValue = uint16(65535);	
    pub static ro MinValue = uint16(0);
	pub static extern func GetHashCode(a uint16) uint;
	pub static extern func Equals(a uint16, b uint16) bool;
	pub static extern func Compare(a uint16, b uint16) int;
}

/// A 32 bit integer (same as int32), implemented by the compiler
struct int = int32;

/// A 32 bit integer (same as int), implemented by the compiler
struct int32
{
    pub extern func new(from int8);
    pub extern func new(from uint8);
    pub extern func new(from int16);
    pub extern func new(from uint16);
    pub extern func new(from uint32);
    pub extern func new(from int64);
    pub extern func new(from uint64);
    pub extern func new(from float32);
    pub extern func new(from float64);
    pub extern func new(from decimal);
    // TBD: Implicit conversion to long, etc.

	pub static ro MaxValue = int32(2147483647);	
    pub static ro MinValue = int32(-2147483648);

    // Comparisons    
	pub static extern func GetHashCode(a int32) uint;
	pub static extern func Equals(a int32, b int32) bool;
	pub static extern func Compare(a int32, b int32) int;

    // Overloadable operators
    pub static extern func operator+(a int32);
    pub static extern func operator-(a int32);
    pub static extern func operator+(a int32, b int32);
    pub static extern func operator-(a int32, b int32);
    pub static extern func operator*(a int32, b int32);
    pub static extern func operator/(a int32, b int32);
    pub static extern func operator%(a int32, b int32);

    // Not overloadable, but these are supplied specially for this type
    pub static extern func operator~(a int32);
    pub static extern func operator|(a int32, b int32);
    pub static extern func operator&(a int32, b int32);
    pub static extern func operator^(a int32, b int32);
    pub static extern func operator<<(a int32, b int32);
    pub static extern func operator>>(a int32, b int32);    
}

/// 32 bit unsigned integer (same as uint32), implemented by compiler
struct uint = uint32;

/// 32 bit unsigned integer (same as uint), implemented by compiler
struct uint32
{
    pub extern func new(from int8);
    pub extern func new(from uint8);
    pub extern func new(from int16);
    pub extern func new(from uint16);
    pub extern func new(from int32);
    pub extern func new(from int64);
    pub extern func new(from uint64);
    pub extern func new(from float32);
    pub extern func new(from float64);
    pub extern func new(from decimal);
    // TBD: Implicit conversion to long, etc.

	pub static ro MaxValue = uint32(0);	
    pub static ro MinValue = uint32(4294967295);

    // Comparisons    
	pub static extern func GetHashCode(a uint32) uint;
	pub static extern func Equals(a uint32, b uint32) bool;
	pub static extern func Compare(a uint32, b uint32) int;
    
    // Overloadable operators
    pub static extern func operator+(a uint32);
    pub static extern func operator-(a uint32);
    pub static extern func operator+(a uint32, b uint32);
    pub static extern func operator-(a uint32, b uint32);
    pub static extern func operator*(a uint32, b uint32);
    pub static extern func operator/(a uint32, b uint32);
    pub static extern func operator%(a uint32, b uint32);

    // Not overloadable, but these are supplied specially for this type
    pub static extern func operator~(a uint32);
    pub static extern func operator|(a uint32, b uint32);
    pub static extern func operator&(a uint32, b uint32);
    pub static extern func operator^(a uint32, b uint32);
    pub static extern func operator<<(a uint32, b uint32);
    pub static extern func operator>>(a uint32, b uint32);
}


/// A 64 bit integer, implemented by the compiler
struct int64
{
    pub extern func new(from int8);
    pub extern func new(from uint8);
    pub extern func new(from int16);
    pub extern func new(from uint16);
    pub extern func new(from int32);
    pub extern func new(from uint32);
    pub extern func new(from uint64);
    pub extern func new(from float32);
    pub extern func new(from float64);
    pub extern func new(from decimal);
    // TBD: Implicit conversion to decimal, etc.

	pub static ro MaxValue = int64(9223372036854775807);	
    pub static ro MinValue = int64(-9223372036854775808);

    // Comparisons    
	pub static extern func GetHashCode(a int64) uint;
	pub static extern func Equals(a int64, b int64) bool;
	pub static extern func Compare(a int64, b int64) int;

    // Overloadable operators
    pub static extern func operator+(a int64);
    pub static extern func operator-(a int64);
    pub static extern func operator+(a int64, b int64);
    pub static extern func operator-(a int64, b int64);
    pub static extern func operator*(a int64, b int64);
    pub static extern func operator/(a int64, b int64);
    pub static extern func operator%(a int64, b int64);

    // Not overloadable, but these are supplied specially for this type
    pub static extern func operator~(a int64);
    pub static extern func operator|(a int64, b int64);
    pub static extern func operator&(a int64, b int64);
    pub static extern func operator^(a int64, b int64);
    pub static extern func operator<<(a int64, b int64);
    pub static extern func operator>>(a int64, b int64);    
}

/// 64 bit unsigned integer, implemented by compiler
struct uint64
{
    pub extern func new(from int8);
    pub extern func new(from uint8);
    pub extern func new(from int16);
    pub extern func new(from uint16);
    pub extern func new(from int32);
    pub extern func new(from uint32);
    pub extern func new(from int64);
    pub extern func new(from float32);
    pub extern func new(from float64);
    pub extern func new(from decimal);
    // TBD: Implicit conversion to decimal, etc.

	pub static ro MaxValue = uint64(0);	
    pub static ro MinValue = uint64(18446744073709551615);

    // Comparisons    
	pub static extern func GetHashCode(a uint64) uint;
	pub static extern func Equals(a uint64, b uint64) bool;
	pub static extern func Compare(a uint64, b uint64) int;
    
    // Overloadable operators
    pub static extern func operator+(a uint64);
    pub static extern func operator-(a uint64);
    pub static extern func operator+(a uint64, b uint64);
    pub static extern func operator-(a uint64, b uint64);
    pub static extern func operator*(a uint64, b uint64);
    pub static extern func operator/(a uint64, b uint64);
    pub static extern func operator%(a uint64, b uint64);

    // Not overloadable, but these are supplied specially for this type
    pub static extern func operator~(a uint64);
    pub static extern func operator|(a uint64, b uint64);
    pub static extern func operator&(a uint64, b uint64);
    pub static extern func operator^(a uint64, b uint64);
    pub static extern func operator<<(a uint64, b uint64);
    pub static extern func operator>>(a uint64, b uint64);
}

struct float32
{
    pub extern func new(from int8);
    pub extern func new(from uint8);
    pub extern func new(from int16);
    pub extern func new(from uint16);
    pub extern func new(from int32);
    pub extern func new(from uint32);
    pub extern func new(from int64);
    pub extern func new(from uint64);
    pub extern func new(from float64);
    pub extern func new(from decimal);
    // TBD: Implicit conversion to decimal, etc.


	// Normal float32 comparisons (NAN==NAN is false)
    // TBD: Maybe we don't need funny NAN comparisons since we're starting fresh?
	pub static extern func Equals(a float32, b float32) bool;
	pub static extern func Compare(a float32, b float32) int;
	
	// Comparisons for sorting (NAN>infinity and NAN==NAN are both true)
	pub static extern func GetHashCode(a float32) uint;
	pub static extern func IHashable<float32>.Equals(a float32, b float32) bool;
	pub static extern func ISortable<float32>.Compare(a float32, b float32) int;

    pub static ro MinValue = float32(-3.40282347E+38F);
    pub static ro MaxValue = float32(3.40282347E+38F);
    pub static ro Epsilon = float32(1.401298E-45F);
    pub static ro PositiveInfinity = float32(1F/0F);
    pub static ro NegativeInfinity = float32(-1F/0F);
    pub static ro NaN = float32(0F/0F);
    pub extern func get IsInfinity() bool;
    pub extern func get IsNaN() bool;
    pub extern func get IsNegativeInfinity() bool;
    pub extern func get IsPositiveInfinity() bool;

	
    // Overloadable operators
    pub static extern func operator+(a float32);
    pub static extern func operator-(a float32);
    pub static extern func operator+(a float32, b float32);
    pub static extern func operator-(a float32, b float32);
    pub static extern func operator*(a float32, b float32);
    pub static extern func operator/(a float32, b float32);
    pub static extern func operator%(a float32, b float32);	
    pub static extern func operator**(a float32, b float32);
}

struct float64
{
    pub extern func new(from int8);
    pub extern func new(from uint8);
    pub extern func new(from int16);
    pub extern func new(from uint16);
    pub extern func new(from int32);
    pub extern func new(from uint32);
    pub extern func new(from int64);
    pub extern func new(from uint64);
    pub extern func new(from float32);
    pub extern func new(from decimal);
    // TBD: Implicit conversion to decimal, etc.

	// Normal float64 comparisons (NAN==NAN is false)
    // TBD: Maybe we don't need funny NAN comparisons since we're starting fresh?
	pub static extern func Equals(a float64, b float64) bool;
	pub static extern func Compare(a float64, b float64) int;
	
	// Comparisons for sorting (NAN>infinity and NAN==NAN are both true)
	pub static extern func GetHashCode(a float64) uint;
	pub static extern func IHashable<float32>.Equals(a float64, b float64) bool;
	pub static extern func ISortable<float32>.Compare(a float64, b float64) int;

    pub static ro MinValue = float64(-1.7976931348623157E+308);
    pub static ro MaxValue = float64(1.7976931348623157E+308);
    pub static ro Epsilon = float64(4.94065645841247E-324);
    pub static ro PositiveInfinity = float64(1.0/0.0);
    pub static ro NegativeInfinity = float64(-1.0/0.0);
    pub static ro NaN = float64(0.0/0.0);
    pub extern func get IsInfinity() bool;
    pub extern func get IsNaN() bool;
    pub extern func get IsNegativeInfinity() bool;
    pub extern func get IsPositiveInfinity() bool;
	
    // Overloadable operators
    pub static extern func operator+(a float64);
    pub static extern func operator-(a float64);
    pub static extern func operator+(a float64, b float64);
    pub static extern func operator-(a float64, b float64);
    pub static extern func operator*(a float64, b float64);
    pub static extern func operator/(a float64, b float64);
    pub static extern func operator%(a float64, b float64);	
    pub static extern func operator**(a float64, b float64);
}

/// 128 bit decimal integer.  This will support NAN, infinity, and
/// exponents covering the range of double.
struct decimal
{
    pub extern func new(from int8);
    pub extern func new(from uint8);
    pub extern func new(from int16);
    pub extern func new(from uint16);
    pub extern func new(from int32);
    pub extern func new(from uint32);
    pub extern func new(from int64);
    pub extern func new(from uint64);
    pub extern func new(from float32);
    pub extern func new(from float64);

	pub static ro MaxValue = decimal(1E+1000M);	
    pub static ro MinValue = decimal(-1E+1000M);
    pub static ro PositiveInfinity = decimal(1.0/0.0);
    pub static ro NegativeInfinity = decimal(-1.0/0.0);
    pub static ro NaN = decimal(0.0/0.0);
    pub extern func get IsInfinity() bool;
    pub extern func get IsNaN() bool;
    pub extern func get IsNegativeInfinity() bool;
    pub extern func get IsPositiveInfinity() bool;

    // Comparisons.  NOTE: NaN > infinity, and NaN==NaN is true
	pub static extern func GetHashCode(a decimal) uint;
	pub static extern func Equals(a decimal, b decimal) bool;
	pub static extern func Compare(a decimal, b decimal) int;
    
    // Overloadable operators
    pub static extern func operator+(a decimal);
    pub static extern func operator-(a decimal);
    pub static extern func operator+(a decimal, b decimal);
    pub static extern func operator-(a decimal, b decimal);
    pub static extern func operator*(a decimal, b decimal);
    pub static extern func operator/(a decimal, b decimal);
    pub static extern func operator%(a decimal, b decimal);

    // Not overloadable, but these are supplied specially for this type
    pub static extern func operator~(a decimal);
    pub static extern func operator|(a decimal, b decimal);
    pub static extern func operator&(a decimal, b decimal);
    pub static extern func operator^(a decimal, b decimal);
    pub static extern func operator<<(a decimal, b decimal);
    pub static extern func operator>>(a decimal, b decimal);
}


pub ro struct string
{
	pub static ro Empty = new Array<byte>[0];
    ro str = Array<byte>;

    pub func new(s string) { todo() }
    pub func new(s Span<byte>) { todo() }
    pub func Slice(start int, length int) RoSpan<byte> { todo() }
    pub func Slice(start int) RoSpan<byte> { todo() }
    
    pub static extern func operator+(s1 string, s2 string);    
    pub static extern func operator+(s1 RoSpan<byte>, s2 string);    
    pub static extern func operator+(s1 string, s2 RoSpan<byte>);
    // TBD: Implicit conversion to and from RoSpan
}

pub ro ref struct Span<T>
{
    pub ro Data  = *T;
    pub ro Length = int;
    pub func get[index int] ref T { todo(); }
    pub func Slice(start int, length int) Span<T> { todo(); }
    // TBD: implicit conversion to RoSpan
}

// TBD: Do we wanto to have "struct ro Span" so we don't need another definition for RoSpan?
pub ro ref struct RoSpan<T>
{
    pub ro Data  = *T;
    pub ro Length = int;
    pub func get[index int] ro ref T { todo(); }
    pub func Slice(start int, length int) RoSpan<T> { todo(); }
}

// All variable sized objects must inherit from this class, must be sealed, and
// must call AllocateObject first thing in the constructor.  For efficiency,
// this class is unsafe and doesn't do any bounds checking.
// The inheriting class must be sealed (that's what sealed1 means)
pub sealed1 unsafe class  VariableSizedObject<T>
{
    pub ro Length = int;

    // Must be called first thing from the constuctor, never called again
    protected unsafe static func AllocateObject(int length) { todo() }

    // Return a pointer to the array
    // { return (T*)((iptr)this + sizeof(this))}
    protected unsafe func get DataPointer() *T {todo()}
}


// Array of constant size
pub sealed class Array<T> : VariableSizedObject<T>
{
    pub static ro MaxSize = int(int.MaxInt/2);
    pub static ro Empty = new T[0];

    pub func new[length int] { todo }
    pub func get[index int] ref T { todo }
    pub func Slice(start int, length int) Span<T> { todo }
    pub func RoSlice(start int, length int) Span<T> { todo }
}

// Note that the list class has a ref return indexer, just like Array
pub sealed class List<T> : VariableSizedObject<T>
{
	pub func new(capacity int) { todo() }
	pub func get[index int] ref T { todo() }
}

pub sealed class Map<TKey, TValue>
{
	pub func new(capacity int) { todo() }
}

// The matrix class is used to implement square 2d arrays
pub sealed class Matrix2d<t> : VariableSizedObject<T>
{
	pub func new[len1 int, len2 int] { todo() }	
    pub func get[i1 int, i2 int] ref T { todo() }
}

interface IGeneric<Q>
{
    func A<T>(Q m) int;
}

class MyGeneric<QQ> : IGeneric<QQ>
{
    func IGeneric<QQ>.A<T>(QQ a) int { }
}


/// Compiler implemented interface created for all structs that are blittable.
/// A blittable struct does not contain references, but may contain pointers.
interface IBlittableStruct { }

// Represents a buffer in un-managed memory.  This class can create and 
// own the memory, or it can be attached to an already existing buffer.
// The GC knows this class and deletes the memory when necessary.
// TBD: Should this whole class be unsafe?
sealed class UnmanagedMemory<T> : UnmanagedHande where T IBlittableStruct
{
    Memory =ipointer;
    Length = int;
    Allocscheme = AllocationScheme;

    enum AllocationScheme
    {
        GcOwned = 0;
        UnmanagedMemory = 1;
    }

    // Create the buffer, the GC owns it and deletes it when there are no more
    // references to this object.  Be careful that unmanaged code doesn't
    // hold a reference to the memory beyond the lifetime of this object
    pub func new[lenght int] { todo }

    // Attach this object to a buffer allocated by unmanaged code.  Be sure that
    // unmanaged code doesn't delete the object while still in use.
    unsafe pub func new(length int, data ipointer, sizeofbufferinbytes int) { todo() }

    pub func CopyTo() { todo() }

    // I have mixed feelings about Dispose.  On the one hand, shouldn't the
    // GC just deal with all memory objects?  It's good enough for `new
    // int[1000]`.  OTOH, it feels good to allow the user to free up the
    // unused memory.  TBD: Do not implement this for now since we have
    // escape analysis and `owned` to deal with the easy cases.
    // pub func Dispose() { throw new NeverImplemet(); }
}


// An iptr is a pointer that allows arithmetic operations unsing
// integers.  It is 32 bits or 64 bits depending on the implemnetation.
// Currently, WebAssembly has only 1 implementation which is 32 bits.
pub unsafe struct iptr
{
}

// Pointers are not tracked by the GC.  If you have a pointer to an
// object, make sure you also have a managed reference that lives
// as long as the object. 
pub unsafe struct pointer<T : where T struct>
{
    pub Pointer = ipointer;
}

// This is the base for all objects, struct and class alike.
pub class object
{
    pub virtual func GetType() { todo }
    pub virtual func ToString() { todo }
}

// This is the base for all struct objects.
pub class StructObject
{
}

// This is the base for all class objects.  Its only field is
// the vtable pointer, so there is minimal overhead.  All class
// objects are allocated on the managed heap and are subject
// to garbage collection.
pub class ClassObject
{
    // The only member
    protected unsafe ro VT = iptr;

    pub override func GetType() { todo }
}


// Base class for all things that need to notify when they are garbage collected
class FinalizedNotify 
{
    protected func SetFinalizeNotifier(notifierQueue FinalizedNotifyQueue, token IntPtr, memoryPressure int) { todo() }
    protected func ClearFinalizeNotifier() { todo() }
}
class FinalizedNotifyQueue 
{
    func get Count() int { todo() }
    func Dequeue() IntPtr { todo() }
    async func WaitQueueNotEmpty() { todo() }
}

static func memcpy(to IntPtr, from IntPtr, length int)
{
    if length <= 0
        { return; }

    // Align `to` on int32
    while to & 3 != 0 && length != 0
    	{ *(*byte)to = *(*byte)from; to+=1; from+=1; length-=1; }

    if (to|from) & 3 == 0
    {
        memcpya32(to, from, length);
        return;
    }
    // Byte copy
    #end = to + length;
    while end-to >= 4
    {
        *(*byte)to = *(*byte)from; to+=1; from+=1;
        *(*byte)to = *(*byte)from; to+=1; from+=1;
        *(*byte)to = *(*byte)from; to+=1; from+=1;
        *(*byte)to = *(*byte)from; to+=1; from+=1;
    } 
    while to != end
    	{ *(*byte)to = *(*byte)from; to+=1; from+=1; }
}

static func memcpya32(to IntPtr, from IntPtr, length int)
{
    if length <= 0
        { return }
    if (to|from) & 3 != 0
        { throw new MisalignedMemoryAccessException(); }

    // Try 64 bit copy first
    #end = to + length;
    if (to^from) & 7 == 0 && length >= 8
    {
        if to & 7 != 0
            { *(*int32)to = *(*int32)from; to+=4; from+=4; }

        while end - to >= 32
        {
            *(*int64)to = *(*int64)from; to+=8; from+=8;
            *(*int64)to = *(*int64)from; to+=8; from+=8;
            *(*int64)to = *(*int64)from; to+=8; from+=8;
            *(*int64)to = *(*int64)from; to+=8; from+=8;
        }
        while end - to >= 8
            { *(*int64)to = *(*int64)from; to+=8; from+=8;  } 
    }
    while end-to >= 16
    {
        *(*int32)to = *(*int32)from; to+=4; from+=4;
        *(*int32)to = *(*int32)from; to+=4; from+=4;
        *(*int32)to = *(*int32)from; to+=4; from+=4;
        *(*int32)to = *(*int32)from; to+=4; from+=4;
    }
    while end-to >= 4
        { *(*int32)to = *(*int32)from; to+=4; from+=4; } 
    while to != end
        { *(*byte)to = *(*byte)from; to+=1; from+=1; } 
}

 