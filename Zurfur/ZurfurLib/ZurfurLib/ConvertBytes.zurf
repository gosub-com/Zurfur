
// Low level byte conversions are little endian regardless
// of platform.  Floating point formats are IEEE.
//
// Most conversions have 3 overloads:
//     (s Span<byte>) bytesToType()
//     (s Span<byte>) setBytesType(value type)
//     (l List<byte>) pushBytesType(value type)
//
// Examples:
//     @myU32 = myList[index::4].bytesToU32()
//     myList[index::4].setBytesU32(myU32)
//     myList.pushBytesU32(myU32)
//
module Zurfur.ConvertBytes


fun Test_ConvertExample()
    @myU32 = myList[index..+4].bytesToU32()
    myList[index..+4].setBytesU32(myU32)
    myList.pushBytesU32(myU32)


pub fun (Span<byte>) bytesToHex(capitalize bool = false) str {todo()}
pub fun (mut List<byte>) pushBytesToHex(bytes []byte, capitalize bool = false) { todo() }
pub fun (mut List<byte>) pushHexToBytes(hex []byte) throws {todo()}


// Convert 4 bytes (u32) to int (little endian)
pub fun (Span<byte>) bytesToU32() u32
    require count == 4
    return     this[0].u32()
            + (this[1].u32() << 8)
            + (this[2].u32() << 16)
            + (this[3].u32() << 24)

// Convert u32 to 4 bytes (little endian) 
pub fun (mut Span<byte>) setBytesU32(v u32)
    require count == 4
    this[0] = v.byteMask()
    this[1] = (v<<8).byteMask()
    this[2] = (v<<16).byteMask()
    this[3] = (v<<24).byteMask()

// Convert u32 to 4 bytes (little endian) and push to list
pub fun (mut List<byte>) pushBytesU32(v u32)
    pushDup(0, 4)
    this[count-4..+4].setBytesU32(v)


pub fun (Span<byte>) bytesToI32() i32
    require count == 4
    return bytesToU32().i32Mask()
    
pub fun (mut Span<byte>) setBytesI32(v i32)
    require count == 4
    setBytesU32(v.u32Mask())
    
pub fun (mut List<byte>) pushBytesI32(v i32)
    pushBytesU32(v.u32Mask())


pub fun (Span<byte>) bytesToU16() u16 require count == 2 { todo() }
pub fun (mut Span<byte>) setBytesU16(v u16) require count == 2 { todo() }
pub fun (mut List<byte>) pushBytesU16(v u16) { todo() }

pub fun (Span<byte>) bytesToI16() i16 require count == 2 { todo() }
pub fun (mut Span<byte>) setBytesI16(v i16) require count == 2 { todo() }
pub fun (mut List<byte>) pushBytesI16(v i16) { todo() }


pub fun (Span<byte>) bytesToUint() uint require count == 8 { todo() }
pub fun (mut Span<byte>) setBytesUint(v uint) require count == 8 { todo() }
pub fun (mut List<byte>) pushBytesUint(v uint) { todo() }


pub fun (Span<byte>) bytesToInt() int require count == 8 { todo() }
pub fun (mut Span<byte>) setBytesInt(v int) require count == 8 { todo() }
pub fun (mut List<byte>) pushBytesInt(v int) { todo() }

pub fun (Span<byte>) bytesToF32() f32 require Count == 4 { todo() }
pub fun (mut Span<byte>) setBytesF32(v f32) require count == 4 { todo() }
pub fun (mut List<byte>) pushBytesF32(v f32) { todo() }

pub fun (Span<byte>) bytesToF64() f64 require count == 8 { todo() }
pub fun (mut Span<byte>) setBytesF64(v f64) require count == 8 { todo() }
pub fun (mut List<byte>) pushBytesF64(v f64) { todo() }

   