

module Zurfur.Io


interface Reader
    afun mut read(data mut []byte) int throws impl

interface Writer
    afun mut write(data []byte) int throws impl
    afun mut flush() throws impl

enum SeekOrigin
    Begin; Current; End

interface Seeker
    afun mut seek(offset int, origin SeekOrigin) int throws impl
    
aget (s Seeker) length() int throws { todo() }
aget (s Seeker) position() int throws { todo() }
aset (s Seeker) position(value int) throws { todo() }

interface FileStream { }

module Zurfur.Io.File

afun open(fileName str, mode str="r") FileStream throws { }
afun readAllText(fileName str) List<str> throws { }
afun readAllBytes(fileName str) List<byte> throws { }
afun writeAllText(fileName str, data List<str>) throws { }
afun writeAllBytes(fileName str, data List<byte>) throws{ }

// TBD: It's probably better to have cancellation built
//      into the async system.  Maybe progress too.
type CancellationToken {}
type Progress(bytesTotal int, bytesTransferred int)
afun readAllText(
    fileName str,
    cancel CancellationToken,
    progress ?fun (p Progress) = null) throws { }