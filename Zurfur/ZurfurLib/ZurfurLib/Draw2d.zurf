
use Zurfur

/// Basic shapes for use with 2d drawing library
module Zurfur.Draw2d

fun test_Shape():
    @rect = Rect<int>(1,2,3,4)
    rect.Location.Y = 30 // This should work
    Assert(rect == Rect<int>(1,30,3,4))
    

type passcopy Point<T>(X T, Y T)
    where T is IArithmetic<T>
{
    fun operator+(a Point<T>, b Point<T>) { return Point(a.X+b.X, a.Y+b.Y) }
    fun operator-(a Point<T>) { return Point(-a.X, -a.Y) }
    fun operator-(a Point<T>, b Point<T>) { return Point(a.X-b.X, a.Y-b.Y) }
    fun operator*(a T, b Point<T>) { return Point(a*b.X, a*b.Y) }
    fun operator*(a Point<T>, b T) { return Point(a.X*b, a.Y*b) }
    fun operator/(a T, b Point<T>) { return Point(a/b.X, a/b.Y) }
    fun operator/(a Point<T>, b T) { return Point(a.X/b, a.Y/b) }
    get ToSize() Size<T> { return Size(X, Y) }
}

type passcopy Size<T>(Width T, Height T)
    where T is IArithmetic<T>
{
    // TBD: Same as Point<T>
    get ToPoint() Point<T> { return Point(Width, Height) }
}

type Rect<T>(X T, Y T, Width T, Height T)
    where T is IArithmetic<T>
{
    // TBD: Operators (add, multiply, divide, sizes, etc.)
    pub fun new(location Point<T>, size Zurfur.Draw2d.Size<T>):
        Location = location
        Size = size

    get Left() T { return X }
    get Right() T { return X + Width }
    get Top() T { return Y }
    get Bottom() T { return Y + Height }
    get Location() Point<T> { return Point<T>(X, Y) }
    set Location(value T) { X = value.X;  Y = value.Y }
    get Size() Draw2d.Size<T> { return Size<T>(Width, Height) }
    set Size(value Draw2d.Size<T>) { Width = value.Width;  Height = value.Height }

}