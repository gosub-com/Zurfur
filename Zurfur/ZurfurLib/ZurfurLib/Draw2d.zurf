
/// Basic shapes for use with 2d drawing library
/// TBD: Still working on getting this fixed
module Zurfur.Draw2d

use Zurfur.Operators[OpAdd, OpMul]

fun test_Shape()
    @rect = Rect<int>(1,2,3,4)
    rect.Location.Y = 30 // This should work
    Assert(rect == Rect<int>(1,30,3,4))
    

type copy Point<T> //TBD: where T is NumOps

    @x T pub init ref mut
    @y T pub init ref mut

    fun toSize() Size<T> { return Size(X, Y) }


// TBD: Maybe just use extension methods with known names?
fun Point<T>::opAdd<T>(n Point<T>) Point<T>
        where T is OpAdd<T,T>
    return Point<T>(x+n.x, y+n.y)
fun Point<T>::opMul<T>(n T) Point<T>
        where T is OpMul<T,T>
    return Point<T>(x*n, y*n)
fun Point<T>::opMul<T>(n Point<T>) Point<T>
        where T is OpMul<T,T>
    return Point<T>(this*n.x, this*n.y)

// TBD: DO NOT ALLOW!
fun T::opMul<T>(n Point<T>) Point<T>
        where T is OpMul<T,T>
    return Point<T>(this*n.x, this*n.y)

// TBD: Get this fixed
//impl<T> Point<T>::OpAdd<Point<T>, Point<T>>
//      where T is OpAdd<T,T>
//    pub fun opAdd(n Point<T>) Point<T> { return Point<T>(x+n.x, y+n.y) }
//impl<T> Point<T>::OpSub<Point<T>, Point<T>>
//      where T is OpSub<T,T>
//    pub fun opSub(n Point<T>) { return Point<T>(x-n.x, y-n.y) }
//impl<T> Point<T>::OpNeg<Point<T>>
//      where T is OpNeg<T>
//    pub fun opNeg() { return Point<T>(-x, -y) }
//impl<T> Point<T>::OpMul<T, Point<T>>
//      where T is OpMul<T,T>
//    pub fun opMul(n T) { return Point<T>(x*n, y*n) }
//impl<T> T::OpMul<Point<T>, Point<T>>
//      where T is OpMul<T,T>
//    pub fun opMul(n Point<T>) { return Point<T>(this*n.x, this*n.y) }
//impl<T> Point<T>::OpDiv<T, Point<T>>
//      where T is OpDiv<T,T>
//    pub fun opDiv(n T) { return Point<T>(x/n, y/n) }
//impl<T> T::OpDiv<Point<T>, Point<T>>
//      where T is OpDiv<T,T>
//    pub fun opDiv(n Point<T>) { return Point<T>(this/n.x, this/n.y) }


type copy Size<T> // TBD:    where T is NumOps

    @width T pub init ref mut
    @height T pub init ref mut
    
    // TBD: Same as Point<T>
    fun toPoint() Point<T> { return Point(width, height) }

type copy Rect<T> // TBD:    where T is NumOps

    @x T pub init ref mut
    @y T pub init ref mut
    @width T pub init ref mut
    @height T pub init ref mut
    
    pub fun new(location Point<T>, size Size<T>)
        this.location = location
        this.size = size

    // TBD: Operators (add, multiply, divide, sizes, etc.)

    get left() T { return x }
    get right() T { return x + width }
    get top() T { return y }
    get bottom() T { return y + height }
    get location() Point<T> { return Point<T>(x, y) }
    set location(value Point<T>) { x = value.x;  Y = value.y }
    get size() Size<T> { return Size<T>(width, height) }
    set size(value Size<T>) { width = value.width;  height = value.height }