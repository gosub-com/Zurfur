
use Zurfur
use Zurfur.Operators

/// Basic shapes for use with 2d drawing library
module Zurfur.Draw2d

fun test_Shape():
    @rect = Rect<int>(1,2,3,4)
    rect.Location.Y = 30 // This should work
    Assert(rect == Rect<int>(1,30,3,4))
    

type passcopy Point<T>
    where T is NumOps
{
    @x T pub init ref mut
    @y T pub init ref mut

    fun pub static op_add(a Point<T>, b Point<T>) Point<T> { return Point(a.x+b.x, a.y+b.y) }
    fun pub static op_neg(a Point<T>) { return Point(-a.x, -a.y) }
    fun pub static op_sub(a Point<T>, b Point<T>) { return Point(a.x-b.x, a.y-b.y) }
    fun pub static op_mul(a T, b Point<T>) { return Point(a*b.x, a*b.Y) }
    fun pub static op_mul(a Point<T>, b T) { return Point(a.x*b, a.y*b) }
    fun pub static op_div(a T, b Point<T>) { return Point(a/b.x, a/b.y) }
    fun pub static op_div(a Point<T>, b T) { return Point(a.x/b, a.y/b) }
    fun toSize() Size<T> { return Size(X, Y) }
}


type passcopy Size<T>
    where T is NumOps
{
    @width T pub init ref mut
    @height T pub init ref mut
    
    // TBD: Same as Point<T>
    fun toPoint() Point<T> { return Point(width, height) }
}

type passcopy Rect<T>
    where T is NumOps
{
    @x T pub init ref mut
    @y T pub init ref mut
    @width T pub init ref mut
    @height T pub init ref mut
    
    fun pub new(location Point<T>, size Size<T>):
        this.location = location
        this.size = size

    // TBD: Operators (add, multiply, divide, sizes, etc.)

    get left() T { return x }
    get right() T { return x + width }
    get top() T { return y }
    get bottom() T { return y + height }
    get location() Point<T> { return Point<T>(x, y) }
    set location(value Point<T>) { x = value.x;  Y = value.y }
    get size() Size<T> { return Size<T>(width, height) }
    set size(value Size<T>) { width = value.width;  height = value.height }

}