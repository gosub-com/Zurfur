
// Basic shapes for use with 2d drawing library.
// Point, Size, Rect.
// TBD: Vec2, Vec3, Vec4 for 3d, is Point same as Vec2?
mod Zurfur.Draw2d

use Zurfur.Operators[NumOps]

fun test_Shape()
    @rect = Rect<int>(1,2,3,4) // TBD: Type inderence for constructors
    
    rect.location.y = 30
    @rl1 = rect.location
    @rly1 = rect.location.y
    @rly2 = rect.location.x2

    @rl2a = rect.lf()
    @rl2b = rect.lf().yf()
    
    

[pub]
type Point<T> copy
        where T has NumOps<T>
    x T
    y T

// Identical to a field
fun get Point.x2() mut ref My.T
    return ref my.x

[pub]
type Size<T> copy
        where T has NumOps<T>
    width T
    height T

[pub]
type Rect<T> copy
        where T has NumOps<T>
    // TBD: use location Point<T>
    //      use size Size<T>
    location Point<T>
    size Size<T>

// Identical to fields (not necessary when we have 'use location Point<T>' syntax)
[pub]
fun get Rect.x() mut ref My.T
    return ref my.location.x
[pub]
fun get Rect.y() mut ref My.T
    return ref my.location.y
[pub]
fun get Rect.width() mut ref My.T
    return ref my.size.height
[pub]
fun get Rect.height() mut ref My.T
    return ref my.size.width


[pub]
fun Point.new(x My.T, y My.T)
    // TBD: (my.x, my.y) = (x, y)
    my.x = x
    my.y = y


[pub]
fun Point.toSize() Size<My.T>
    return Size<My.T>(my.x, my.y)

// TBD: Remove
fun Point.yf() My.T
    return my.y


[pub static]
fun Point._opAdd(a Point<My.T>, b Point<My.T>) Point<My.T>
        where My.T has NumOps<My.T> // TBD: Use constraints from `Point`
    return Point(a.x+b.x, a.y+b.y)

[pub static]
fun Point._opNeg(a Point<My.T>) Point<My.T>
        where My.T has NumOps<My.T> // TBD: Use constraints from `Point`
    return Point(-a.x, -a.y)

[pub static]
fun Point._opSub(a Point<My.T>, b Point<My.T>) Point<My.T>
        where My.T has NumOps<My.T> // TBD: Use constraints from `Point`
    return Point(a.x-b.x, a.y-b.y)

[pub static]
fun Point._opMul(a My.T, b Point<My.T>) Point<My.T>
        where My.T has NumOps<My.T> // TBD: Use constraints from `Point`
    return Point(a*b.x, a*b.y)

[pub static]
fun Point._opMul(a Point<My.T>, b My.T) Point<My.T>
        where My.T has NumOps<My.T> // TBD: Use constraints from `Point`
    return Point(a.x*b, a.y*b)

[pub static]
fun Point._opDiv(a My.T, b Point<My.T>) Point<My.T>
        where My.T has NumOps<My.T> // TBD: Use constraints from `Point`
    return Point(a/b.x, a/b.y)

[pub static]
fun Point._opDiv(a Point<My.T>, b My.T) Point<My.T>
        where My.T has NumOps<My.T> // TBD: Use constraints from `Point`
    return Point(a.x/b, a.y/b)

[pub]
fun Size.new(width My.T, height My.T)
    // TBD: (my.width, my.height) = (width, height)
    my.width = width
    my.height = height
    
[pub]
fun Size.toPoint() Point<My.T>
    return Point(my.width, my.height)


// TBD: Shortcut syntax for this:
[pub]
fun Rect.new(x My.T, y My.T, width My.T, height My.T)
    my.x = x
    my.y = y
    my.width = width
    my.height = height
    
[pub]
fun Rect.new(location Point<My.T>, size Size<My.T>)
    my.location = location
    my.size = size


// TBD: Operators (add, multiply, divide, sizes, etc.)

[pub]
fun get Rect.left() My.T
    return my.x
    
[pub]
fun get Rect.right() My.T
        where My.T has NumOps<My.T> // TBD: Use constraints from `Point`
    return my.x + my.width

[pub]
fun get Rect.top() My.T
    return my.y
    
[pub]
fun get Rect.bottom() My.T
        where My.T has NumOps<My.T> // TBD: Use constraints from `Point`
    return my.y + my.height
    
// TBD: Remove
[pub]
fun Rect.lf() Point<My.T>
    return Point(my.x, my.y)
    