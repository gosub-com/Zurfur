
use Zurfur
use Zurfur.Operators

/// Basic shapes for use with 2d drawing library
module Zurfur.Draw2d

fun test_Shape():
    @rect = Rect<int>(1,2,3,4)
    rect.Location.Y = 30 // This should work
    Assert(rect == Rect<int>(1,30,3,4))
    

type passcopy Point<T>(X T, Y T)
    where T is NumOps
{
    fun pub add(a Point<T>, b Point<T>) { return Point(a.X+b.X, a.Y+b.Y) }
    fun pub neg(a Point<T>) { return Point(-a.X, -a.Y) }
    fun pub sub(a Point<T>, b Point<T>) { return Point(a.X-b.X, a.Y-b.Y) }

    // TBD: These need to be impl Point::OpMul, etc.
    fun pub mul(a T, b Point<T>) { return Point(a*b.X, a*b.Y) }
    fun pub mul(a Point<T>, b T) { return Point(a.X*b, a.Y*b) }
    fun pub div(a T, b Point<T>) { return Point(a/b.X, a/b.Y) }
    fun pub div(a Point<T>, b T) { return Point(a.X/b, a.Y/b) }
    get toSize() Size<T> { return Size(X, Y) }
}

type passcopy Size<T>(Width T, Height T)
    where T is NumOps
{
    // TBD: Same as Point<T>
    get ToPoint() Point<T> { return Point(Width, Height) }
}

type Rect<T>(X T, Y T, Width T, Height T)
    where T is NumOps
{
    // TBD: Operators (add, multiply, divide, sizes, etc.)
    fun pub new(location Point<T>, size Zurfur.Draw2d.Size<T>):
        Location = location
        Size = size

    get Left() T { return X }
    get Right() T { return X + Width }
    get Top() T { return Y }
    get Bottom() T { return Y + Height }
    get Location() Point<T> { return Point<T>(X, Y) }
    set Location(value T) { X = value.X;  Y = value.Y }
    get Size() Draw2d.Size<T> { return Size<T>(Width, Height) }
    set Size(value Draw2d.Size<T>) { Width = value.Width;  Height = value.Height }

}