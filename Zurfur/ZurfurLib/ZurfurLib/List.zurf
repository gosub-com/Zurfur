use Zurfur.Unsafe.Memory

namespace Zurfur

/// This is the lowest level array type in Zurfur.
/// All dynamically sized objects should build from this.
pub class List<T>
    implements Iterable<List<T>, T>
{
    pub const MaxItems uint = uint.Max/4/Math.Max(1,sizeof(t))

    // The GC will know the layout of this class
    // and follow the items pointer accordingly.
    //
    // spanCount is currenty held here, but could be
    // moved to the array memory in the future.
    // This would allow Span<T>'s drop to also free the
    // memory.  It should be rare to detach and need
    // GC, so doing that might actually be slower
    // in the normal case.

    items  GcArrayPointer<T>
    capacity int       // CapacSize of the items array (GC uses this)
    count int          // Current size of the list
    spanCount int
    version int
    
    pub fun new(capacity int)
    {
        SetCapacity(capacity)
    }

    pub fun drop()
    {
        count = 0 // Flag to drop
        SetCapacity(0)
    }
    
    /// Grow the capacity to be at least minCount size.
    /// If minCount is <= capacity nothing happens,
    /// otherwise the list is expanded exponentially.
    pub fun Grow(minCapacity int)
    {
        if minCapacity <= capacity
            { return }
        @newCap = Math.Max(capacity*2, minCount)
        if sizeof(T) == 1
            { newCap = Math.Max(newCap, 12) }
        else if sizeof(T) <= 64
            { newCap = Math.Max(newCap, 4) }
        else
            { newCap = Math.Max(newCap, 1) }
        SetCapacity(newCap)
    }
    
    pub fun Trim(extra int = 0)
    {
        SetCapacity(count + extra)
    }
    
    // Set the capacity, won't shrink below count
    fun SetCapacity(capacity int)
    {
        capacity = Math.Max(capacity, count)
        Debug.PanicIf(uint(capacity) > MaxItems)
        
        // Copy old items into new array
        @oldItems = items
        items = capacity == 0 ? null : unsafe cast(*T)DlMalloc.Calloc(sizeof(T)*capacity:2)
        this.capacity = capacity
        unsafe MemCopy32(items, oldItems, sizeof(T)*count)
        
        // When spanCout is zero, we own it and can delete it.
        // Oterwise, it becomes garbage
        if spanCount == 0
            { unsafe dlMalloc.Free(oldItems) }
        spanCount = 0
        
    }

    
    pub fun new(items Span<T>)
    {
        // TBD: Clone here?
    }
    
    pub fun new(items Collection<T>)
    {
    }


    pub fun operator[](index int) ref mut T
        => todo()

    pub fun operator[](range Range<int>) ref mut Span<T>
        => todo()
    
    pub prop Count int => count
    pub mut fun Push(item T) => todo()
    pub mut fun Push(items Span<T>) => todo()
    pub mut fun Pop() ?T => todo()
    pub mut fun Insert(index int, item T) => todo()
    pub mut fun Insert(index int, items Span<T>) => todo()
    pub mut fun Insert(index int, items ICollection<T>) => todo()
    pub mut fun Remove(index int) => todo()
    pub mut fun Remove(range Range<int>) => todo()

    pub fun Convert<Tout>(f fun(item T)Tout) => todo()
    pub fun Find(f fun(item T)) => todo()
    pub mut fun Sort(compare fun(a T, b T)bool) => todo()
    pub mut fun Sort(compare fun(a T, b T)bool, range Range<int>) => todo()

    pub fun Remove(test fun(item T) bool exit) exit
    {
        @v = version
        @si = 0
        @di = 0
        while si < count
        {
            @remove = test(items[si])
            if v != version
                { throw MutateWhileIteratingException() }
            if !remove
            {
                if si != di
                    { items[di] = itmes[si]}
                di += 1
            }
            si += 1
        }
        Remove(di:si)
        return
    error:
        if v != version
            { throw MutateWhileIteratingException() }
        Remove(di:si)
    }

    // Usage: myList.For @item => DoStuffWithItem()
    pub fun For(f fun(item mut T) exit) exit
    {
        @v = version
        for @i in count
        {
            f(items[i])
            if v != version
                { throw MutateWhileIteratingException() }
        }
    }

    
    pub struct ListIterator<T>
        implements Iterator<List<T>, T>
    {
        version int
        index int
        pub fun new(list List<T>)
            { version = list.version }
        pub mut fun GetNext(list List<T>) ?mut T
        {
            if version != list.version
                { throw MutateWhileIteratingException() }
            if index < list.Count
            {
                @item = list[index]
                index += 1
                return item
            }
            return null
        }
    }
               
}