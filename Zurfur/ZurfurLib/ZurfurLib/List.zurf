use Zurfur.Unsafe
use Zurfur.Collections
use Zurfur.Operators

module Zurfur

pub type List<T>
    where This is OpIn<T> + GetIterator<ref T>

    pub const MaxItems uint = xint.MaxValue/4/Math.Max(1,sizeof(t))

    @buffer  Buffer<T>
    @count int pub get
    @version int pub get  // Increment when Count changes

    pub fun new(capacity int)
        buffer = Buffer<T>(capacity)

    // Clone items into the new list
    pub fun new(items []T)
        buffer = Buffer<T>(items.Count)
        for @i in 0..items.count
            buffer[i] = items[i].clone()

    // Clone items into the new list
    pub fun new(items Iterator<T>)
        buffer = Buffer<T>(items.countHint)
        push(items)
        
    pub fun mut incVersion()
        version += 1

    get op_index(i int) mut ref T
        require i in 0..count
        return ref buffer[index]

    get op_index(r Range<int>) mut []T
        require r.start in 0..count
        require r.end in 0..count
        require r.start <= range.end
        return ref buffer[range]

    /// Grow the capacity to be at least minCapacity size.
    /// If minCapacity is <= capacity nothing happens,
    /// otherwise the list is expanded exponentially.
    pub fun mut grow(minCapacity int)
        if minCapacity <= buffer.count
            incVersion()
            return
        @newCap = max(capacity*2, minCount)
        if sizeof(T) == 1
            newCap = max(newCap, 12)
        elif sizeof(T) <= 64
            newCap = max(newCap, 4)
        else
            newCap = max(newCap, 1)
        setCapacity(newCap)
    
    pub fun mut trim(extra int = 0)
        setCapacity(Count + extra)

    get capacity() int
        return buffer.count
        
    // Set the capacity, won't shrink below count.
    pub fun mut setCapacity(value int)
        incVersion()
        @newCap = max(newCap, Count)
        if newCap == buffer.Count
            return
        Debug.PanicIf(uint(newCap) > MaxItems)
        
        // Copy items into new array
        @newBuffer = Buffer<T>(newCap)
        for @i in 0..count
            newBuffer[i] = move(buffer[i])
        buffer = newBuffer


    /// Return a new array with all occurences of `seqSearch`
    /// replaced by `seqReplace`.
    // TBD: Is it confusing to have this function be an in-place replacement,
    //      but Array.Replace to be immutable?
    pub fun mut replace(seqSearch []T, seqReplace[]T) { todo()}
    pub fun mut clear() {}
    pub fun mut push(item own T) {}
    pub fun mut push(items []T) {}
    pub fun mut push(items Iterator<T>) {}
    pub fun mut pushDup(item T, count int) {}
    pub fun mut pop() ?T {} 
    pub fun mut insert(index int, item T) {}
    pub fun mut insert(index int, items []T) {}
    pub fun mut insert(index int, items Iterator<T>) {}
    pub fun mut remove(index int) {}
    pub fun mut remove(range Range<int>) {}
    pub fun mut remove(test fun(item T) bool) {}
    pub fun<Tout> convert(f fun(item T)Tout) List<Tout> {}


    // Usage: myList.For @item => DoStuffWithItem()
    pub fun mut forEach(f fun(item mut T)) {}

    // TBD: Verify that it's impossible to get a mutable
    //      ListIterator from an immutable list reference
    pub fun getIterator() ListIterator
        return ListIterator(this)

    pub type ref ListIterator
        where This is Iterator<T>
 
        @list ref List<T>
        @version int
        @index int = -1
        
        pub fun new(list ref List<T>)
            this.list = ref list
            version = list.Version
            
        pub fun mut next() ?ref T
            if version != list.Version
                throw InvalidIteratorException()
            index += 1
            if index < list.Count
                return ref list[index]
            return null

 
