
module Zurfur

use Zurfur.Unsafe
use Zurfur.Collections[Iterator]
use Zurfur.Operators[Clone]


// This type contains ?T and relies on List to keep track of
// how many items it has.  The list will have to use manual
// reference count to ensure it's impossible to modify in
// an unsafe way.  Still very TBD.
type unsafe owned box ListBuffer<T>
    @refCount xint

    
get pub (l ListBuffer<T>) hasRef()
    return refCount != 0

type pub owned List<T>
    pub const MaxItems uint = xint.MaxValue/4/Math.Max(1,sizeof(t))
    @buffer ListBuffer<T>
    @count int pub get

fun pub (l List<T>) hasRef()
    return buffer.hasRef()

fun pub (l List<T>) new(capacity int)
    buffer = ListBuffer<T>(capacity)

// Clone items into the new list
fun pub (l List<T>) new(items []T)
    buffer = ListBuffer<T>(items.Count)
    push(items)

// Clone items into the new list
fun pub (l List<T>) new(items mut Iterator<T>)
    buffer = Buffer<T>(items.countHint)
    push(items)
    
get pub (l List<T>) op_index(i int) mut ref T
    require i in 0..count
    return ref buffer[index]

get pub (l List<T>) op_index(r Range<int>) mut []T
    require r.start in 0..count
    require r.end in 0..count
    require r.start <= range.end
    return ref buffer[range]

// Grow the capacity to be at least minCapacity size.
// If minCapacity is <= capacity nothing happens,
// otherwise the list is expanded exponentially.
fun pub (l mut List<T>) grow(minCapacity int)
    require !hasRef()
    if minCapacity <= buffer.count
        incVersion()
        return
    @newCap = max(capacity*2, minCount)
    if sizeof(T) == 1
        newCap = max(newCap, 12)
    elif sizeof(T) <= 64
        newCap = max(newCap, 4)
    else
        newCap = max(newCap, 1)
    setCapacity(newCap)

fun pub (l mut List<T>) trim(extra int = 0)
    require !hasRef()        
    setCapacity(Count + extra)

get pub (l List<T>) capacity() int
    return buffer.count
    
// Set the capacity, won't shrink below count.
fun pub (l mut List<T>) setCapacity(value int)
    require !hasRef()        
    @newCap = max(newCap, Count)
    if newCap == buffer.Count
        return
    Debug.PanicIf(uint(newCap) > MaxItems)
    
    // Copy items into new array
    @newBuffer = Buffer<T>(newCap)
    for @i in 0..count
        newBuffer[i] = move(buffer[i])
    buffer = newBuffer


// Return a new array with all occurences of `seqSearch`
// replaced by `seqReplace`.
fun pub (l mut List<T>) replace(seqSearch []T, seqReplace[]T)
    require !hasRef()
    todo()

fun pub (l mut List<T>) clear()
    require !hasRef()
    todo()

fun pub (l mut List<T>) push(item own T)
    require !hasRef()
    todo()

fun pub (l mut List<T>) push(items []T)
    require !hasRef()
    todo()

fun pub (l mut List<T>) push(items mut Iterator<T>)
    require !hasRef()
    todo()

fun pub (l mut List<T>) pushDups(item T, count int)
    require !hasRef()
    todo()

fun pub (l mut List<T>) pop() ?T
    require !hasRef()
    todo()

fun pub (l mut List<T>) insert(index int, item own T)
    require !hasRef()
    todo()

fun pub (l mut List<T>) insert(index int, items []T)
    require !hasRef()
    todo()

fun pub (l mut List<T>) insert(index int, items mut Iterator<T>)
    require !hasRef()
    todo()

fun pub (l mut List<T>) remove(index int) T
    require !hasRef()
    todo()

fun pub (l mut List<T>) remove(range Range<int>)
    require !hasRef()
    todo()

fun pub (l mut List<T>) remove(test fun(item T) bool)
    require !hasRef()
    todo()

fun pub (l List<T>) convert<Tout>(f fun(item T) ?Tout) List<Tout>
    where T is Clone
    todo()

fun pub (l List<T>) toArray() Array<T>
    where T is Clone
    todo()


// Usage: myList.For @item => DoStuffWithItem()
fun pub (l mut List<T>) forEach(f fun(item mut T)) {}

fun pub (l mut List<T>) getIter()
    return this[0..count]

 