
module Zurfur

use Zurfur.Unsafe
use Zurfur.Collections[Iterator]
use Zurfur[Clone]

pub const MAX_ARRAY_SIZE_BYTES int = i32.MaxValue/4

// This type contains ?T and relies on List to keep track of
// how many items it has.  The list will have to use manual
// reference count to ensure it's impossible to modify in
// an unsafe way.  Still very TBD.
type unsafe owned box ListBuffer<T>
    @refCount int

    
get pub ListBuffer<T>.hasRef()
    return refCount != 0

type pub owned List<T>
    pub const MaxItems int = MAX_ARRAY_SIZE_BYTES/Math.Max(1,sizeof(t))
    @buffer ListBuffer<T>
    @count int pub get

fun pub List<T>.hasRef()
    return buffer.hasRef()

fun pub List<T>.new(capacity int)
    buffer = ListBuffer<T>(capacity)

// Clone items into the new list
fun pub List<T>.new(items []T)
    buffer = ListBuffer<T>(items.Count)
    push(items)

// Clone items into the new list
fun pub List<T>.new(items mut Iterator<T>)
    buffer = Buffer<T>(items.countHint)
    push(items)
    
get pub List<T>.op_index(i int) mut ref T
    require i in 0..count
    return ref buffer[index]

get pub List<T>.op_index(r Range<int>) mut []T
    require r.start in 0..count
    require r.end in 0..count
    require r.start <= range.end
    return ref buffer[range]

// Grow the capacity to be at least minCapacity size.
// If minCapacity is <= capacity nothing happens,
// otherwise the list is expanded exponentially.
fun pub mut List<T>.grow(minCapacity int)
    require !hasRef()
    if minCapacity <= buffer.count
        incVersion()
        return
    @newCap = max(capacity*2, minCount)
    if sizeof(T) == 1
        newCap = max(newCap, 12)
    elif sizeof(T) <= 64
        newCap = max(newCap, 4)
    else
        newCap = max(newCap, 1)
    setCapacity(newCap)

fun pub mut List<T>.trim(extra int = 0)
    require !hasRef()        
    setCapacity(Count + extra)

get pub List<T>.capacity() int
    return buffer.count
    
// Set the capacity, won't shrink below count.
fun pub mut List<T>.setCapacity(value int)
    require !hasRef()        
    @newCap = max(newCap, Count)
    if newCap == buffer.Count
        return
    Debug.PanicIf(int(newCap) > MaxItems)
    
    // Copy items into new array
    @newBuffer = Buffer<T>(newCap)
    for @i in 0..count
        newBuffer[i] = move(buffer[i])
    buffer = newBuffer


// Return a new array with all occurences of `seqSearch`
// replaced by `seqReplace`.
fun pub mut List<T>.replace(seqSearch []T, seqReplace[]T)
    require !hasRef()
    todo()

fun pub mut List<T>.clear()
    require !hasRef()
    todo()

fun pub mut List<T>.push(item own T)
    require !hasRef()
    todo()

fun pub mut List<T>.push(items []T)
    require !hasRef()
    todo()

fun pub mut List<T>.push(items mut Iterator<T>)
    require !hasRef()
    todo()

fun pub mut List<T>.pushDups(item T, count int)
    require !hasRef()
    todo()

fun pub mut List<T>.pop() ?T
    require !hasRef()
    todo()

fun pub mut List<T>.insert(index int, item own T)
    require !hasRef()
    todo()

fun pub mut List<T>.insert(index int, items []T)
    require !hasRef()
    todo()

fun pub mut List<T>.insert(index int, items mut Iterator<T>)
    require !hasRef()
    todo()

fun pub mut List<T>.remove(index int) T
    require !hasRef()
    todo()

fun pub mut List<T>.remove(range Range<int>)
    require !hasRef()
    todo()

fun pub mut List<T>.remove(test fun(item T) bool)
    require !hasRef()
    todo()

fun pub List<T>.convert<Tout>(f fun(item T) ?Tout) List<Tout>
    where T is Clone<T>
    todo()

fun pub List<T>.toArray() Array<T>
    where T is Clone<T>
    todo()


// Usage: myList.For @item => DoStuffWithItem()
fun pub mut List<T>.forEach(f fun(item mut T)) {}

fun pub mut List<T>.getIter()
    return this[0..count]

 