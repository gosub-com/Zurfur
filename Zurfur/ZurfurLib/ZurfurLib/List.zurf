use Zurfur.Unsafe
use Zurfur.Collections
use Zurfur.Operators

module Zurfur

pub type List<T>
    where This is OpIn<T> + GetIterator<ref T>
{
    pub const MaxItems uint = xint.MaxValue/4/Math.Max(1,sizeof(t))

    @buffer  Buffer<T>
    @count int pub get
    @version int pub get  // Increment when Count changes
    
    pub fun new(capacity int):
        SetCapcity(capacity)


    // Clone items into the list.
    // TBD: Allow moving tiems into list via 'items [] own T'?
    pub fun new(items []T):
        buffer = Buffer<T>(items.Count)
        for @i in 0..items.Count:
            buffer[i] = items[i].clone()

    // Clone items into the list.
    // TBD: Allow moving tiems into list via 'Iterator<own T>'?
    pub fun new(items Iterator<T>):
        todo()

    pub fun incVersion():
        version += 1

    get op_index(i int) mut ref T
        require i in 0..Count:
        return ref buffer[index]

    get op_index(r Range<int>) mut []T
        require r.Low in 0..Count
        require r.High in 0..Count
        require r.Low <= range.High:
        return ref buffer[range]

    /// Grow the capacity to be at least minCapacity size.
    /// If minCapacity is <= capacity nothing happens,
    /// otherwise the list is expanded exponentially.
    pub fun grow(minCapacity int):
        if minCapacity <= buffer.Count:
            return
        @newCap = Math.Max(capacity*2, minCount)
        if sizeof(T) == 1:
            newCap = Math.Max(newCap, 12)
        elif sizeof(T) <= 64:
            newCap = Math.Max(newCap, 4)
        else:
            newCap = Math.Max(newCap, 1)
        setCapacity(newCap)
    
    pub fun trim(extra int = 0):
        setCapacity(Count + extra)

    get capacity() int:
        return buffer.count
        
    // Set the capacity, won't shrink below count.
    pub fun setCapacity(value int):
        IncVersion()
        @newCap = Math.Max(newCap, Count)
        if newCap == buffer.Count:
            return
        Debug.PanicIf(uint(newCap) > MaxItems)
        
        // Copy items into new array
        @newBuffer = Buffer<T>(newCap)
        for @i in 0..Count:
            newBuffer[i] = move_tbd(buffer[i]) // TBD: Use move reserved word here
        buffer = newBuffer


    /// Return a new array with all occurences of `seqSearch`
    /// replaced by `seqReplace`.
    // TBD: Is it confusing to have this function be an in-place replacement,
    //      but Array.Replace to be immutable?
    pub fun replace(seqSearch []T, seqReplace[]T):
        return todo()

    // NOTE: Find/Sort, etc. are defined in Span<T>


    pub fun mut Clear(item T = default):
        return todo()
    pub fun mut Push(item T):
        return todo()
    pub fun mut Push(items []T):
        return todo()
    pub fun mut PushDup(item T, count int):
        return todo()
    pub fun mut Pop() ?T:
        return todo()
    pub fun mut Insert(index int, item T):
        return todo()
    pub fun mut Insert(index int, items []T):
        return todo()
    pub fun mut Insert(index int, items Collection<T>):
        return todo()
    pub fun mut Remove(index int):
        return todo()
    pub fun mut Remove(range Range<int>):
        return todo()
    pub fun Convert<Tout>(f fun(item T)Tout):
        return todo()

    pub fun Remove(test fun(item T) bool exit) exit
    {
        @v = Version
        @si = 0
        @di = 0
        while si < Count:
            @remove = test(buffer[si])
            if v != Version:
                throw InvalidIteratorException()
            if !remove:
                if si != di
                    { buffer[di] = buffer[si]}
                di += 1
            si += 1
        Remove(di:si)
        return
    err:
        if v != Version:
            throw InvalidIteratorException()
        Remove(di:si)
    }

    // Usage: myList.For @item => DoStuffWithItem()
    pub fun For(f fun(item mut T) exit) exit:
        @v = Version
        for @i in Count:
            f(buffer[i])
            if v != Version:
                throw InvalidIteratorException()

    // TBD: Verify that it's impossible to get a mutable
    //      ListIterator from an immutable list reference
    pub fun ref GetIterator() ListIterator:
        return ListIterator(this)

    pub type ref ListIterator
        where This is Iterator<T>
    {
        @list ref List<T>
        @version int
        @index int = -1
        
        pub fun new(list ref List<T>):
            this.list = ref list
            version = list.Version
            
        pub fun mut Next() ?ref T:
            if version != list.Version:
                throw InvalidIteratorException()
            index += 1
            if index < list.Count:
                return ref list[index]
            return null

    }
               
}