
module Zurfur

use Zurfur.Unsafe
use Zurfur.Collections[Iter]
use Zurfur.Operators[Clone]


// This type is unique because it is the only one that
// knows when a reference points into it.  This is used
// to allow the List to safely change the count or move
// the ListBuffer elements to a new location.  It also
// contains null's in unused locations even when T is
// non-nullable.
type owned box ListBuffer<T> is Buffer<T>
    // The one and only function that knows when a reference
    // points into the type.  Returns TRUE if there are any
    // references pointing into the ListBuffer.  All functions
    // that could possibly change the List count or capacity
    // must verify there are no outstanding references.
    pub fun hasRef() bool
        todo()

pub type owned List<T>

    pub const MaxItems uint = xint.MaxValue/4/Math.Max(1,sizeof(t))

    @buffer ListBuffer<T>
    @count int pub get

    pub fun hasRef()
        return buffer.hasRef()

    pub fun new(capacity int)
        buffer = ListBuffer<T>(capacity)

    // Clone items into the new list
    pub fun new(items []T)
        where T is Clone
        buffer = ListBuffer<T>(items.Count)
        push(items)

    // Clone items into the new list
    pub fun new(items mut Iter<T>)
        where T is Clone
        buffer = Buffer<T>(items.countHint)
        push(items)
        
    get op_index(i int) mut ref T
        require i in 0..count
        return ref buffer[index]

    get op_index(r Range<int>) mut []T
        require r.start in 0..count
        require r.end in 0..count
        require r.start <= range.end
        return ref buffer[range]

    /// Grow the capacity to be at least minCapacity size.
    /// If minCapacity is <= capacity nothing happens,
    /// otherwise the list is expanded exponentially.
    pub fun mut grow(minCapacity int)
        require !hasRef()
        if minCapacity <= buffer.count
            incVersion()
            return
        @newCap = max(capacity*2, minCount)
        if sizeof(T) == 1
            newCap = max(newCap, 12)
        elif sizeof(T) <= 64
            newCap = max(newCap, 4)
        else
            newCap = max(newCap, 1)
        setCapacity(newCap)
    
    pub fun mut trim(extra int = 0)
        require !hasRef()        
        setCapacity(Count + extra)

    get capacity() int
        return buffer.count
        
    // Set the capacity, won't shrink below count.
    pub fun mut setCapacity(value int)
        require !hasRef()        
        @newCap = max(newCap, Count)
        if newCap == buffer.Count
            return
        Debug.PanicIf(uint(newCap) > MaxItems)
        
        // Copy items into new array
        @newBuffer = Buffer<T>(newCap)
        for @i in 0..count
            newBuffer[i] = move(buffer[i])
        buffer = newBuffer


    /// Return a new array with all occurences of `seqSearch`
    /// replaced by `seqReplace`.
    pub fun mut replace(seqSearch []T, seqReplace[]T)
        where T is Clone
        require !hasRef()
        todo()
    pub fun mut clear()
        require !hasRef()
        todo()
    pub fun mut push(item own T)
        where T is Clone
        require !hasRef()
        todo()
    pub fun mut push(items []T)
        where T is Clone
        require !hasRef()
        todo()
    pub fun mut push(items mut Iter<T>)
        where T is Clone
        require !hasRef()
        todo()
    pub fun mut pushDups(item T, count int)
        where T is Clone
        require !hasRef()
        todo()
    pub fun mut pop() ?T
        require !hasRef()
        todo()
    pub fun mut insert(index int, item own T)
        require !hasRef()
        todo()
    pub fun mut insert(index int, items []T)
        where T is Clone
        require !hasRef()
        todo()
    pub fun mut insert(index int, items mut Iter<T>)
        where T is Clone
        require !hasRef()
        todo()
    pub fun mut remove(index int) T
        require !hasRef()
        todo()
    pub fun mut remove(range Range<int>)
        require !hasRef()
        todo()
    pub fun mut remove(test fun(item T) bool)
        require !hasRef()
        todo()

    pub fun convert<Tout>(f fun(item T) ?Tout) List<Tout>
        where T is Clone
        todo()

    pub fun toArray() Array<T>
        where T is Clone
        todo()


    // Usage: myList.For @item => DoStuffWithItem()
    pub fun mut forEach(f fun(item mut T)) {}

    pub fun getIter()
        return this[0..count]

 