use Zurfur.Unsafe
use Zurfur.Compiler.Internal

namespace Zurfur

/// This is the lowest level array type in Zurfur.
/// All dynamically sized objects should build from this.
/// Mutating the list count (or deleting it) while a
/// span exists causes a run-time error in debug mode
/// or a memory leak in release mode.  Always memory safe.
pub type List<T>
    implements Iterable<List<T>, T>
{
    pub const MaxItems uint = uint.Max/4/Math.Max(1,sizeof(t))


    // Detect incorrect list passed to iterator
    // and mutation while iterating.
    const MASTER_VERSION_INC int = 65536 + 1024
    static mut sMasterVersion int = 0

    // The GC will follow this pointer because it is special.
    // `items` is never referenced when count is zero, so
    // we can unsafe cast to follow without checking for null
    items  ?*GcRefArray<T>
    count int           // Current size of the list
    version int         // Increment when Count changes

    pub fun new()
    {
        version = sMasterVersion
        sMasterVersion += MASTER_VERSION_INC
    }
    
    pub fun new(capacity int)
    {
        new()
        SetCapacity(capacity)
    }

    mut fun drop()
    {
        if items != null
        {
            if items.Ref != 1
            {
                count = 0
                items.Ref -= 1
                Log.PanicInDebugMode("Drop while span exists")
                return
            }
            Clear()
            unsafe dlMalloc.Free(items)
            items = null
        }
    }
    
    /// Grow the capacity to be at least minCount size.
    /// If minCount is <= capacity nothing happens,
    /// otherwise the list is expanded exponentially.
    pub fun Grow(minCapacity int)
    {
        if minCapacity <= items.Count
            { return }
        @newCap = Math.Max(capacity*2, minCount)
        if sizeof(T) == 1
            { newCap = Math.Max(newCap, 12) }
        else if sizeof(T) <= 64
            { newCap = Math.Max(newCap, 4) }
        else
            { newCap = Math.Max(newCap, 1) }
        SetCapacity(newCap)
    }
    
    pub fun Trim(extra int = 0)
    {
        SetCapacity(count + extra)
    }
    
    // Set the capacity, won't shrink below count.
    // Always makes a copy, even if capacity is the same.
    fun SetCapacity(capacity int)
    {
        version += 1
        @capacity = Math.Max(capacity, count)
        Debug.PanicIf(uint(capacity) > MaxItems)
        
        // Move items into new array
        @oldItems = items
        if capacity != 0
        {
            items = unsafe cast(*T)DlMalloc.Calloc(sizeof(T)*capacity)
            *items = GcRefArray(Count:capacity, Ref:oldItems.Ref)
            unsafe MemCopy32(items.Data, oldItems.Data, sizeof(T)*count)
        }
        else
        {
            items = null
        }

        // Delete old array if possible
        if oldItems != null
        {
            items.Ref -= 1
            if oldItems.Ref != 0
            {
                Log.PanicInDebugMode("Mutate list capacity while span exists")
                return
            }
            unsafe DlMalloc.Free(oldItems)
        }
        
    }


    // TBD: Where to clone
    pub fun new(items Span<T>)
    {
    }
    
    pub fun new(items Collection<T>)
    {
    }


    pub fun operator[](index int) ref mut T
        => todo()

    pub fun operator[](range Range<int>) ref mut Span<T>
        => todo()
    
    pub prop Count int => count
    pub mut fun Clear() => todo
    pub mut fun Push(item T) => todo()
    pub mut fun Push(items Span<T>) => todo()
    pub mut fun Pop() ?T => todo()
    pub mut fun Insert(index int, item T) => todo()
    pub mut fun Insert(index int, items Span<T>) => todo()
    pub mut fun Insert(index int, items ICollection<T>) => todo()
    pub mut fun Remove(index int) => todo()
    pub mut fun Remove(range Range<int>) => todo()

    pub fun Convert<Tout>(f fun(item T)Tout) => todo()
    pub fun Find(f fun(item T)) => todo()
    pub mut fun Sort(compare fun(a T, b T)bool) => todo()
    pub mut fun Sort(compare fun(a T, b T)bool, range Range<int>) => todo()

    pub fun Remove(test fun(item T) bool exit) exit
    {
        @v = version
        @si = 0
        @di = 0
        while si < count
        {
            @remove = test(items[si])
            if v != version
                { throw InvalidIteratorException() }
            if !remove
            {
                if si != di
                    { items[di] = itmes[si]}
                di += 1
            }
            si += 1
        }
        Remove(di:si)
        return
    error:
        if v != version
            { throw InvalidIteratorException() }
        Remove(di:si)
    }

    // Usage: myList.For @item => DoStuffWithItem()
    pub fun For(f fun(item mut T) exit) exit
    {
        @v = version
        for @i in count
        {
            f(items[i])
            if v != version
                { throw InvalidIteratorException() }
        }
    }

    
    pub type ListIterator<T>
        implements Iterator<List<T>, T>
    {
        version int
        index int = -1
        
        pub fun new(list List<T>)
            { version = list.version }
            
        pub mut fun Next(list List<T>) ?mut ref T
        {
            if version != list.version
                { throw InvalidIteratorException() }
            index += 1
            if index < list.Count
                { return ref list[index] }
            return null
        }

        pub fun Current(list List<T>) mut ref T
        {
            if version != list.version
                { throw InvalidIteratorException() }
            return ref list[index]
        }
    }
               
}