use Zurfur.Unsafe
use Zurfur.Compiler.Internal

namespace Zurfur

pub type List<T>
    implements Collection<T>
{
    pub const MaxItems uint = uint.Max/4/Math.Max(1,sizeof(t))

    @buffer  Buffer<T>
    @Count int pub get
    @Version int pub get  // Increment when Count changes
    
    pub fun new(capacity int) void
    {
        SetCapacity(capacity)
    }

    pub fun IncVersion() void
    {
        Version += 1
    }
    
    /// Grow the capacity to be at least minCapacity size.
    /// If minCapacity is <= capacity nothing happens,
    /// otherwise the list is expanded exponentially.
    pub fun Grow(minCapacity int) void
    {
        if minCapacity <= buffer.Count
            return
        @newCap = Math.Max(capacity*2, minCount)
        if sizeof(T) == 1
            newCap = Math.Max(newCap, 12)
        else if sizeof(T) <= 64
            newCap = Math.Max(newCap, 4)
        else
            newCap = Math.Max(newCap, 1)
        SetCapacity(newCap)
    }
    
    pub fun Trim(extra int = 0) void
    {
        SetCapacity(Count + extra)
    }
    
    // Set the capacity, won't shrink below count.
    fun SetCapacity(capacity int) void
    {
        IncVersion()
        @capacity = Math.Max(capacity, Count)
        if capacity == buffer.Count
            return
        Debug.PanicIf(uint(capacity) > MaxItems)
        
        // Copy items into new array
        @newBuffer = Buffer<T>(capacity)
        for @i in 0..Count
            newBuffer[i] = move_tbd(buffer[i]) // TBD: Use move reserved word here
        buffer = newBuffer
    }


    pub fun new(items []T) void
    {
        buffer = Buffer<T>(items.Count)
        for @i in 0..items.Count
            buffer[i] = items[i]
    }
    
    pub fun new(items Collection<T>) void
    {
    }

    /// Return a new array with all occurences of `seqSearch`
    /// replaced by `seqReplace`.
    // TBD: Is it confusing to have this function be an in-place replacement,
    //      but Array.Replace to be immutable?
    pub fun Replace(seqSearch []T, seqReplace[]T) void
        return todo()

    // NOTE: Find/Sort, etc. are defined in Span<T>


    pub fun mut Clear(item T = default) void
        return todo()
    pub fun mut Push(item T) void
        return todo()
    pub fun mut Push(items []T) void
        return todo()
    pub fun mut Pop() ?T
        return todo()
    pub fun mut Insert(index int, item T) void
        return todo()
    pub fun mut Insert(index int, items []T) void
        return todo()
    pub fun mut Insert(index int, items Collection<T>) void
        return todo()
    pub fun mut Remove(index int) void
        return todo()
    pub fun mut Remove(range Range<int>) void
        return todo()
    pub fun Convert<Tout>(f fun(item T)Tout) void
        return todo()

    pub fun Remove(test fun(item T) bool exit)  void exit
    {
        @v = Version
        @si = 0
        @di = 0
        while si < Count
        {
            @remove = test(buffer[si])
            if v != Version
                throw InvalidIteratorException()
            if !remove
            {
                if si != di
                    { buffer[di] = buffer[si]}
                di += 1
            }
            si += 1
        }
        Remove(di:si)
        return
    error:
        if v != Version
            throw InvalidIteratorException()
        Remove(di:si)
    }

    // Usage: myList.For @item => DoStuffWithItem()
    pub fun For(f fun(item mut T) void exit) void exit
    {
        @v = Version
        for @i in Count
        {
            f(buffer[i])
            if v != Version
                throw InvalidIteratorException()
        }
    }

    pub fun operator[](index int) ref mut T
       return ref buffer[index]

    pub fun operator[](range Range<int>) mut []T
       return ref buffer[range]


    // TBD: Verify that it's impossible to get a mutable
    //      ListIterator from an immutable list reference
    pub fun ref GetIterator() ListIterator<T>
    {
        return ListIterator<T>(this)
    }

    pub type ref ListIterator<T>
        implements Iterator<T>
    {
        @list ref List<T>
        @version int
        @index int = -1
        
        pub fun new(list ref List<T>) void
        {
            this.list = ref list
            version = list.Version
        }
            
        pub fun mut Next() ?ref T
        {
            if version != list.Version
                throw InvalidIteratorException()
            index += 1
            if index < list.Count
                return ref list[index]
            return null
        }

    }
               
}