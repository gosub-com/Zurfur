use Zurfur.Unsafe
use Zurfur.Compiler.Internal

module Zurfur

type pub List<T>
    implements Collection<T>
{
    const pub MaxItems uint = uint.Max/4/Math.Max(1,sizeof(t))

    @buffer  Buffer<T>
    @Count int pub get
    @Version int pub get  // Increment when Count changes
    
    fun pub new(capacity int):
        SetCapacity(capacity)

    fun pub IncVersion():
        Version += 1


    fun pub operator[](index int) mut ref T
        require index in 0..Count:
        return ref buffer[index]

    fun pub operator[](range Range<int>) mut []T
        require range.Low in 0..Count
        require range.High in 0..Count
        require range.Low <= range.High:
        return ref buffer[range]

    /// Grow the capacity to be at least minCapacity size.
    /// If minCapacity is <= capacity nothing happens,
    /// otherwise the list is expanded exponentially.
    fun pub Grow(minCapacity int):
        if minCapacity <= buffer.Count:
            return
        @newCap = Math.Max(capacity*2, minCount)
        if sizeof(T) == 1:
            newCap = Math.Max(newCap, 12)
        elif sizeof(T) <= 64:
            newCap = Math.Max(newCap, 4)
        else:
            newCap = Math.Max(newCap, 1)
        SetCapacity(newCap)
    
    fun pub Trim(extra int = 0):
        SetCapacity(Count + extra)
    
    // Set the capacity, won't shrink below count.
    fun SetCapacity(capacity int):
        IncVersion()
        @capacity = Math.Max(capacity, Count)
        if capacity == buffer.Count:
            return
        Debug.PanicIf(uint(capacity) > MaxItems)
        
        // Copy items into new array
        @newBuffer = Buffer<T>(capacity)
        for @i in 0..Count:
            newBuffer[i] = move_tbd(buffer[i]) // TBD: Use move reserved word here
        buffer = newBuffer


    fun pub new(items []T):
        buffer = Buffer<T>(items.Count)
        for @i in 0..items.Count:
            buffer[i] = items[i]
    
    fun pub new(items Collection<T>)
    {
    }

    /// Return a new array with all occurences of `seqSearch`
    /// replaced by `seqReplace`.
    // TBD: Is it confusing to have this function be an in-place replacement,
    //      but Array.Replace to be immutable?
    fun pub Replace(seqSearch []T, seqReplace[]T):
        return todo()

    // NOTE: Find/Sort, etc. are defined in Span<T>


    fun pub mut Clear(item T = default):
        return todo()
    fun pub mut Push(item T):
        return todo()
    fun pub mut Push(items []T):
        return todo()
    fun pub mut PushDup(item T, count int):
        return todo()
    fun pub mut Pop() ?T:
        return todo()
    fun pub mut Insert(index int, item T):
        return todo()
    fun pub mut Insert(index int, items []T):
        return todo()
    fun pub mut Insert(index int, items Collection<T>):
        return todo()
    fun pub mut Remove(index int):
        return todo()
    fun pub mut Remove(range Range<int>):
        return todo()
    fun pub Convert<Tout>(f fun(item T)Tout):
        return todo()

    fun pub Remove(test fun(item T) bool exit) exit
    {
        @v = Version
        @si = 0
        @di = 0
        while si < Count:
            @remove = test(buffer[si])
            if v != Version:
                throw InvalidIteratorException()
            if !remove:
                if si != di
                    { buffer[di] = buffer[si]}
                di += 1
            si += 1
        Remove(di:si)
        return
    err:
        if v != Version:
            throw InvalidIteratorException()
        Remove(di:si)
    }

    // Usage: myList.For @item => DoStuffWithItem()
    fun pub For(f fun(item mut T) exit) exit:
        @v = Version
        for @i in Count:
            f(buffer[i])
            if v != Version:
                throw InvalidIteratorException()

    // TBD: Verify that it's impossible to get a mutable
    //      ListIterator from an immutable list reference
    fun pub ref GetIterator() ListIterator:
        return ListIterator(this)

    type pub ref ListIterator
        implements Iterator<T>
    {
        @list ref List<T>
        @version int
        @index int = -1
        
        fun pub new(list ref List<T>):
            this.list = ref list
            version = list.Version
            
        fun pub mut Next() ?ref T:
            if version != list.Version:
                throw InvalidIteratorException()
            index += 1
            if index < list.Count:
                return ref list[index]
            return null

    }
               
}