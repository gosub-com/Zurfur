

module Zurfur

use Zurfur.Operators[OpEq]

// []T is converted to Span<T>
type pub ref copy Span<T>
    @data ro ?ref mut T
    @count ro int pub get
    
fun pub (s Span<T>) opIndex(i int) mut ref T
    require i in 0..count
    extern // Implementation TBD

fun pub (s Span<T>) opIndex(range Range<int>) mut Span<T>
    require range.start in 0..count
    require range.end in 0..count
    require range.start <= range.end
    extern // Implementation TBD

fun pub mut (s Span<T>) sort(compare fun(a T, b T)bool)
    return todo()

// Set the span to `item` (or default if not specified)
fun pub mut (s Span<T>) clear(item T = default)
    for @i in 0..count
        this[i] = item

// Find index of the sequence `seq`.
// Returns -1 if not found, or 0 if `seq` is empty.
fun pub (s Span<T>) find(seq Span<T>) int
        where T is OpEq<T>
    if seq.count == 0
        return 0
    if seq.count > count
        return -1
    for @i in 0..count-seq.count+1
        if this[i] != seq[0]
            continue
        @j = 1
        while j < seq.count and seq[j] == this[i+j]
            j += 1
        if j == seq.count
            return i
    return -1


// Find the index of the `item`.  Returns -1 if not found.
fun pub (s Span<T>) find(item T) int
        where T is OpEq<T>
    for @i in 0..count
        if this[i] == item
            return i
    return -1

// Find the index of the `item` when `eq` returns true.
// Returns -1 if not found.
fun pub (s Span<T>) find(eq fun(item T) bool) int
    for @i in 0..count
        if eq(this[i])
            return i
    return -1


        