use Zurfur.Operators


module Zurfur

/// []T is converted to Span<T>
pub type ref passcopy Span<T>
{
    @Data ro ?ref mut T
    @Count ro int pub get
    
    pub fun op_index(i int) mut ref T
        require i in 0..Count
        extern // Implementation TBD
    
    pub fun op_index(range Range<int>) mut Span<T>
        require range.Low in 0..Count
        require range.High in 0..Count
        require range.Low <= range.High
        extern // Implementation TBD

    pub fun mut Sort(compare fun(a T, b T)bool):
        return todo()

    /// Set the span to `item` (or default if not specified)
    pub fun mut Clear(item T = default):
        for @i in 0..Count:
            this[i] = item

    /// Find index of the sequence `seq`.
    /// Returns -1 if not found, or 0 if `seq` is empty.
    pub fun Find(seq Span<T>) int
            where T is OpEq<T>:
        if seq.Count == 0:
            return 0
        if seq.Count > Count:
            return -1
        for @i in 0..Count-seq.Count+1:
            if this[i] != seq[0]:
                continue
            @j = 1
            while j < seq.Count && seq[j] == this[i+j]:
                j += 1
            if j == seq.Count:
                return i
        return -1


    /// Find the index of the `item`.  Returns -1 if not found.
    pub fun Find(item T) int
            where T is OpEq<T>:
        for @i in 0..Count:
            if this[i] == item:
                return i
        return -1

    /// Find the index of the `item` when `eq` returns true.
    /// Returns -1 if not found.
    pub fun Find(eq fun(item T) bool) int
    {
        for @i in 0..Count:
            if eq(this[i]):
                return i
        return -1
    }

        
}