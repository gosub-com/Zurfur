
// Internal stuff for compiler, heap, and GC
module Zurfur.Internal

use Zurfur[todo]

pragma AllowUnderscoreDefinitions

// Internal definition of a reference.
[pub] type ro __ref<T>
    @r ro *T

[pub] fun __ref<T>.new(reference *T)
    require reference != null
    my = reference
    
[pub] fun __ref<T>.Get() T extern
[pub] fun __ref<T>.SetRef(value ref T) extern
[pub] fun __ref<T>.SetVal(value T) extern
[pub unsafe] fun __ref<T>.Index(offset int) mut ref T extern
[pub unsafe] fun __ref<T>.ByteOffset(offset int) *void extern


// Owned reference.  This is specific to reference counting
// and wouldn't exist for a different kind of GC.
[pub] type ro __oref<T>
    @r *T
    @owner ?*__heap<T>

// Owner is null when on the stack
[pub] fun __oref<T>.new(reference *T, owner ?*__heap<T>)
    require reference != null
    my = reference
    this.owner = owner

[pub] fun __oref<T>.drop()
    if my.owner != nil
        my.owner.Dec()
    
[pub] fun __oref<T>.Get() T extern
[pub] fun __oref<T>.SetRef(value ref T) extern
[pub] fun __oref<T>.SetVal(value T) extern
[pub unsafe] fun __oref<T>.Index(offset int) mut ref T extern
[pub unsafe] fun __oref<T>.ByteOffset(offset int) *void extern



// All objects on the heap start with this header.
// This is specific to reference counted GC.
[pub] type __heap<T>
    @vtable *void // TBD: Type info for GC and metadata
    @refCount u64

[pub] fun __heap<T>.Inc()
    my.refCount += 1
    if my.refCount < 0
        todo // TBD: Queue to call drop and reclaim memory