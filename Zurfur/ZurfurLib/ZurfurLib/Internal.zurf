
pragma AllowUnderscoreDefinitions

namespace Zurfur


/// Internal stuff for compiler, heap, and GC
namespace Zurfur.Internal


/// Internal definition of a reference.
pub type ro _ref<T>
{
    ro @r *T

    pub fun new(reference *T) void
        require reference != null
        r = reference
        
    pub fun Get() T extern
    pub fun SetRef(value ref T) void extern
    pub fun SetVal(value T) void extern
    pub unsafe fun Index(offset int) mut ref T extern
    pub unsafe fun ByteOffset(offset int) *void extern
}


/// Owned reference.  This is specific to reference counting
/// and wouldn't exist for a different kind of GC.

pub type ro _oref<T>
{
    @r *T
    @owner ?*_heap<T>

    /// Owner is null when on the stack
    pub fun new(reference *T, owner ?*_heap) void
        require reference != null
        r = reference
        this.owner = owner

    pub fun drop() void
        if owner != null
            owner.Dec()
        
    pub fun Get() T extern
    pub fun SetRef(value ref T) void extern
    pub fun SetVal(value T) void extern
    pub unsafe fun Index(offset int) mut ref T extern
    pub unsafe fun ByteOffset(offset int) *void extern
}


/// All objects on the heap start with this header.
/// This is specific to reference counted GC.
pub type _heap<T>
{
    @vtable *void // TBD: Type info for GC and metadata
    @refCount xint

    pub fun Inc() void
        refCount += 1
        if refCount < 0
            todo() // TBD: Queue to call drop and reclaim memory
}


namespace Zurfur.Compiler

pub type ro Attribute { }

pub type class ro AlignAttribute
    extends Attribute
{
    @Size int pub get
}


namespace Zurfur.Compiler.Internal

// TBD: This will contain compiler generated metadata for each type
pub type GcType { }


// Header for all heap objects
#Align(8)
pub type ro GcObject<T>
{
    @Type *GcType pub get
    @refCount int // Might not exist in GC implementations
}

// Header for all heap array objects
// NOTE: refCount may not exist in GC implementations.
#Align(8)
pub type ro GcArray<T>
{
    const DEFAULT_HASH uint = 0xFFFFFFFF
    @Type *GcType pub get
    @refCount int // Might not exist in GC implementations
    @Count uint pub get
    @hashCode uint = DEFAULT_HASH // Immutable type, so cache the hash
}

// This is the underlying array used by List<T>.
// Separate it from all other types since there is a chance
// it would be reference counted even in a GC implementation.
#Align(8)
pub type ro GcRefArray<T>
{
    @Type *GcType pub get
    @RefCount uint pub get set
    @Count uint pub get

    pub fun new() void
    {
        Type = todo()
    }

    // TBD: Need access to 'this' pointer (use 'ref' on property?)
    pub unsafe get Data *T
        return cast(*T)(cast(xuint)&this + sizeof(GcRefArray<T>))

    // TBD: Need access to 'this' pointer (use 'ref' on function?)
    /// No bounds checking
    pub unsafe fun operator[](index int) *T
        return unsafe cast(*T)(cast(xuint)&this
                                + sizeof(GcRefArray<T>)
                                + sizeof(T)*index)
}