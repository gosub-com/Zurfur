pragma AllowUnderscoreDefinitions

module Zurfur


/// Internal stuff for compiler, heap, and GC
module Zurfur.Internal


/// Internal definition of a reference.
type pub ro __ref<T>
{
    @r ro *T

    fun pub new(reference *T)
        require reference != null:
        r = reference
        
    fun pub Get() T extern
    fun pub SetRef(value ref T) extern
    fun pub SetVal(value T) extern
    fun pub unsafe Index(offset int) mut ref T extern
    fun pub unsafe ByteOffset(offset int) *void extern
}


/// Owned reference.  This is specific to reference counting
/// and wouldn't exist for a different kind of GC.

type pub ro __oref<T>
{
    @r *T
    @owner ?*__heap<T>

    /// Owner is null when on the stack
    fun pub new(reference *T, owner ?*__heap<T>)
        require reference != null:
        r = reference
        this.owner = owner

    fun pub drop():
        if owner != null:
            owner.Dec()
        
    fun pub Get() T extern
    fun pub SetRef(value ref T) extern
    fun pub SetVal(value T) extern
    fun pub unsafe Index(offset int) mut ref T extern
    fun pub unsafe ByteOffset(offset int) *void extern
}


/// All objects on the heap start with this header.
/// This is specific to reference counted GC.
type pub __heap<T>
{
    @vtable *void // TBD: Type info for GC and metadata
    @refCount xint

    fun pub Inc():
        refCount += 1
        if refCount < 0:
            todo() // TBD: Queue to call drop and reclaim memory
}


module Zurfur.Compiler

type pub ro Attribute { }

type pub ro class AlignAttribute
    extends Attribute
{
    @Size int pub get
}


module Zurfur.Compiler.Internal

// TBD: This will contain compiler generated metadata for each type
type pub GcType { }


// Header for all heap objects
#Align(8)
type pub ro GcObject<T>
{
    @Type *GcType pub get
    @refCount int // Might not exist in GC implementations
}

// Header for all heap array objects
// NOTE: refCount may not exist in GC implementations.
#Align(8)
type pub ro GcArray<T>
{
    const DEFAULT_HASH uint = 0xFFFFFFFF
    @Type *GcType pub get
    @refCount int // Might not exist in GC implementations
    @Count uint pub get
    @hashCode uint = DEFAULT_HASH // Immutable type, so cache the hash
}

// This is the underlying array used by List<T>.
// Separate it from all other types since there is a chance
// it would be reference counted even in a GC implementation.
#Align(8)
type pub ro GcRefArray<T>
{
    @Type *GcType pub get
    @RefCount uint pub get set
    @Count uint pub get

    fun pub new()
    {
        Type = todo()
    }

    // TBD: Need access to 'this' pointer (use 'ref' on property?)
    get pub unsafe Data() *T:
        return cast(*T)(cast(xuint)&this + sizeof(GcRefArray<T>))

    // TBD: Need access to 'this' pointer (use 'ref' on function?)
    /// No bounds checking
    fun pub unsafe operator[](index int) *T:
        return unsafe cast(*T)(cast(xuint)&this
                                + sizeof(GcRefArray<T>)
                                + sizeof(T)*index)
}