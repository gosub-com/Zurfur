
/// Internal stuff needed to implement libraries and compiler stuff
namespace Zurfur.Internal



/// A return reference is used when a reference is returned from
/// a function.  This is required so the GC can pin the object
/// containing the reference.  Also used when an object returns
/// a reference to one of its own fields.
pub struct ref ro rref<T>
{
    pub var ro obj  ?object   // Container object, or null if pointing to non GC memory
    pub var ro r    *T       // The reference
    pub fun new(obj ?obj, reference *T) { this.obj = obj;  r = reference}
}

/// A forward reference is a reqular pointer passed down the call stack.
/// The object containing the reference is already stored on the memory
/// stack, and is therefore GC pinned.
pub struct ref ro fref<T>
{
    pub var ro r *T
    pub fun new(reference *T) { r = reference}
}

/// Interfaces are implemented as two pointers, one to a `vtable`, and
/// one to the object itself.  In a multithreaded environment, these
/// would need to be read and written to memory as an automic operation.
pub struct ro InterfacePointer
{
    pub var ro vtable *InterfaceVTable;
    pub var ro obj *void;
    pub fun new(vtable *InterfaceVTable, obj *void) { this.vtable = vtable;  this.obj = obj}
}

/// Base for all compiler generated interface vtables
pub struct ro InterfaceVTable
{
    pub var ro vtable *void // TBD: Common 
    pub var ro IsProtected *fun<bool>
    pub var ro GetObject *fun<*void>
}

/// All variable sized objects must inherit from this
/// class and must be sealed (that's what sealed1 means)
[Sealed1]
pub class ArrayBase<T>
{
    static fun default() => ArrayBase<T>(0)
    pub var ro Count int
        
    fun new(count int) 
        => todo() // Allocate object on heap
        
    protected prop DataSpan Span<T> 
        => todo()
    protected unsafe prop DataPointer *T 
        => cast *T(cast *byte(this) + Sizeof(ArrayBase))
}