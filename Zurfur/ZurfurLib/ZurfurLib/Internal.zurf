
namespace Zurfur.Compiler

pub class ro Attribute { }

pub class ro AlignAttribute
    extends Attribute
{
    pub ro Size int
}


namespace Zurfur.Compiler.Internal

// TBD: This will contain compiler generated metadata for each type
pub struct GcType { }

// Base for all objects
pub struct object_base<T>
{
    // TBD: The compiler only generates these when
    //      T is Equatable, Comparable, clonable, etc.
    static fun GetHashCode<T>(a ref T)
        where T is Equatable
        todo()
    static fun Equals<T>(a ref T, b ref T)
        where T is Equatable
        todo()
    static fun Compare<T>(a ref T, b ref T)
        where T is Comparable
        todo()
    static fun clone<T>(a ref T)
        todo()
}



// Header for all heap objects
[Align(8)]
pub struct ro GcObject<T>
{
    pub ro Type *GcType
    refCount int // Might not exist in GC implementations
}

// Header for all heap array objects
// NOTE: refCount may not exist in GC implementations.
[Align(8)]
pub struct ro GcArray<T>
{
    const DEFAULT_HASH uint= 0xFFFFFFFF
    pub ro Type  *GcType
    refCount int // Might not exist in GC implementations
    pub ro Count  uint
    hashCode uint = DEFAULT_HASH // Immutable type, so cache the hash
}

// This is the underlying array used by List<T>.
// Separate it from all other types since there is a chance
// it would be reference counted even in a GC implementation.
[Align(8)]
pub struct ro GcRefArray<T>
{
    pub ro Type     *GcType
    pub    RefCount  uint
    pub ro Count     uint

    pub fun new()
    {
        Type = todo()
    }

    // TBD: Need access to 'this' pointer (use 'ref' on property?)
    pub unsafe prop Data *T
        return cast(*T)(cast(xuint)&this + sizeof(GcRefArray<T>))

    // TBD: Need access to 'this' pointer (use 'ref' on function?)
    /// No bounds checking
    pub unsafe fun operator[](index int) *T
        return unsafe cast(*T)(cast(xuint)&this
                                + sizeof(GcRefArray<T>)
                                + sizeof(T)*index)
}