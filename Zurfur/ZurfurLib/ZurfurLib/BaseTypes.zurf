// Define the simple types:
//     i8, byte, i16, u16, i32, u32, int, u64, f32, f64, Decimal
//

module Zurfur

pragma AllowUnderscoreDefinitions

// Blank function
get pub nop() {}

// TBD: Probably need to remove this
get todo()
    require(false)
    nop

// Return type of functions that don't return anything
type pub void { }

// Empty value for pointers and optionals
type pub nil { }

// a UTF8 encoded character, same as i32
type pub rune = i32

// Base interface for all types
pub interface object { }

// All types have a unique `id`, but other
// non-essential metadata is opt-in
type pub ro copy Type
    @id i32 pub get


// Swap two items
fun pub swap<T>(a mut ref T, b mut ref T)
    extern

// bool (true or false)
type pub ro copy bool
    const __size int = 1


fun pub bool.getHash() int extern
fun pub bool._opEq(a bool) bool extern

// i8 (-128..127)
type pub ro copy i8
    const __size int = 1
    const __align int = 1
    const pub MAX i8 = 127
    const pub MIN i8 = -128
    const pub ZERO i8 = 0
    const pub ONE i8 = 1
    
get pub i8.byte() ?byte extern
get pub i8.i16() i16 extern
get pub i8.i32() i32 extern
get pub i8.int() int extern
get pub i8.f32() f32 extern
get pub i8.f64() f64 extern
get pub i8.decimal() Decimal extern
fun pub i8.str() str extern
get pub i8.byteMask() byte extern

fun pub i8.getHash() int extern
fun pub i8._opEq(a i8) bool extern
fun pub i8._opCmp(a i8) i32 extern


// byte (0..255)
type pub ro copy byte
    const __size int = 1
    const __align int = 1    
    const pub MAX byte = 255
    const pub MIN byte = 0
    const pub ZERO byte = 0
    const pub ONE byte = 1
    
get pub byte.i8() ?i8 extern
get pub byte.i16() i16 extern
get pub byte.u16() u16 extern
get pub byte.i32() i32 extern
get pub byte.u32() u32 extern
get pub byte.int() int extern
get pub byte.u64() u64 extern
get pub byte.f32() f32 extern
get pub byte.f64() f64 extern
get pub byte.decimal() Decimal extern
fun pub byte.str() str extern
get pub byte.i8Mask() i8 extern

fun pub byte.getHash() int extern
fun pub _opEq(a byte, b byte) bool extern
fun pub _opCmp(a byte, b byte) i32 extern


// i16 (-32768..32768)
type pub ro copy i16
    const __size int = 2
    const __align int = 2    
    const pub MAX i16 = 32767
    const pub MIN i16 = -32768
    const pub ZERO i16 = 0
    const pub ONE i16 = 1

get pub i16.i8() ?i8 extern
get pub i16.byte() ?byte extern
get pub i16.u16() ?u16 extern
get pub i16.i32() i32 extern
get pub i16.int() int extern
get pub i16.f32() f32 extern
get pub i16.f64() f64 extern
get pub i16.decimal() Decimal extern    
fun pub i16.str() str extern
get pub i16.i8Mask() i8 extern
get pub i16.byteMask() byte extern
get pub i16.u16Mask() u16 extern    

fun pub i16.getHash() int extern
fun pub _opEq(a i16, b i16) bool extern
fun pub _opCmp(a i16, b i16) i32 extern



// u16 (0..65535)
type pub ro copy u16
    const __size int = 2
    const __align int = 2    
    const pub MAX u16 = 65535
    const pub MIN u16 = 0
    const pub ZERO u16 = 0
    const pub ONE u16 = 1

get pub u16.i8() ?i8 extern
get pub u16.byte() ?byte extern
get pub u16.i16() ?i16 extern
get pub u16.i32() i32 extern
get pub u16.u32() u32 extern
get pub u16.int() int extern
get pub u16.u64() u64 extern
get pub u16.f32() f32 extern
get pub u16.f64() f64 extern
get pub u16.decimal() Decimal extern
fun pub u16.str() str extern
get pub u16.i8Mask() i8 extern
get pub u16.byteMask() byte extern
get pub u16.i16Mask() i16 extern

fun pub u16.getHash() int extern
fun pub _opEq(a u16, b u16) bool extern
fun pub _opCmp(a u16, b u16) i32 extern

// A 32 bit integer
type pub ro copy i32
    const __size int = 4
    const __align int = 4    
    const pub MAX i32 = 2147483647
    const pub MIN i32 = -2147483648
    const pub ZERO i32 = 0
    const pub ONE i32 = 1

get pub i32.i8() ?i8 extern
get pub i32.byte() ?byte extern
get pub i32.i16() ?i16 extern
get pub i32.u16() ?u16 extern
get pub i32.u32() ?u32 extern
get pub i32.int() int extern
get pub i32.f32() f32 extern
get pub i32.f64() f64 extern
get pub i32.decimal() Decimal extern    
fun pub i32.str() str extern
get pub i32.i8Mask() i8 extern
get pub i32.byteMask() byte extern
get pub i32.i16Mask() i16 extern
get pub i32.u16Mask() u16 extern
get pub i32.u32Mask() u32 extern

fun pub i32.getHash() int extern
fun pub _opEq(a i32, b i32) bool extern
fun pub _opCmp(a i32, b i32) i32 extern
fun pub _opRange(a i32, b i32) Range<i32> extern // TBD: Generic function on range?
fun pub _opAdd(a i32, b i32) i32 extern
fun pub _opSub(a i32, b i32) i32 extern
fun pub _opNeg(a i32) i32 extern
fun pub _opMul(a i32, b i32) i32 extern
fun pub _opDiv(a i32, b i32) i32 extern
fun pub _opRem(a i32, b i32) i32 extern
fun pub _opBitNot(a i32) i32 extern
fun pub _opBitAnd(a i32, b i32) i32 extern
fun pub _opBitOr(a i32, b i32) i32 extern
fun pub _opBitXor(a i32, b i32) i32 extern
fun pub _opBitShl(a i32, b int) i32 extern
fun pub _opBitShr(a i32, b int) i32 extern

get pub i32.iterator() RangeIterator<i32>
    return RangeIterator<i32>(0, my)


// 32 bit unsigned integer
type pub ro copy u32
    const __size int = 4
    const __align int = 4    
    const pub MAX u32 = 4294967295
    const pub MIN u32 = 0
    const pub ZERO u32 = 0
    const pub ONE u32 = 1

get pub u32.i8() ?i8 extern
get pub u32.byte() ?byte extern
get pub u32.i16() ?i16 extern
get pub u32.u16() ?u16 extern
get pub u32.i32() ?i32 extern        
get pub u32.int() int extern
get pub u32.u64() u64 extern
get pub u32.f32() f32 extern
get pub u32.f64() f64 extern
get pub u32.decimal() Decimal extern        
fun pub u32.str() str extern
get pub u32.i8Mask() i8 extern
get pub u32.byteMask() byte extern
get pub u32.i16Mask() i16 extern
get pub u32.u16Mask() u16 extern
get pub u32.i32Mask() i32 extern

fun pub u32.getHash() int extern
fun pub _opEq(a u32, b u32) bool extern
fun pub _opCmp(a u32, b u32) i32 extern
fun pub _opRange(a u32, b u32) Range<u32> extern // TBD: Generic function on range?
fun pub _opAdd(a u32, b u32) u32 extern
fun pub _opSub(a u32, b u32) u32 extern
fun pub _opNeg(a u32) u32 extern
fun pub _opMul(a u32, b u32) u32 extern
fun pub _opDiv(a u32, b u32) u32 extern
fun pub _opRem(a u32, b u32) u32 extern
fun pub _opBitNot(a u32) u32 extern
fun pub _opBitAnd(a u32, b u32) u32 extern
fun pub _opBitOr(a u32, b u32) u32 extern
fun pub _opBitXor(a u32, b u32) u32 extern
fun pub _opBitShl(a u32, b int) u32 extern
fun pub _opBitShr(a u32, b int) u32 extern

get pub u32.iterator() RangeIterator<u32>
    return RangeIterator<u32>(0, my)


// A 64 bit integer (same as int)
type pub ro copy int
    const __size int = 8
    const __align int = 8    
    const pub MAX int = 9223372036854775807
    const pub MIN int = -9223372036854775808
    const pub ZERO int = 0
    const pub ONE int = 1

get pub int.i8() ?i8 extern
get pub int.byte() ?byte extern
get pub int.i16() ?i16 extern
get pub int.u16() ?u16 extern
get pub int.i32() ?i32 extern
get pub int.u32() ?u32 extern
get pub int.u64() ?u64 extern    
get pub int.f32() f32 extern
get pub int.f64() f64 extern
get pub int.decimal() Decimal extern
fun pub int.str() str extern
get pub int.i8Mask() i8 extern
get pub int.byteMask() byte extern
get pub int.i16Mask() i16 extern
get pub int.u16Mask() u16 extern
get pub int.i32Mask() i32 extern
get pub int.u32Mask() u32 extern
get pub int.u64Mask() u64 extern


fun pub int.getHash() int extern
fun pub _opEq(a int, b int) bool extern
fun pub _opCmp(a int, b int) i32 extern
fun pub _opRange(a int, b int) Range<int> extern // TBD: Generic function on range?
fun pub _opAdd(a int, b int) int extern
fun pub _opSub(a int, b int) int extern
fun pub _opNeg(a int) int extern
fun pub _opMul(a int, b int) int extern
fun pub _opDiv(a int, b int) int extern
fun pub _opRem(a int, b int) int extern
fun pub _opBitNot(a int) int extern
fun pub _opBitAnd(a int, b int) int extern
fun pub _opBitOr(a int, b int) int extern
fun pub _opBitXor(a int, b int) int extern
fun pub _opBitShl(a int, b int) int extern
fun pub _opBitShr(a int, b int) int extern


get pub int.iterator() RangeIterator<int>
    return RangeIterator<int>(0, my)

// 64 bit unsigned integer
type pub ro copy u64
    const __size int = 8
    const __align int = 8    
    const pub MAX u64 = 18446744073709551615
    const pub MIN u64 = 0
    const pub ZERO u64 = 0
    const pub ONE u64 = 1

get pub u64.i8() ?i8 extern
get pub u64.byte() ?byte extern
get pub u64.i16() ?i16 extern
get pub u64.u16() ?u16 extern
get pub u64.i32() ?i32 extern
get pub u64.u32() ?u32 extern
get pub u64.int() ?int extern
get pub u64.f32() f32 extern
get pub u64.f64() f64 extern
get pub u64.decimal() Decimal extern
fun pub u64.str() str extern
get pub u64.i8Mask() i8 extern
get pub u64.byteMask() byte extern
get pub u64.i16Mask() i16 extern
get pub u64.u16Mask() u16 extern
get pub u64.i32Mask() i32 extern
get pub u64.u32Mask() u32 extern
get pub u64.intMask() int extern

fun pub u64.getHash() int extern
fun pub _opEq(a u64, b u64) bool extern
fun pub _opCmp(a u64, b u64) i32 extern
fun pub _opRange(a u64, b u64) Range<u64> extern // TBD: Generic function on range?
fun pub _opAdd(a u64, b u64) u64 extern
fun pub _opSub(a u64, b u64) u64 extern
fun pub _opNeg(a u64) u64 extern
fun pub _opMul(a u64, b u64) u64 extern
fun pub _opDiv(a u64, b u64) u64 extern
fun pub _opRem(a u64, b u64) u64 extern
fun pub _opBitNot(a u64) u64 extern
fun pub _opBitAnd(a u64, b u64) u64 extern
fun pub _opBitOr(a u64, b u64) u64 extern
fun pub _opBitXor(a u64, b u64) u64 extern
fun pub _opBitShl(a u64, b int) u64 extern
fun pub _opBitShr(a u64, b int) u64 extern
fun pub _opBitShr(a u64, b u64) u64 extern
fun pub _opBitShl(a u64, b u64) u64 extern



get pub u64.iterator() RangeIterator<u64>
    return RangeIterator<u64>(0, my)

type pub ro copy i128
    const __size int = 16
    const __align int = 16

type pub ro copy u128
    const __size int = 16
    const __align int = 16


type pub ro copy f32
    const __size int = 4
    const __align int = 4    
    const pub MAX f32 = 3.40282347E+38F
    const pub MIN f32 = -3.40282347E+38F
    const pub ZERO f32 = 0
    const pub ONE f32 = 1
    const pub EPSILON f32 = 1.401298E-45F
    const pub INF f32 = 1F/0F
    const pub NEG_INF f32 = -1F/0F
    const pub NAN f32 = 0f32/0f32
    const pub PI f32 = 3.141592653589793238
    const pub E f32 = 2.718281828459045235

get pub f32.isInfinity() bool extern
get pub f32.isNan() bool extern
get pub f32.isNegativeInfinity() bool extern
get pub f32.isPositiveInfinity() bool extern        

get pub f32.byte() ?byte extern
get pub f32.int() ?int extern
get pub f32.u64() ?u64 extern
get pub f32.f64() f64 extern
get pub f32.decimal() Decimal extern    
fun pub f32.str() str extern
get pub f32.byteMask() byte extern
get pub f32.intMask() int extern
get pub f32.u64Mask() u64 extern

        
fun pub f32.getHash() int extern
fun pub _opEq(a f32, b f32) bool extern
fun pub _opCmp(a f32, b f32) i32 extern
fun pub _opEqNan(a f32, b f32) bool extern
fun pub _opCmpNan(a f32, b f32) i32 extern
fun pub _opRange(a f32, b f32) Range<i32> extern // TBD: Generic function on range?
fun pub _opAdd(a f32, b f32) f32 extern
fun pub _opSub(a f32, b f32) f32 extern
fun pub _opNeg(a f32) f32 extern
fun pub _opMul(a f32, b f32) f32 extern
fun pub _opDiv(a f32, b f32) f32 extern
fun pub _opRem(a f32, b f32) f32 extern

get pub f32.iterator() RangeIterator<f32>
    return RangeIterator<f32>(0, my)

type pub ro copy f64
    const __size int = 8
    const __align int = 8    
    const pub MAX f64 = 1.7976931348623157E+308
    const pub MIN f64 = -1.7976931348623157E+308
    const pub ZERO f64 = 0
    const pub ONE f64 = 1
    const pub EPSILON f64 = 4.94065645841247E-324
    const pub INF f64 = 1.0/0.0
    const pub NEG_INF f64 = -1.0/0.0
    const pub NAN f64 = 0f64/0f64
    const pub PI f64 = 3.141592653589793238
    const pub E f64 = 2.718281828459045235

get pub f64.isInfinity() bool extern
get pub f64.isNan() bool extern
get pub f64.isNegativeInfinity() bool extern
get pub f64.isPositiveInfinity() bool extern        

get pub f64.byte() ?byte extern
get pub f64.int() ?int extern
get pub f64.u64() ?u64 extern
get pub f64.decimal() Decimal extern
fun pub f64.str() str extern
get pub f64.byteMask() byte extern
get pub f64.intMask() int extern
get pub f64.u64Mask() u64 extern
get pub f64.f32Clamp() f32 extern

fun pub f64.getHash() int extern

fun pub _opEq(a f64, b f64) bool extern
fun pub _opCmp(a f64, b f64) i32 extern
fun pub _opEqNan(a f64, b f64) bool extern
fun pub _opCmpNan(a f64, b f64) i32 extern
fun pub _opRange(a f64, b f64) Range<f64> extern // TBD: Generic function on range?
fun pub _opAdd(a f64, b f64) f64 extern
fun pub _opSub(a f64, b f64) f64 extern
fun pub _opNeg(a f64) f64 extern
fun pub _opMul(a f64, b f64) f64 extern
fun pub _opDiv(a f64, b f64) f64 extern
fun pub _opRem(a f64, b f64) f64 extern

get pub f64.iterator() RangeIterator<f64>
    return RangeIterator<f64>(0, my)


// 128 bit decimal integer.  This will support NAN, infinity, and
// exponents covering the entire range of f64 with more precision.
type pub ro copy Decimal
    const __size int = 16
    const __align int = 16
    const pub MAX Decimal = 1E+1000M
    const pub MIN Decimal = -1E+1000M
    const pub ZERO Decimal = 0
    const pub ONE Decimal = 1
    const pub INF Decimal = 1.0/0.0
    const pub NEG_INF Decimal = -1.0/0.0
    const pub NAN Decimal = 0.0/0.0
    
get pub Decimal.isInfinity() bool extern
get pub Decimal.isNan() bool extern
get pub Decimal.isNegativeInfinity() bool extern
get pub Decimal.isPositiveInfinity() bool extern

get pub Decimal.byte() ?byte extern
get pub Decimal.int() ?int extern
get pub Decimal.u64() ?u64 extern
fun pub Decimal.str() str extern
get pub Decimal.byteMask() byte extern
get pub Decimal.intMask() int extern
get pub Decimal.u64Mask() u64 extern
get pub Decimal.intClamp() int extern
get pub Decimal.f32Clamp() f32 extern
get pub Decimal.f64Clamp() f64 extern

fun pub Decimal.getHash() int extern
fun pub _opEq(a Decimal, b Decimal) bool extern
fun pub _opCmp(a Decimal, b Decimal) i32 extern
fun pub _opEqNan(a Decimal, b Decimal) bool extern
fun pub _opCmpNan(a Decimal, b Decimal) i32 extern
fun pub _opRange(a Decimal, b Decimal) Range<i32> extern // TBD: Generic function on range?
fun pub _opAdd(a Decimal, b Decimal) Decimal extern
fun pub _opSub(a Decimal, b Decimal) Decimal extern
fun pub _opNeg(a Decimal) Decimal extern
fun pub _opMul(a Decimal, b Decimal) Decimal extern
fun pub _opDiv(a Decimal, b Decimal) Decimal extern
fun pub _opRem(a Decimal, b Decimal) Decimal extern

fun pub Decimal.getIterator() RangeIterator<Decimal>
    return RangeIterator<Decimal>(0, my)

    