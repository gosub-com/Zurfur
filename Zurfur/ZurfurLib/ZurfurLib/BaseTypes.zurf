// Define the simple types:
//     i8, byte, i16, u16, i32, u32, int, u64, f32, f64, Decimal
//

mod Zurfur

pragma AllowUnderscoreDefinitions

// Blank function
[pub] fun get nop() extern
[pub] fun get todo() require(false) extern

// These implement throw and require reserved words
[pub] fun __throw(code ErrorCode, message str) extern
[pub] fun __throw(condition bool, code ErrorCode, message str) extern
[pub] fun __require(condition bool) extern
[pub] fun __require(condition bool, message str) extern
[pub] fun assert(condition bool) extern
[pub] fun assert(condition bool, message str) extern

// Return type of functions that don't return anything
[pub]
type void { }

// Empty value for pointers and optionals
[pub]
type nil { }

// Nilable<T> is the same as ?T.  Pointer and reference types are always
// optimized so that `?ref T`, `*T`, and `^T` are just one pointer.
[pub]
type Nilable<T>
    value T
    hasValue bool

[pub]
fun Nilable.new(value My.T)
    my.value = value
    my.hasValue = true


[pub]
type Error ro interface
    fun get code() ErrorCode
    fun get message() str


// Result<T> - Same as !T
[pub]
type Result<T> union
    ok T
    error ro Error

// This will probably be a specially recognized error code type
[pub]
type ErrorCode enum
    Success = 0 

    

// a UTF8 encoded character, same as i32
[pub]
type rune = i32

// Base interface for all types
[pub]
type object interface { }


// All types have a unique `id`, but other non-essential metadata is opt-in.
// This must always be 32 bits, even on 64 bit machines, so as not to change
// the `GcHeapObject` footprint.
[pub]
type Type ro copy
    id u32


// Swap two items
[pub] fun swap<T>(a mut ref T, b mut ref T)
    extern

// bool (true or false)
[pub]
type bool ro copy
    const __size int = 1


[pub static] fun bool.getHash(a bool) int extern
[pub static] fun bool._opEq(a bool, b bool) bool extern

// i8 (-128..127)
[pub]
type i8 ro copy
    const __size int = 1
    const __align int = 1
    const Zero i8 = 0
    const One i8 = 1
    const MinValue i8 = -128
    const MaxValue i8 = 127
    const NanOrMin i8 = MinValue
    
[pub] fun get i8.toStr() str extern
[pub] fun get i8.toByte() ?byte extern
[pub] fun get i8.toByteMask() byte extern
[pub] fun get i8.toI16() i16 extern
[pub] fun get i8.toI32() i32 extern
[pub] fun get i8.toInt() int extern
[pub] fun get i8.toF32() f32 extern
[pub] fun get i8.toF64() f64 extern
[pub] fun get i8.toDecimal() Decimal extern

[pub static] fun i8.getHash(a i8) int extern
[pub static] fun i8._opEq(a i8, b i8) bool extern
[pub static] fun i8._opCmp(a i8, b i8) i32 extern


// byte (0..255)
[pub] type byte ro copy
    const __size int = 1
    const __align int = 1    
    const Zero byte = 0
    const One byte = 1
    const MinValue byte = 0
    const MaxValue byte = 255
    const NanOrMin byte = MinValue
    
[pub] fun get byte.toStr() str extern
[pub] fun get byte.toI8() ?i8 extern
[pub] fun get byte.toI8Mask() i8 extern
[pub] fun get byte.toI16() i16 extern
[pub] fun get byte.toU16() u16 extern
[pub] fun get byte.toI32() i32 extern
[pub] fun get byte.toU32() u32 extern
[pub] fun get byte.toInt() int extern
[pub] fun get byte.toU64() u64 extern
[pub] fun get byte.toF32() f32 extern
[pub] fun get byte.toF64() f64 extern
[pub] fun get byte.toDecimal() Decimal extern

[pub static] fun byte.getHash(a byte) int extern
[pub static] fun byte._opEq(a byte, b byte) bool extern
[pub static] fun byte._opCmp(a byte, b byte) i32 extern


// i16 (-32768..32768)
[pub] type i16 ro copy
    const __size int = 2
    const __align int = 2    
    const Zero i16 = 0
    const One i16 = 1
    const MinValue i16 = -32768
    const MaxValue i16 = 32767
    const NanOrMin i16 = MinValue

[pub] fun get i16.toStr() str extern
[pub] fun get i16.toI8() ?i8 extern
[pub] fun get i16.toByte() ?byte extern
[pub] fun get i16.toU16() ?u16 extern
[pub] fun get i16.toI32() i32 extern
[pub] fun get i16.toInt() int extern
[pub] fun get i16.toF32() f32 extern
[pub] fun get i16.toF64() f64 extern
[pub] fun get i16.toDecimal() Decimal extern    
[pub] fun get i16.toI8Mask() i8 extern
[pub] fun get i16.toByteMask() byte extern
[pub] fun get i16.toU16Mask() u16 extern    

[pub static] fun i16.getHash(a i16) int extern
[pub static] fun i16._opEq(a i16, b i16) bool extern
[pub static] fun i16._opCmp(a i16, b i16) i32 extern



// u16 (0..65535)
[pub] type u16 ro copy
    const __size int = 2
    const __align int = 2    
    const Zero u16 = 0
    const One u16 = 1
    const MinValue u16 = 0
    const MaxValue u16 = 65535
    const NanOrMin u16 = MinValue
    

[pub] fun get u16.toStr() str extern
[pub] fun get u16.toI8() ?i8 extern
[pub] fun get u16.toByte() ?byte extern
[pub] fun get u16.toI16() ?i16 extern
[pub] fun get u16.toI32() i32 extern
[pub] fun get u16.toU32() u32 extern
[pub] fun get u16.toInt() int extern
[pub] fun get u16.toU64() u64 extern
[pub] fun get u16.toF32() f32 extern
[pub] fun get u16.toF64() f64 extern
[pub] fun get u16.toDecimal() Decimal extern
[pub] fun get u16.toI8Mask() i8 extern
[pub] fun get u16.toByteMask() byte extern
[pub] fun get u16.toI16Mask() i16 extern

[pub static] fun u16.getHash(a u16) int extern
[pub static] fun u16._opEq(a u16, b u16) bool extern
[pub static] fun u16._opCmp(a u16, b u16) i32 extern

// A 32 bit integer
[pub] type i32 ro copy
    const __size int = 4
    const __align int = 4    
    const Zero i32 = 0
    const One i32 = 1
    const MinValue i32 = -2147483648
    const MaxValue i32 = 2147483647
    const NanOrMin i32 = MinValue
    

[pub] fun get i32.toStr() str extern
[pub] fun get i32.toI8() ?i8 extern
[pub] fun get i32.toByte() ?byte extern
[pub] fun get i32.toI16() ?i16 extern
[pub] fun get i32.toU16() ?u16 extern
[pub] fun get i32.toU32() ?u32 extern
[pub] fun get i32.toInt() int extern
[pub] fun get i32.toF32() f32 extern
[pub] fun get i32.toF64() f64 extern
[pub] fun get i32.toDecimal() Decimal extern    
[pub] fun get i32.toI8Mask() i8 extern
[pub] fun get i32.toByteMask() byte extern
[pub] fun get i32.toI16Mask() i16 extern
[pub] fun get i32.toU16Mask() u16 extern
[pub] fun get i32.toU32Mask() u32 extern

[pub static] fun i32.getHash(a i32) int extern
[pub static] fun i32._opEq(a i32, b i32) bool extern
[pub static] fun i32._opCmp(a i32, b i32) i32 extern
[pub static] fun i32._opIn(a i32, b Range<i32>) bool extern
[pub static] fun i32._opRange(a i32, b i32) Range<i32> extern // TBD: Generic function on range?
[pub static] fun i32._opAdd(a i32, b i32) i32 extern
[pub static] fun i32._opSub(a i32, b i32) i32 extern
[pub static] fun i32._opNeg(a i32) i32 extern
[pub static] fun i32._opMul(a i32, b i32) i32 extern
[pub static] fun i32._opDiv(a i32, b i32) i32 extern
[pub static] fun i32._opRem(a i32, b i32) i32 extern
[pub static] fun i32._opBitNot(a i32) i32 extern
[pub static] fun i32._opBitAnd(a i32, b i32) i32 extern
[pub static] fun i32._opBitOr(a i32, b i32) i32 extern
[pub static] fun i32._opBitXor(a i32, b i32) i32 extern
[pub static] fun i32._opBitShl(a i32, b int) i32 extern
[pub static] fun i32._opBitShr(a i32, b int) i32 extern

[pub] fun get i32.iterator() RangeIterator<i32>
    return RangeIterator<i32>(0 i32, my)


// 32 bit unsigned integer
[pub] type u32 ro copy
    const __size int = 4
    const __align int = 4    
    const Zero u32 = 0
    const One u32 = 1
    const MinValue u32 = 0
    const MaxValue u32 = 4294967295
    const NanOrMin u32 = MinValue
    

[pub] fun get u32.toStr() str extern
[pub] fun get u32.toI8() ?i8 extern
[pub] fun get u32.toByte() ?byte extern
[pub] fun get u32.toI16() ?i16 extern
[pub] fun get u32.toU16() ?u16 extern
[pub] fun get u32.toI32() ?i32 extern        
[pub] fun get u32.toInt() int extern
[pub] fun get u32.toU64() u64 extern
[pub] fun get u32.toF32() f32 extern
[pub] fun get u32.toF64() f64 extern
[pub] fun get u32.toDecimal() Decimal extern        
[pub] fun get u32.toI8Mask() i8 extern
[pub] fun get u32.toByteMask() byte extern
[pub] fun get u32.toI16Mask() i16 extern
[pub] fun get u32.toU16Mask() u16 extern
[pub] fun get u32.toI32Mask() i32 extern

[pub static] fun u32.getHash(a u32) int extern
[pub static] fun u32._opEq(a u32, b u32) bool extern
[pub static] fun u32._opCmp(a u32, b u32) i32 extern
[pub static] fun u32._opIn(a u32, b Range<u32>) bool extern
[pub static] fun u32._opRange(a u32, b u32) Range<u32> extern // TBD: Generic function on range?
[pub static] fun u32._opAdd(a u32, b u32) u32 extern
[pub static] fun u32._opSub(a u32, b u32) u32 extern
[pub static] fun u32._opNeg(a u32) u32 extern
[pub static] fun u32._opMul(a u32, b u32) u32 extern
[pub static] fun u32._opDiv(a u32, b u32) u32 extern
[pub static] fun u32._opRem(a u32, b u32) u32 extern
[pub static] fun u32._opBitNot(a u32) u32 extern
[pub static] fun u32._opBitAnd(a u32, b u32) u32 extern
[pub static] fun u32._opBitOr(a u32, b u32) u32 extern
[pub static] fun u32._opBitXor(a u32, b u32) u32 extern
[pub static] fun u32._opBitShl(a u32, b int) u32 extern
[pub static] fun u32._opBitShr(a u32, b int) u32 extern

[pub] fun get u32.iterator() RangeIterator<u32>
    return RangeIterator<u32>(0 u32, my)


// A 64 bit integer (same as int)
[pub] type int ro copy
    const __size int = 8
    const __align int = 8    
    const Zero int = 0
    const One int = 1
    const MinValue int = -9223372036854775808
    const MaxValue int = 9223372036854775807
    const NanOrMin int = MinValue    

[pub] fun get int.toStr() str extern
[pub] fun get int.toI8() ?i8 extern
[pub] fun get int.toByte() ?byte extern
[pub] fun get int.toI16() ?i16 extern
[pub] fun get int.toU16() ?u16 extern
[pub] fun get int.toI32() ?i32 extern
[pub] fun get int.toU32() ?u32 extern
[pub] fun get int.toU64() ?u64 extern    
[pub] fun get int.toF32() f32 extern
[pub] fun get int.toF64() f64 extern
[pub] fun get int.toDecimal() Decimal extern
[pub] fun get int.toI8Mask() i8 extern
[pub] fun get int.toByteMask() byte extern
[pub] fun get int.toI16Mask() i16 extern
[pub] fun get int.toU16Mask() u16 extern
[pub] fun get int.toI32Mask() i32 extern
[pub] fun get int.toU32Mask() u32 extern
[pub] fun get int.toU64Mask() u64 extern


[pub static] fun int.getHash(a int) int extern
[pub static] fun int._opEq(a int, b int) bool extern
[pub static] fun int._opCmp(a int, b int) i32 extern
[pub static] fun int._opIn(a int, b Range<int>) bool extern
[pub static] fun int._opRange(a int, b int) Range<int> extern // TBD: Generic function on range?
[pub static] fun int._opAdd(a int, b int) int extern
[pub static] fun int._opSub(a int, b int) int extern
[pub static] fun int._opNeg(a int) int extern
[pub static] fun int._opMul(a int, b int) int extern
[pub static] fun int._opDiv(a int, b int) int extern
[pub static] fun int._opRem(a int, b int) int extern
[pub static] fun int._opBitNot(a int) int extern
[pub static] fun int._opBitAnd(a int, b int) int extern
[pub static] fun int._opBitOr(a int, b int) int extern
[pub static] fun int._opBitXor(a int, b int) int extern
[pub static] fun int._opBitShl(a int, b int) int extern
[pub static] fun int._opBitShr(a int, b int) int extern


[pub] fun get int.iterator() RangeIterator<int>
    return RangeIterator<int>(0, my)

// 64 bit unsigned integer
[pub] type u64 ro copy
    const __size int = 8
    const __align int = 8    
    const Zero u64 = 0
    const One u64 = 1
    const MinValue u64 = 0
    const MaxValue u64 = 18446744073709551615
    const NanOrMin u64 = MinValue

[pub] fun get u64.toStr() str extern
[pub] fun get u64.toI8() ?i8 extern
[pub] fun get u64.toByte() ?byte extern
[pub] fun get u64.toI16() ?i16 extern
[pub] fun get u64.toU16() ?u16 extern
[pub] fun get u64.toI32() ?i32 extern
[pub] fun get u64.toU32() ?u32 extern
[pub] fun get u64.toInt() ?int extern
[pub] fun get u64.toF32() f32 extern
[pub] fun get u64.toF64() f64 extern
[pub] fun get u64.toDecimal() Decimal extern
[pub] fun get u64.toI8Mask() i8 extern
[pub] fun get u64.toByteMask() byte extern
[pub] fun get u64.toI16Mask() i16 extern
[pub] fun get u64.toU16Mask() u16 extern
[pub] fun get u64.toI32Mask() i32 extern
[pub] fun get u64.toU32Mask() u32 extern
[pub] fun get u64.toIntMask() int extern

[pub static] fun u64.getHash(a u64) int extern
[pub static] fun u64._opEq(a u64, b u64) bool extern
[pub static] fun u64._opCmp(a u64, b u64) i32 extern
[pub static] fun u64._opIn(a u64, b Range<u64>) bool extern
[pub static] fun u64._opRange(a u64, b u64) Range<u64> extern // TBD: Generic function on range?
[pub static] fun u64._opAdd(a u64, b u64) u64 extern
[pub static] fun u64._opSub(a u64, b u64) u64 extern
[pub static] fun u64._opNeg(a u64) u64 extern
[pub static] fun u64._opMul(a u64, b u64) u64 extern
[pub static] fun u64._opDiv(a u64, b u64) u64 extern
[pub static] fun u64._opRem(a u64, b u64) u64 extern
[pub static] fun u64._opBitNot(a u64) u64 extern
[pub static] fun u64._opBitAnd(a u64, b u64) u64 extern
[pub static] fun u64._opBitOr(a u64, b u64) u64 extern
[pub static] fun u64._opBitXor(a u64, b u64) u64 extern
[pub static] fun u64._opBitShl(a u64, b int) u64 extern
[pub static] fun u64._opBitShr(a u64, b int) u64 extern
[pub static] fun u64._opBitShr(a u64, b u64) u64 extern
[pub static] fun u64._opBitShl(a u64, b u64) u64 extern



[pub] fun get u64.iterator() RangeIterator<u64>
    return RangeIterator<u64>(0 u64, my)

[pub] type i128 ro copy
    const __size int = 16
    const __align int = 16

[pub] type u128 ro copy
    const __size int = 16
    const __align int = 16


[pub] type f32 ro copy
    const __size int = 4
    const __align int = 4    
    const Zero f32 = 0
    const One f32 = 1
    const MinValue f32 = -3.40282347E+38F
    const MaxValue f32 = 3.40282347E+38F
    const NanOrMin f32 = MinValue    
    const epsilon f32 = 1.401298E-45F
    const infinity f32 = 1F/0F
    const negativeInfinity f32 = -1F/0F
    const nan f32 = 0f32/0f32
    const PI f32 = 3.141592653589793238
    const E f32 = 2.718281828459045235

[pub] fun get f32.isInfinity() bool extern
[pub] fun get f32.isNan() bool extern
[pub] fun get f32.isNegInfinity() bool extern
[pub] fun get f32.isPosInfinity() bool extern        

[pub] fun get f32.toStr() str extern
[pub] fun get f32.toByte() ?byte extern
[pub] fun get f32.toInt() ?int extern
[pub] fun get f32.toU64() ?u64 extern
[pub] fun get f32.toF64() f64 extern
[pub] fun get f32.toDecimal() Decimal extern    
[pub] fun get f32.toByteMask() byte extern
[pub] fun get f32.toIntMask() int extern
[pub] fun get f32.toU64Mask() u64 extern
        
[pub static] fun f32.getHash(a f32) int extern
[pub static] fun f32._opEq(a f32, b f32) bool extern
[pub static] fun f32._opCmp(a f32, b f32) i32 extern
[pub static] fun f32._opEqUnordered(a f32, b f32) bool extern
[pub static] fun f32._opGtUnordered(a f32, b f32) bool extern
[pub static] fun f32._opGeUnordered(a f32, b f32) bool extern
[pub static] fun f32._opLtUnordered(a f32, b f32) bool extern
[pub static] fun f32._opLeUnordered(a f32, b f32) bool extern
[pub static] fun f32._opIn(a f32, b Range<f32>) bool extern
[pub static] fun f32._opRange(a f32, b f32) Range<i32> extern // TBD: Generic function on range?
[pub static] fun f32._opAdd(a f32, b f32) f32 extern
[pub static] fun f32._opSub(a f32, b f32) f32 extern
[pub static] fun f32._opNeg(a f32) f32 extern
[pub static] fun f32._opMul(a f32, b f32) f32 extern
[pub static] fun f32._opDiv(a f32, b f32) f32 extern
[pub static] fun f32._opRem(a f32, b f32) f32 extern


[pub] type f64 ro copy
    const __size int = 8
    const __align int = 8    
    const Zero f64 = 0
    const One f64 = 1
    const MinValue f64 = -1.7976931348623157E+308
    const MaxValue f64 = 1.7976931348623157E+308
    const NanOrMin f64 = MinValue    
    const epsilon f64 = 4.94065645841247E-324
    const infinity f64 = 1.0/0.0
    const negativeInfinity f64 = -1.0/0.0
    const nan f64 = 0f64/0f64
    const PI f64 = 3.141592653589793238
    const E f64 = 2.718281828459045235

[pub] fun get f64.isInfinity() bool extern
[pub] fun get f64.isNan() bool extern
[pub] fun get f64.isNegInfinity() bool extern
[pub] fun get f64.isPosInfinity() bool extern        

[pub] fun get f64.toStr() str extern
[pub] fun get f64.toByte() ?byte extern
[pub] fun get f64.toInt() ?int extern
[pub] fun get f64.toU64() ?u64 extern
[pub] fun get f64.toDecimal() Decimal extern
[pub] fun get f64.toByteMask() byte extern
[pub] fun get f64.toIntMask() int extern
[pub] fun get f64.toU64Mask() u64 extern
[pub] fun get f64.toF32Clamp() f32 extern

[pub static] fun f64.getHash(a f64) int extern
[pub static] fun f64._opEq(a f64, b f64) bool extern
[pub static] fun f64._opCmp(a f64, b f64) i32 extern
[pub static] fun f64._opEqUnordered(a f64, b f64) bool extern
[pub static] fun f64._opGtUnordered(a f64, b f64) bool extern
[pub static] fun f64._opGeUnordered(a f64, b f64) bool extern
[pub static] fun f64._opLtUnordered(a f64, b f64) bool extern
[pub static] fun f64._opLeUnordered(a f64, b f64) bool extern
[pub static] fun f64._opIn(a f64, b Range<f64>) bool extern
[pub static] fun f64._opRange(a f64, b f64) Range<f64> extern // TBD: Generic function on range?
[pub static] fun f64._opAdd(a f64, b f64) f64 extern
[pub static] fun f64._opSub(a f64, b f64) f64 extern
[pub static] fun f64._opNeg(a f64) f64 extern
[pub static] fun f64._opMul(a f64, b f64) f64 extern
[pub static] fun f64._opDiv(a f64, b f64) f64 extern
[pub static] fun f64._opRem(a f64, b f64) f64 extern


// 128 bit decimal integer.  This will support nan, infinity, and
// exponents covering the entire range of f64 with more precision.
[pub] type Decimal ro copy
    const __size int = 16
    const __align int = 16
    const Zero Decimal = 0
    const One Decimal = 1
    const MinValue Decimal = -1E+1000M
    const MaxValue Decimal = 1E+1000M
    const NanOrMin Decimal = MinValue    
    const infinity Decimal = 1.0/0.0
    const negativeInfinity Decimal = -1.0/0.0
    const nan Decimal = 0.0/0.0
    
[pub] fun get Decimal.isInfinity() bool extern
[pub] fun get Decimal.isNan() bool extern
[pub] fun get Decimal.isNegInfinity() bool extern
[pub] fun get Decimal.isPosInfinity() bool extern

[pub] fun get Decimal.toStr() str extern
[pub] fun get Decimal.toByte() ?byte extern
[pub] fun get Decimal.toInt() ?int extern
[pub] fun get Decimal.toU64() ?u64 extern
[pub] fun get Decimal.toByteMask() byte extern
[pub] fun get Decimal.toIntMask() int extern
[pub] fun get Decimal.toU64Mask() u64 extern
[pub] fun get Decimal.toIntClamp() int extern
[pub] fun get Decimal.toF32Clamp() f32 extern
[pub] fun get Decimal.toF64Clamp() f64 extern

[pub static] fun Decimal.getHash(a Decimal) int extern
[pub static] fun Decimal._opEq(a Decimal, b Decimal) bool extern
[pub static] fun Decimal._opCmp(a Decimal, b Decimal) i32 extern
[pub static] fun Decimal._opEqUnordered(a Decimal, b Decimal) bool extern
[pub static] fun Decimal._opGtUnordered(a Decimal, b Decimal) bool extern
[pub static] fun Decimal._opGeUnordered(a Decimal, b Decimal) bool extern
[pub static] fun Decimal._opLtUnordered(a Decimal, b Decimal) bool extern
[pub static] fun Decimal._opLeUnordered(a Decimal, b Decimal) bool extern
[pub static] fun Decimal._opIn(a Decimal, b Range<Decimal>) bool extern
[pub static] fun Decimal._opRange(a Decimal, b Decimal) Range<i32> extern // TBD: Generic function on range?
[pub static] fun Decimal._opAdd(a Decimal, b Decimal) Decimal extern
[pub static] fun Decimal._opSub(a Decimal, b Decimal) Decimal extern
[pub static] fun Decimal._opNeg(a Decimal) Decimal extern
[pub static] fun Decimal._opMul(a Decimal, b Decimal) Decimal extern
[pub static] fun Decimal._opDiv(a Decimal, b Decimal) Decimal extern
[pub static] fun Decimal._opRem(a Decimal, b Decimal) Decimal extern