/// Define the simple types:
///     i8, u8, i16, u16, i32, u32, i64, u64, f32, f64, Decimal.
///
/// int and uint are 64 bits
/// xint and xuint are pointer sized integers (32 or 64 bits)

module Zurfur

use Zurfur.Operators
use Zurfur.Collections

pragma AllowUnderscoreDefinitions


pub type void { }
pub type byte = u8
pub type int = i64
pub type uint = u64


/// Base class for all types.  Even though Zurfur doesn't yet
/// support inheritance, all objects do inherit from `object`.
/// Any boxed object (e.g ^int) can be cast to ^object and back.
pub type object { }

/// All types have a unique `id`, but other
/// non-essential metadata is opt-in
pub type ro copy Type
    @id i32 pub get

// TBD: Needs to be an actual type to enforce proper typing and casting rules
/// 32 bit or 64 bit integer depending on the platform
pub type xint = i32
pub type xuint = u32

pub fun nop() {}

// The compiler implements this fundamental function:
//      fun move<T>(take own T) T { return take }

/// Swap two items
fun<T> swap(a mut ref T, b mut ref T)
    @t = move(a)
    a = move(b)
    b = t

/// bool (true or false)
pub type ro copy bool
    const __size int = 1

impl bool::GetHash { pub fun getHash() i64 extern }
impl bool::OpEqTotal<bool> { pub fun opEqTotalTotal(a bool) bool extern }

/// i8 (-128..127)
pub type ro copy i8
    const __size int = 1
    
    pub const MAX i8 = 127
    pub const MIN i8 = -128
    pub const ZERO i8 = 0
    pub const ONE i8 = 1
    
    pub fun i16() i16 extern
    pub fun i32() i32 extern
    pub fun i64() i64 extern
    pub fun f32() f32 extern
    pub fun f64() f64 extern
    pub fun toDecimal() Decimal extern

    pub fun u8Mask() u8 extern
    pub fun u8Fail() u8 require this >= 0 extern


impl i8::GetHash { pub fun getHash() i64 extern }
impl i8::OpEqTotal<i8> { pub fun opEqTotal(a i8) bool extern }
impl i8::OpCmpTotal<i8> { pub fun opCmpTotal(a i8) int extern }


/// u8 (0..255) same as byte
pub type ro copy u8
    const __size int = 1
    
    pub const MAX u8 = 255
    pub const MIN u8 = 0
    pub const ZERO u8 = 0
    pub const ONE u8 = 1
    
    pub fun i16() i16 extern
    pub fun u16() u16 extern
    pub fun i32() i32 extern
    pub fun u32() u32 extern
    pub fun i64() i64 extern
    pub fun u64() u64 extern
    pub fun f32() f32 extern
    pub fun f64() f64 extern
    pub fun toDecimal() Decimal extern
    
    pub fun i8Mask() i8 extern
    pub fun i8Fail() i8 require this <= i8.MAX extern

impl u8::GetHash { pub fun getHash() i64 extern }
impl u8::OpEqTotal<u8> { pub fun opEqTotal(a u8) bool extern }
impl u8::OpCmpTotal<u8> { pub fun opCmpTotal(a u8) int extern }


/// i16 (-32768..32768)
pub type ro copy i16
    const __size int = 2
    
    pub const MAX i16 = 32767
    pub const MIN i16 = -32768
    pub const ZERO i8 = 0
    pub const ONE i8 = 1

    pub fun i32() i32 extern
    pub fun i64() i64 extern
    pub fun f32() f32 extern
    pub fun f64() f64 extern
    pub fun toDecimal() Decimal extern    
        
    pub fun i8Mask() i8 extern
    pub fun u8Mask() u8 extern
    pub fun u16Mask() u16 extern

    // TBD: Add requires    
    pub fun i8Fail() i8 extern
    pub fun u8Fail() u8 extern
    pub fun u16Fail() u16 extern


impl i16::GetHash { pub fun getHash() i64 extern }
impl i16::OpEqTotal<i16> { pub fun opEqTotal(a i16) bool extern }
impl i16::OpCmpTotal<i16> { pub fun opCmpTotal(a i16) i64 extern }



/// u16 (0..65535)
pub type ro copy u16
    const __size int = 2

    pub const MAX u16 = 65535
    pub const MIN u16 = 0
    pub const ZERO i8 = 0
    pub const ONE i8 = 1

    pub fun i32() i32 extern
    pub fun u32() u32 extern
    pub fun i64() i64 extern
    pub fun u64() u64 extern
    pub fun f32() f32 extern
    pub fun f64() f64 extern
    pub fun toDecimal() Decimal extern
        
    pub fun i8Mask() i8 extern
    pub fun u8Mask() u8 extern
    pub fun i16Mask() i16 extern

    // TBD: Add requires
    pub fun i8Fail() i8 extern
    pub fun u8Fail() u8 extern
    pub fun i16Fail() i16 extern

impl u16::GetHash { pub fun getHash() i64 extern }
impl u16::OpEqTotal<u16> { pub fun opEqTotal(a u16) bool extern }
impl u16::OpCmpTotal<u16> { pub fun opCmpTotal(a u16) i64 extern }

/// A 32 bit integer
pub type ro copy i32
    const __size int = 4

    pub const MAX i32 = 2147483647
    pub const MIN i32 = -2147483648
    pub const ZERO i8 = 0
    pub const ONE i8 = 1

    pub fun i64() i64 extern
    pub fun f32() f32 extern
    pub fun f64() f64 extern
    pub fun toDecimal() Decimal extern    
    
    pub fun i8Mask() i8 extern
    pub fun u8Mask() u8 extern
    pub fun i16Mask() i16 extern
    pub fun u16Mask() u16 extern
    pub fun u32Mask() u32 extern

    // TBD: Add requires
    pub fun i8Fail() i8 extern
    pub fun u8Fail() u8 extern
    pub fun i16Fail() i16 extern
    pub fun u16Fail() u16 extern
    pub fun u32Fail() u32 extern

impl i32::GetHash { pub fun getHash() int extern }
impl i32::OpEqTotal<i32> { pub fun opEqTotal(a i32) bool extern }
impl i32::OpCmpTotal<i32> { pub fun opCmpTotal(a i32) int extern }
impl i32::OpAdd<i32, i32> { pub fun opAdd(n i32) i32 extern }
impl i32::OpSub<i32, i32> {  pub fun opSub(n i32) i32 extern }
impl i32::OpNeg<i32> {  pub fun opNeg() i32 extern }
impl i32::OpMul<i32, i32> { pub fun opMul(n i32) i32 extern }
impl i32::OpDiv<i32, i32> { pub fun opDiv(n i32) i32 extern }
impl i32::OpRem<i32, i32> { pub fun opRem(n i32) i32 extern }


impl i32::GetIterator<i32>
    pub fun getIterator() RangeIterator<i32>
        return RangeIterator<i32>(0, this)


/// 32 bit unsigned integer
pub type ro copy u32
    const __size int = 4

    pub const MAX u32 = 4294967295
    pub const MIN u32 = 0
    pub const ZERO i8 = 0
    pub const ONE i8 = 1

    pub fun i64() i64 extern
    pub fun u64() u64 extern
    pub fun f32() f32 extern
    pub fun f64() f64 extern
    pub fun toDecimal() Decimal extern        

    pub fun i8Mask() i8 extern
    pub fun u8Mask() u8 extern
    pub fun i16Mask() i16 extern
    pub fun u16Mask() u16 extern
    pub fun i32Mask() i32 extern

    // TBD: Add requires
    pub fun i8Fail() i8 extern
    pub fun u8Fail() u8 extern
    pub fun i16Fail() i16 extern
    pub fun u16Fail() u16 extern
    pub fun i32Fail() i32 extern
        


impl u32::GetHash { pub fun getHash() int extern }
impl u32::OpEqTotal<u32> { pub fun opEqTotal(a u32) bool extern }
impl u32::OpCmpTotal<u32> { pub fun opCmpTotal(a u32) int extern }
impl u32::OpAdd<u32, u32> { pub fun opAdd(n u32) u32 extern }
impl u32::OpSub<u32, u32> {  pub fun opSub(n u32) u32 extern }
impl u32::OpNeg<u32> {  pub fun opNeg() u32 extern }
impl u32::OpMul<u32, u32> { pub fun opMul(n u32) u32 extern }
impl u32::OpDiv<u32, u32> { pub fun opDiv(n u32) u32 extern }
impl u32::OpRem<u32, u32> { pub fun opRem(n u32) u32 extern }


impl u32::GetIterator<u32>
    pub fun getIterator() RangeIterator<u32>
        return RangeIterator<u32>(0, this)


/// A 64 bit integer (same as int)
pub type ro copy i64
    const __size int = 8

    pub const MAX i64 = 9223372036854775807
    pub const MIN i64 = -9223372036854775808
    pub const ZERO i8 = 0
    pub const ONE i8 = 1

    pub fun f32() f32 extern
    pub fun f64() f64 extern
    pub fun toDecimal() Decimal extern

    pub fun i8Mask() i8 extern
    pub fun u8Mask() u8 extern
    pub fun i16Mask() i16 extern
    pub fun u16Mask() u16 extern
    pub fun i32Mask() i32 extern
    pub fun u32Mask() u32 extern
    pub fun u64Mask() u64 extern

    // TBD: Add requires
    pub fun i8Fail() i8 extern
    pub fun u8Fail() u8 extern
    pub fun i16Fail() i16 extern
    pub fun u16Fail() u16 extern
    pub fun i32Fail() i32 extern
    pub fun u32Fail() u32 extern
    pub fun u64Fail() u64 extern
    

impl i64::GetHash { pub fun getHash() int extern }
impl i64::OpEqTotal<i64> { pub fun opEqTotal(a i64) bool extern }
impl i64::OpCmpTotal<i64> { pub fun opCmpTotal(a i64) int extern }
impl i64::OpAdd<i64, i64> { pub fun opAdd(n i64) i64 extern }
impl i64::OpSub<i64, i64> {  pub fun opSub(n i64) i64 extern }
impl i64::OpNeg<i64> {  pub fun opNeg() i64 extern }
impl i64::OpMul<i64, i64> { pub fun opMul(n i64) i64 extern }
impl i64::OpDiv<i64, i64> { pub fun opDiv(n i64) i64 extern }
impl i64::OpRem<i64, i64> { pub fun opRem(n i64) i64 extern }

impl i64::GetIterator<i64>
    pub fun getIterator() RangeIterator<i64>
        return RangeIterator<i64>(0, this)


/// 64 bit unsigned integer
pub type ro copy u64
    const __size int = 8

    pub const MAX u64 = 18446744073709551615
    pub const MIN u64 = 0
    pub const ZERO u64 = 0
    pub const ONE u64 = 1

    pub fun f32() f32 extern
    pub fun f64() f64 extern
    pub fun toDecimal() Decimal extern

    pub fun i8Mask() i8 extern
    pub fun u8Mask() u8 extern
    pub fun i16Mask() i16 extern
    pub fun u16Mask() u16 extern
    pub fun i32Mask() i32 extern
    pub fun u32Mask() u32 extern
    pub fun i64Mask() i64 extern

    // TBD: Add requires
    pub fun i8Fail() i8 extern
    pub fun u8Fail() u8 extern
    pub fun i16Fail() i16 extern
    pub fun u16Fail() u16 extern
    pub fun i32Fail() i32 extern
    pub fun u32Fail() u32 extern
    pub fun i64Fail() i64 extern


impl u64::GetHash { pub fun getHash() int extern }
impl u64::OpEqTotal<u64> { pub fun opEqTotal(a u64) bool extern }
impl u64::OpCmpTotal<u64> { pub fun opCmpTotal(a u64) int extern }
impl u64::OpAdd<u64, u64> { pub fun opAdd(n u64) u64 extern }
impl u64::OpSub<u64, u64> {  pub fun opSub(n u64) u64 extern }
impl u64::OpNeg<u64> {  pub fun opNeg() u64 extern }
impl u64::OpMul<u64, u64> { pub fun opMul(n u64) u64 extern }
impl u64::OpDiv<u64, u64> { pub fun opDiv(n u64) u64 extern }
impl u64::OpRem<u64, u64> { pub fun opRem(n u64) u64 extern }

impl u64::GetIterator<u64>
    pub fun getIterator() RangeIterator<u64>
        return RangeIterator<u64>(0, this)


pub type ro copy f32
    const __size int = 4

    pub const MAX f32 = 3.40282347E+38F
    pub const MIN f32 = -3.40282347E+38F
    pub const ZERO f32 = 0
    pub const ONE f32 = 1
    pub const EPSILON f32 = 1.401298E-45F
    pub const INF f32 = 1F/0F
    pub const NEG_INF f32 = -1F/0F
    pub const NAN f32 = 0_f32/0_f32
    pub const PI f32 = 3.141592653589793238
    pub const E f32 = 2.718281828459045235

    get isInfinity() bool extern
    get isNan() bool extern
    get isNegativeInfinity() bool extern
    get isPositiveInfinity() bool extern        

    pub fun f64() f64 extern
    pub fun toDecimal() Decimal extern    

    pub fun i8Mask() i8 extern
    pub fun u8Mask() u8 extern
    pub fun i16Mask() i16 extern
    pub fun u16Mask() u16 extern
    pub fun i32Mask() i32 extern
    pub fun u32Mask() u32 extern
    pub fun i64Mask() i64 extern
    pub fun u64Mask() u64 extern

    // TBD: Add requires
    pub fun i8Fail() i8 extern
    pub fun u8Fail() u8 extern
    pub fun i16Fail() i16 extern
    pub fun u16Fail() u16 extern
    pub fun i32Fail() i32 extern
    pub fun u32Fail() u32 extern
    pub fun i64Fail() i64 extern
    pub fun u64Fail() u64 extern
        

impl f32::GetHash { pub fun getHash() int extern }
impl f32::OpEqTotal<f32> { pub fun opEqTotal(a f32) bool extern }
impl f32::OpCmpTotal<f32> { pub fun opCmpTotal(a f32) int extern }
impl f32::OpEqPartial<f32> { pub fun opEqPartial(a f32) bool extern }
impl f32::OpCmpPartial<f32> { pub fun opCmpPartial(a f32) int extern }
impl f32::OpAdd<f32, f32> { pub fun opAdd(n f32) f32 extern }
impl f32::OpSub<f32, f32> {  pub fun opSub(n f32) f32 extern }
impl f32::OpNeg<f32> {  pub fun opNeg() f32 extern }
impl f32::OpMul<f32, f32> { pub fun opMul(n f32) f32 extern }
impl f32::OpDiv<f32, f32> { pub fun opDiv(n f32) f32 extern }
impl f32::OpRem<f32, f32> { pub fun opRem(n f32) f32 extern }

impl f32::GetIterator<f32>
    pub fun getIterator() RangeIterator<f32>
        return RangeIterator<f32>(0, this)


pub type ro copy f64
    const __size int = 8

    pub const MAX f64 = 1.7976931348623157E+308
    pub const MIN f64 = -1.7976931348623157E+308
    pub const ZERO f64 = 0
    pub const ONE f64 = 1
    pub const EPSILON f64 = 4.94065645841247E-324
    pub const INF f64 = 1.0/0.0
    pub const NEG_INF f64 = -1.0/0.0
    pub const NAN f64 = 0_f64/0_f64
    const PI f64 = 3.141592653589793238
    const E f64 = 2.718281828459045235

    get isInfinity() bool extern
    get isNan() bool extern
    get isNegativeInfinity() bool extern
    get isPositiveInfinity() bool extern        

    pub fun toDecimal() Decimal extern

    pub fun i8Mask() i8 extern
    pub fun u8Mask() u8 extern
    pub fun i16Mask() i16 extern
    pub fun u16Mask() u16 extern
    pub fun i32Mask() i32 extern
    pub fun u32Mask() u32 extern
    pub fun i64Mask() i64 extern
    pub fun u64Mask() u64 extern
    pub fun f32Clamp() f32 extern
    pub fun i8Fail() i8 extern
    pub fun u8Fail() u8 extern
    pub fun i16Fail() i16 extern
    pub fun u16Fail() u16 extern
    pub fun i32Fail() i32 extern
    pub fun u32Fail() u32 extern
    pub fun i64Fail() i64 extern
    pub fun u64Fail() u64 extern
    pub fun f32Fail() f32 extern
    
    pub fun getHash() i64 extern    
    

impl f64::GetHash { pub fun getHash() int extern }
impl f64::OpEqTotal<f64> { pub fun opEqTotal(a f64) bool extern }
impl f64::OpCmpTotal<f64> { pub fun opCmpTotal(a f64) int extern }
impl f64::OpEqPartial<f64> { pub fun opEqPartial(a f64) bool extern }
impl f64::OpCmpPartial<f64> { pub fun opCmpPartial(a f64) int extern }
impl f64::OpAdd<f64, f64> { pub fun opAdd(n f64) f64 extern }
impl f64::OpSub<f64, f64> {  pub fun opSub(n f64) f64 extern }
impl f64::OpNeg<f64> {  pub fun opNeg() f64 extern }
impl f64::OpMul<f64, f64> { pub fun opMul(n f64) f64 extern }
impl f64::OpDiv<f64, f64> { pub fun opDiv(n f64) f64 extern }
impl f64::OpRem<f64, f64> { pub fun opRem(n f64) f64 extern }

impl f64::GetIterator<f64>
    pub fun getIterator() RangeIterator<f64>
        return RangeIterator<f64>(0, this)



/// 128 bit decimal integer.  This will support NAN, infinity, and
/// exponents covering the entire range of f64 with more precision.
pub type ro copy Decimal
    const __size int = 16

    pub fun new(a Decimal) extern

    pub const MAX Decimal = 1E+1000M
    pub const MIN Decimal = -1E+1000M
    pub const ZERO Decimal = 0
    pub const ONE Decimal = 1
    pub const INF Decimal = 1.0/0.0
    pub const NEG_INF Decimal = -1.0/0.0
    pub const NAN Decimal = 0.0/0.0
    
    get isInfinity() bool extern
    get isNan() bool extern
    get isNegativeInfinity() bool extern
    get isPositiveInfinity() bool extern

    pub fun i8Mask() i8 extern
    pub fun u8Mask() u8 extern
    pub fun i16Mask() i16 extern
    pub fun u16Mask() u16 extern
    pub fun i32Mask() i32 extern
    pub fun u32Mask() u32 extern
    pub fun i64Mask() i64 extern
    pub fun u64Mask() u64 extern
    pub fun f32Clamp() f32 extern
    pub fun f64Clamp() f64 extern
    pub fun i8Fail() i8 extern
    pub fun u8Fail() u8 extern
    pub fun i16Fail() i16 extern
    pub fun u16Fail() u16 extern
    pub fun i32Fail() i32 extern
    pub fun u32Fail() u32 extern
    pub fun i64Fail() i64 extern
    pub fun u64Fail() u64 extern


impl Decimal::GetHash { pub fun getHash() int extern }
impl Decimal::OpEqTotal<Decimal> { pub fun opEqTotal(a Decimal) bool extern }
impl Decimal::OpCmpTotal<Decimal> { pub fun opCmpTotal(a Decimal) int extern }
impl Decimal::OpEqPartial<Decimal> { pub fun opEqPartial(a Decimal) bool extern }
impl Decimal::OpCmpPartial<Decimal> { pub fun opCmpPartial(a Decimal) int extern }
impl Decimal::OpAdd<Decimal, Decimal> { pub fun opAdd(n Decimal) Decimal extern }
impl Decimal::OpSub<Decimal, Decimal> {  pub fun opSub(n Decimal) Decimal extern }
impl Decimal::OpNeg<Decimal> {  pub fun opNeg() Decimal extern }
impl Decimal::OpMul<Decimal, Decimal> { pub fun opMul(n Decimal) Decimal extern }
impl Decimal::OpDiv<Decimal, Decimal> { pub fun opDiv(n Decimal) Decimal extern }
impl Decimal::OpRem<Decimal, Decimal> { pub fun opRem(n Decimal) Decimal extern }

impl Decimal::GetIterator<Decimal>
    pub fun getIterator() RangeIterator<Decimal>
        return RangeIterator<Decimal>(0, this)