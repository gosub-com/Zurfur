// Define the simple types:
//     i8, byte, i16, u16, i32, u32, int, u64, f32, f64, Decimal
//

module Zurfur

pragma AllowUnderscoreDefinitions

// Blank function
[pub] fun get nop() extern

// These implement throw and require reserved words
[pub] fun __throw(code ErrorCode, message str) extern
[pub] fun __throw(condition bool, code ErrorCode, message str) extern
[pub] fun __require(condition bool) extern
[pub] fun __require(condition bool, message str) extern

// 
[pub] fun assert(condition bool) extern
[pub] fun assert(condition bool, message str) extern

[pub] interface Error
    fun get code() ErrorCode impl
    fun get Message() str impl

// This will probably be a specially recognized error code type
[pub] enum ErrorCode
    Success = 0 

// TBD: Probably need to remove this
fun get todo() require(false) extern

// Return type of functions that don't return anything
[pub] type void { }

// Empty value for pointers and optionals
[pub] type nil { }

// a UTF8 encoded character, same as i32
[pub] type rune = i32

// Base interface for all types
[pub] interface object { }

// All types have a unique `id`, but other
// non-essential metadata is opt-in
[pub] type ro copy Type
    @id i32 pub ro


// Swap two items
[pub] fun swap<T>(a mut ref T, b mut ref T)
    extern

// bool (true or false)
[pub] type ro copy bool
    const __size int = 1


[pub] fun bool.getHash() int extern
[pub] fun bool._opEq(a bool) bool extern

// i8 (-128..127)
[pub] type ro copy i8
    const __size int = 1
    const __align int = 1
    [pub] const MAX i8 = 127
    [pub] const MIN i8 = -128
    [pub] const ZERO i8 = 0
    [pub] const ONE i8 = 1
    
[pub] fun get i8.byte() ?byte extern
[pub] fun get i8.i16() i16 extern
[pub] fun get i8.i32() i32 extern
[pub] fun get i8.int() int extern
[pub] fun get i8.f32() f32 extern
[pub] fun get i8.f64() f64 extern
[pub] fun get i8.decimal() Decimal extern
[pub] fun i8.str() str extern
[pub] fun get i8.byteMask() byte extern

[pub] fun i8.getHash() int extern
[pub] fun i8._opEq(a i8) bool extern
[pub] fun i8._opCmp(a i8) i32 extern


// byte (0..255)
[pub] type ro copy byte
    const __size int = 1
    const __align int = 1    
    [pub] const MAX byte = 255
    [pub] const MIN byte = 0
    [pub] const ZERO byte = 0
    [pub] const ONE byte = 1
    
[pub] fun get byte.i8() ?i8 extern
[pub] fun get byte.i16() i16 extern
[pub] fun get byte.u16() u16 extern
[pub] fun get byte.i32() i32 extern
[pub] fun get byte.u32() u32 extern
[pub] fun get byte.int() int extern
[pub] fun get byte.u64() u64 extern
[pub] fun get byte.f32() f32 extern
[pub] fun get byte.f64() f64 extern
[pub] fun get byte.decimal() Decimal extern
[pub] fun byte.str() str extern
[pub] fun get byte.i8Mask() i8 extern

[pub] fun byte.getHash() int extern
[pub] fun _opEq(a byte, b byte) bool extern
[pub] fun _opCmp(a byte, b byte) i32 extern


// i16 (-32768..32768)
[pub] type ro copy i16
    const __size int = 2
    const __align int = 2    
    [pub] const MAX i16 = 32767
    [pub] const MIN i16 = -32768
    [pub] const ZERO i16 = 0
    [pub] const ONE i16 = 1

[pub] fun get i16.i8() ?i8 extern
[pub] fun get i16.byte() ?byte extern
[pub] fun get i16.u16() ?u16 extern
[pub] fun get i16.i32() i32 extern
[pub] fun get i16.int() int extern
[pub] fun get i16.f32() f32 extern
[pub] fun get i16.f64() f64 extern
[pub] fun get i16.decimal() Decimal extern    
[pub] fun i16.str() str extern
[pub] fun get i16.i8Mask() i8 extern
[pub] fun get i16.byteMask() byte extern
[pub] fun get i16.u16Mask() u16 extern    

[pub] fun i16.getHash() int extern
[pub] fun _opEq(a i16, b i16) bool extern
[pub] fun _opCmp(a i16, b i16) i32 extern



// u16 (0..65535)
[pub] type ro copy u16
    const __size int = 2
    const __align int = 2    
    [pub] const MAX u16 = 65535
    [pub] const MIN u16 = 0
    [pub] const ZERO u16 = 0
    [pub] const ONE u16 = 1

[pub] fun get u16.i8() ?i8 extern
[pub] fun get u16.byte() ?byte extern
[pub] fun get u16.i16() ?i16 extern
[pub] fun get u16.i32() i32 extern
[pub] fun get u16.u32() u32 extern
[pub] fun get u16.int() int extern
[pub] fun get u16.u64() u64 extern
[pub] fun get u16.f32() f32 extern
[pub] fun get u16.f64() f64 extern
[pub] fun get u16.decimal() Decimal extern
[pub] fun u16.str() str extern
[pub] fun get u16.i8Mask() i8 extern
[pub] fun get u16.byteMask() byte extern
[pub] fun get u16.i16Mask() i16 extern

[pub] fun u16.getHash() int extern
[pub] fun _opEq(a u16, b u16) bool extern
[pub] fun _opCmp(a u16, b u16) i32 extern

// A 32 bit integer
[pub] type ro copy i32
    const __size int = 4
    const __align int = 4    
    [pub] const MAX i32 = 2147483647
    [pub] const MIN i32 = -2147483648
    [pub] const ZERO i32 = 0
    [pub] const ONE i32 = 1

[pub] fun get i32.i8() ?i8 extern
[pub] fun get i32.byte() ?byte extern
[pub] fun get i32.i16() ?i16 extern
[pub] fun get i32.u16() ?u16 extern
[pub] fun get i32.u32() ?u32 extern
[pub] fun get i32.int() int extern
[pub] fun get i32.f32() f32 extern
[pub] fun get i32.f64() f64 extern
[pub] fun get i32.decimal() Decimal extern    
[pub] fun i32.str() str extern
[pub] fun get i32.i8Mask() i8 extern
[pub] fun get i32.byteMask() byte extern
[pub] fun get i32.i16Mask() i16 extern
[pub] fun get i32.u16Mask() u16 extern
[pub] fun get i32.u32Mask() u32 extern

[pub] fun i32.getHash() int extern
[pub] fun _opEq(a i32, b i32) bool extern
[pub] fun _opCmp(a i32, b i32) i32 extern
[pub] fun _opRange(a i32, b i32) Range<i32> extern // TBD: Generic function on range?
[pub] fun _opAdd(a i32, b i32) i32 extern
[pub] fun _opSub(a i32, b i32) i32 extern
[pub] fun _opNeg(a i32) i32 extern
[pub] fun _opMul(a i32, b i32) i32 extern
[pub] fun _opDiv(a i32, b i32) i32 extern
[pub] fun _opRem(a i32, b i32) i32 extern
[pub] fun _opBitNot(a i32) i32 extern
[pub] fun _opBitAnd(a i32, b i32) i32 extern
[pub] fun _opBitOr(a i32, b i32) i32 extern
[pub] fun _opBitXor(a i32, b i32) i32 extern
[pub] fun _opBitShl(a i32, b int) i32 extern
[pub] fun _opBitShr(a i32, b int) i32 extern

[pub] fun get i32.iterator() RangeIterator<i32>
    return RangeIterator<i32>(0 i32, my)


// 32 bit unsigned integer
[pub] type ro copy u32
    const __size int = 4
    const __align int = 4    
    [pub] const MAX u32 = 4294967295
    [pub] const MIN u32 = 0
    [pub] const ZERO u32 = 0
    [pub] const ONE u32 = 1

[pub] fun get u32.i8() ?i8 extern
[pub] fun get u32.byte() ?byte extern
[pub] fun get u32.i16() ?i16 extern
[pub] fun get u32.u16() ?u16 extern
[pub] fun get u32.i32() ?i32 extern        
[pub] fun get u32.int() int extern
[pub] fun get u32.u64() u64 extern
[pub] fun get u32.f32() f32 extern
[pub] fun get u32.f64() f64 extern
[pub] fun get u32.decimal() Decimal extern        
[pub] fun u32.str() str extern
[pub] fun get u32.i8Mask() i8 extern
[pub] fun get u32.byteMask() byte extern
[pub] fun get u32.i16Mask() i16 extern
[pub] fun get u32.u16Mask() u16 extern
[pub] fun get u32.i32Mask() i32 extern

[pub] fun u32.getHash() int extern
[pub] fun _opEq(a u32, b u32) bool extern
[pub] fun _opCmp(a u32, b u32) i32 extern
[pub] fun _opRange(a u32, b u32) Range<u32> extern // TBD: Generic function on range?
[pub] fun _opAdd(a u32, b u32) u32 extern
[pub] fun _opSub(a u32, b u32) u32 extern
[pub] fun _opNeg(a u32) u32 extern
[pub] fun _opMul(a u32, b u32) u32 extern
[pub] fun _opDiv(a u32, b u32) u32 extern
[pub] fun _opRem(a u32, b u32) u32 extern
[pub] fun _opBitNot(a u32) u32 extern
[pub] fun _opBitAnd(a u32, b u32) u32 extern
[pub] fun _opBitOr(a u32, b u32) u32 extern
[pub] fun _opBitXor(a u32, b u32) u32 extern
[pub] fun _opBitShl(a u32, b int) u32 extern
[pub] fun _opBitShr(a u32, b int) u32 extern

[pub] fun get u32.iterator() RangeIterator<u32>
    return RangeIterator<u32>(0 u32, my)


// A 64 bit integer (same as int)
[pub] type ro copy int
    const __size int = 8
    const __align int = 8    
    [pub] const MAX int = 9223372036854775807
    [pub] const MIN int = -9223372036854775808
    [pub] const ZERO int = 0
    [pub] const ONE int = 1

[pub] fun get int.i8() ?i8 extern
[pub] fun get int.byte() ?byte extern
[pub] fun get int.i16() ?i16 extern
[pub] fun get int.u16() ?u16 extern
[pub] fun get int.i32() ?i32 extern
[pub] fun get int.u32() ?u32 extern
[pub] fun get int.u64() ?u64 extern    
[pub] fun get int.f32() f32 extern
[pub] fun get int.f64() f64 extern
[pub] fun get int.decimal() Decimal extern
[pub] fun int.str() str extern
[pub] fun get int.i8Mask() i8 extern
[pub] fun get int.byteMask() byte extern
[pub] fun get int.i16Mask() i16 extern
[pub] fun get int.u16Mask() u16 extern
[pub] fun get int.i32Mask() i32 extern
[pub] fun get int.u32Mask() u32 extern
[pub] fun get int.u64Mask() u64 extern


[pub] fun int.getHash() int extern
[pub] fun _opEq(a int, b int) bool extern
[pub] fun _opCmp(a int, b int) i32 extern
[pub] fun _opRange(a int, b int) Range<int> extern // TBD: Generic function on range?
[pub] fun _opAdd(a int, b int) int extern
[pub] fun _opSub(a int, b int) int extern
[pub] fun _opNeg(a int) int extern
[pub] fun _opMul(a int, b int) int extern
[pub] fun _opDiv(a int, b int) int extern
[pub] fun _opRem(a int, b int) int extern
[pub] fun _opBitNot(a int) int extern
[pub] fun _opBitAnd(a int, b int) int extern
[pub] fun _opBitOr(a int, b int) int extern
[pub] fun _opBitXor(a int, b int) int extern
[pub] fun _opBitShl(a int, b int) int extern
[pub] fun _opBitShr(a int, b int) int extern


[pub] fun get int.iterator() RangeIterator<int>
    return RangeIterator<int>(0, my)

// 64 bit unsigned integer
[pub] type ro copy u64
    const __size int = 8
    const __align int = 8    
    [pub] const MAX u64 = 18446744073709551615
    [pub] const MIN u64 = 0
    [pub] const ZERO u64 = 0
    [pub] const ONE u64 = 1

[pub] fun get u64.i8() ?i8 extern
[pub] fun get u64.byte() ?byte extern
[pub] fun get u64.i16() ?i16 extern
[pub] fun get u64.u16() ?u16 extern
[pub] fun get u64.i32() ?i32 extern
[pub] fun get u64.u32() ?u32 extern
[pub] fun get u64.int() ?int extern
[pub] fun get u64.f32() f32 extern
[pub] fun get u64.f64() f64 extern
[pub] fun get u64.decimal() Decimal extern
[pub] fun u64.str() str extern
[pub] fun get u64.i8Mask() i8 extern
[pub] fun get u64.byteMask() byte extern
[pub] fun get u64.i16Mask() i16 extern
[pub] fun get u64.u16Mask() u16 extern
[pub] fun get u64.i32Mask() i32 extern
[pub] fun get u64.u32Mask() u32 extern
[pub] fun get u64.intMask() int extern

[pub] fun u64.getHash() int extern
[pub] fun _opEq(a u64, b u64) bool extern
[pub] fun _opCmp(a u64, b u64) i32 extern
[pub] fun _opRange(a u64, b u64) Range<u64> extern // TBD: Generic function on range?
[pub] fun _opAdd(a u64, b u64) u64 extern
[pub] fun _opSub(a u64, b u64) u64 extern
[pub] fun _opNeg(a u64) u64 extern
[pub] fun _opMul(a u64, b u64) u64 extern
[pub] fun _opDiv(a u64, b u64) u64 extern
[pub] fun _opRem(a u64, b u64) u64 extern
[pub] fun _opBitNot(a u64) u64 extern
[pub] fun _opBitAnd(a u64, b u64) u64 extern
[pub] fun _opBitOr(a u64, b u64) u64 extern
[pub] fun _opBitXor(a u64, b u64) u64 extern
[pub] fun _opBitShl(a u64, b int) u64 extern
[pub] fun _opBitShr(a u64, b int) u64 extern
[pub] fun _opBitShr(a u64, b u64) u64 extern
[pub] fun _opBitShl(a u64, b u64) u64 extern



[pub] fun get u64.iterator() RangeIterator<u64>
    return RangeIterator<u64>(0 u64, my)

[pub] type ro copy i128
    const __size int = 16
    const __align int = 16

[pub] type ro copy u128
    const __size int = 16
    const __align int = 16


[pub] type ro copy f32
    const __size int = 4
    const __align int = 4    
    [pub] const MAX f32 = 3.40282347E+38F
    [pub] const MIN f32 = -3.40282347E+38F
    [pub] const ZERO f32 = 0
    [pub] const ONE f32 = 1
    [pub] const EPSILON f32 = 1.401298E-45F
    [pub] const INF f32 = 1F/0F
    [pub] const NEG_INF f32 = -1F/0F
    [pub] const NAN f32 = 0f32/0f32
    [pub] const PI f32 = 3.141592653589793238
    [pub] const E f32 = 2.718281828459045235

[pub] fun get f32.isInfinity() bool extern
[pub] fun get f32.isNan() bool extern
[pub] fun get f32.isNegativeInfinity() bool extern
[pub] fun get f32.isPositiveInfinity() bool extern        

[pub] fun get f32.byte() ?byte extern
[pub] fun get f32.int() ?int extern
[pub] fun get f32.u64() ?u64 extern
[pub] fun get f32.f64() f64 extern
[pub] fun get f32.decimal() Decimal extern    
[pub] fun f32.str() str extern
[pub] fun get f32.byteMask() byte extern
[pub] fun get f32.intMask() int extern
[pub] fun get f32.u64Mask() u64 extern

        
[pub] fun f32.getHash() int extern
[pub] fun _opEq(a f32, b f32) bool extern
[pub] fun _opCmp(a f32, b f32) i32 extern
[pub] fun _opEqNan(a f32, b f32) bool extern
[pub] fun _opCmpNan(a f32, b f32) i32 extern
[pub] fun _opRange(a f32, b f32) Range<i32> extern // TBD: Generic function on range?
[pub] fun _opAdd(a f32, b f32) f32 extern
[pub] fun _opSub(a f32, b f32) f32 extern
[pub] fun _opNeg(a f32) f32 extern
[pub] fun _opMul(a f32, b f32) f32 extern
[pub] fun _opDiv(a f32, b f32) f32 extern
[pub] fun _opRem(a f32, b f32) f32 extern


[pub] type ro copy f64
    const __size int = 8
    const __align int = 8    
    [pub] const MAX f64 = 1.7976931348623157E+308
    [pub] const MIN f64 = -1.7976931348623157E+308
    [pub] const ZERO f64 = 0
    [pub] const ONE f64 = 1
    [pub] const EPSILON f64 = 4.94065645841247E-324
    [pub] const INF f64 = 1.0/0.0
    [pub] const NEG_INF f64 = -1.0/0.0
    [pub] const NAN f64 = 0f64/0f64
    [pub] const PI f64 = 3.141592653589793238
    [pub] const E f64 = 2.718281828459045235

[pub] fun get f64.isInfinity() bool extern
[pub] fun get f64.isNan() bool extern
[pub] fun get f64.isNegativeInfinity() bool extern
[pub] fun get f64.isPositiveInfinity() bool extern        

[pub] fun get f64.byte() ?byte extern
[pub] fun get f64.int() ?int extern
[pub] fun get f64.u64() ?u64 extern
[pub] fun get f64.decimal() Decimal extern
[pub] fun f64.str() str extern
[pub] fun get f64.byteMask() byte extern
[pub] fun get f64.intMask() int extern
[pub] fun get f64.u64Mask() u64 extern
[pub] fun get f64.f32Clamp() f32 extern

[pub] fun f64.getHash() int extern

[pub] fun _opEq(a f64, b f64) bool extern
[pub] fun _opCmp(a f64, b f64) i32 extern
[pub] fun _opEqNan(a f64, b f64) bool extern
[pub] fun _opCmpNan(a f64, b f64) i32 extern
[pub] fun _opRange(a f64, b f64) Range<f64> extern // TBD: Generic function on range?
[pub] fun _opAdd(a f64, b f64) f64 extern
[pub] fun _opSub(a f64, b f64) f64 extern
[pub] fun _opNeg(a f64) f64 extern
[pub] fun _opMul(a f64, b f64) f64 extern
[pub] fun _opDiv(a f64, b f64) f64 extern
[pub] fun _opRem(a f64, b f64) f64 extern


// 128 bit decimal integer.  This will support NAN, infinity, and
// exponents covering the entire range of f64 with more precision.
[pub] type ro copy Decimal
    const __size int = 16
    const __align int = 16
    [pub] const MAX Decimal = 1E+1000M
    [pub] const MIN Decimal = -1E+1000M
    [pub] const ZERO Decimal = 0
    [pub] const ONE Decimal = 1
    [pub] const INF Decimal = 1.0/0.0
    [pub] const NEG_INF Decimal = -1.0/0.0
    [pub] const NAN Decimal = 0.0/0.0
    
[pub] fun get Decimal.isInfinity() bool extern
[pub] fun get Decimal.isNan() bool extern
[pub] fun get Decimal.isNegativeInfinity() bool extern
[pub] fun get Decimal.isPositiveInfinity() bool extern

[pub] fun get Decimal.byte() ?byte extern
[pub] fun get Decimal.int() ?int extern
[pub] fun get Decimal.u64() ?u64 extern
[pub] fun Decimal.str() str extern
[pub] fun get Decimal.byteMask() byte extern
[pub] fun get Decimal.intMask() int extern
[pub] fun get Decimal.u64Mask() u64 extern
[pub] fun get Decimal.intClamp() int extern
[pub] fun get Decimal.f32Clamp() f32 extern
[pub] fun get Decimal.f64Clamp() f64 extern

[pub] fun Decimal.getHash() int extern
[pub] fun _opEq(a Decimal, b Decimal) bool extern
[pub] fun _opCmp(a Decimal, b Decimal) i32 extern
[pub] fun _opEqNan(a Decimal, b Decimal) bool extern
[pub] fun _opCmpNan(a Decimal, b Decimal) i32 extern
[pub] fun _opRange(a Decimal, b Decimal) Range<i32> extern // TBD: Generic function on range?
[pub] fun _opAdd(a Decimal, b Decimal) Decimal extern
[pub] fun _opSub(a Decimal, b Decimal) Decimal extern
[pub] fun _opNeg(a Decimal) Decimal extern
[pub] fun _opMul(a Decimal, b Decimal) Decimal extern
[pub] fun _opDiv(a Decimal, b Decimal) Decimal extern
[pub] fun _opRem(a Decimal, b Decimal) Decimal extern


    