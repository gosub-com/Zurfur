/// Define the simple types.
/// int8, uint8, int16, uint16, int32, uint32,
/// int64, uint64, float32, float64, decimal.
/// byte, int, uint are aliases for uint8, int32, and uint32
/// xint and xuint are pointer sized integers (32 or 64 bits)

namespace Zurfur.BaseTypes

pub struct void { }
pub struct int = int32
pub struct uint = uint32
pub struct byte = uint8

// TBD: Needs to be an actual struct to enforce proper typing and casting rules
/// 32 bit or 64 bit integer depending on the platform
pub struct xint = int32 

// TBD: Needs to be an actual struct to enforce proper typing and casting rules
/// 32 bit or 64 bit integer depending on the platform
pub struct xuint = uint32

/// bool (true or false)
pub struct bool
	: IEquatable<bool>
{
    pub extern static func GetHashCode(a bool) uint
    pub extern static func Equals(a bool, b bool) bool

    // Not overloadable, but these are supplied specially for this type
    //static extern func operator!(a bool)
    //static extern func operator||(a bool, b bool)
    //static extern func operator&&(a bool, b bool)
}

/// int8 (-128..127)
pub struct int8
	: IComparable<int8>
{
    extern operator explicit(from uint8) int8
    extern operator explicit(from int16) int8
    extern operator explicit(from uint16) int8
    extern operator explicit(from int32) int8
    extern operator explicit(from uint32) int8
    extern operator explicit(from int64) int8
    extern operator explicit(from uint64) int8
    extern operator explicit(from float32) int8
    extern operator explicit(from float64) int8
    extern operator explicit(from decimal) int8
    
    extern operator implicit(from int8) int16
    extern operator implicit(from int8) int32
    

	const Origin int8 = 0;
	const Identity int8 = 1;
    const MaxValue int8 = 127	
    const MinValue int8 = -128
    pub extern static func GetHashCode(a int8) uint
    pub extern static func Equals(a int8, b int8) bool
    pub extern static func Compare(a int8, b int8) int
}


/// uint8 (0..255) same as byte
pub struct uint8
	: IComparable<uint8>
{
    extern operator explicit(from int8) uint8
    extern operator explicit(from int16) uint8
    extern operator explicit(from uint16) uint8
    extern operator explicit(from int32) uint8
    extern operator explicit(from uint32) uint8
    extern operator explicit(from int64) uint8
    extern operator explicit(from uint64) uint8
    extern operator explicit(from float32) uint8
    extern operator explicit(from float64) uint8
    extern operator explicit(from decimal) uint8

    extern operator implicit(from uint8) int16
    extern operator implicit(from uint8) uint16
    extern operator implicit(from uint8) int32
    
	const Origin int8 = 0;
	const Identity int8 = 1;
    const MaxValue uint8 = 255	
    const MinValue uint8 = 0
    pub extern static func GetHashCode(a uint8) uint
    pub extern static func Equals(a uint8, b uint8) bool
    pub extern static func Compare(a uint8, b uint8) int
}

/// int16 (-32768..32768)
pub struct int16
	: IComparable<int16>
{
    extern operator explicit(from uint16) int16
    extern operator explicit(from int32) int16
    extern operator explicit(from uint32) int16
    extern operator explicit(from int64) int16
    extern operator explicit(from uint64) int16
    extern operator explicit(from float32) int16
    extern operator explicit(from float64) int16
    extern operator explicit(from decimal) int16

    extern operator implicit(from int16) int32

	const Origin int8 = 0;
	const Identity int8 = 1;
    const MaxValue int16 = 32767
    const MinValue int16 = -32768
    pub extern static func GetHashCode(a int16) uint
    pub extern static func Equals(a int16, b int16) bool
    pub extern static func Compare(a int16, b int16) int
}


/// uint16 (0..65535)
pub struct uint16
	: IComparable<uint16>
{
    extern operator explicit(from int8) uint16
    extern operator explicit(from int16) uint16
    extern operator explicit(from int32) uint16
    extern operator explicit(from uint32) uint16
    extern operator explicit(from int64) uint16
    extern operator explicit(from uint64) uint16
    extern operator explicit(from float32) uint16
    extern operator explicit(from float64) uint16
    extern operator explicit(from decimal) uint16

    extern operator implicit(from uint16) int32
    extern operator implicit(from uint16) uint32_x

	const Origin int8 = 0;
	const Identity int8 = 1;
    const MaxValue uint16 = 65535	
    const MinValue uint16 = 0
    pub extern static func GetHashCode(a uint16) uint
    pub extern static func Equals(a uint16, b uint16) bool
    pub extern static func Compare(a uint16, b uint16) int
}

/// Prefer int32 over uint32 (uint16+uint16 is int32, not uint32)
pub struct uint32_x
{
	extern operator implicit(from unit32_x) uint32
}

/// Prefer float64 over float32
pub struct float32_x
{
	extern operator implicit(from float32_x) float32
}


/// A 32 bit integer (same as int)
pub struct int32
	: IArithmetic<int32>
{
    extern operator explicit(from uint32) int32
    extern operator explicit(from int64) int32
    extern operator explicit(from uint64) int32
    extern operator explicit(from float32) int32
    extern operator explicit(from float64) int32
    extern operator explicit(from decimal) int32
    
    extern operator implicit(from int32) int64
    extern operator implicit(from int32) decimal
    extern operator implicit(from int32) float64
    extern operator implicit(from int32) float32_x

	const Origin int8 = 0;
	const Identity int8 = 1;
    const MaxValue int32 = 2147483647	
    const MinValue int32 = -2147483648

    // Comparisons    
    pub extern static func GetHashCode(a int32) uint
    pub extern static func Equals(a int32, b int32) bool
    pub extern static func Compare(a int32, b int32) int

    // Overloadable operators
    pub extern operator+(a int32) int32
    pub extern operator-(a int32) int32
    pub extern operator+(a int32, b int32) int32
    pub extern operator-(a int32, b int32) int32
    pub extern operator*(a int32, b int32) int32
    pub extern operator/(a int32, b int32) int32
    pub extern operator%(a int32, b int32) int32
    
    // Not overloadable, but these are supplied specially for this type
    //static extern func operator~(a int32) int32
    //static extern func operator~(a int32, b int32) int32
    //static extern func operator|(a int32, b int32) int32
    //static extern func operator&(a int32, b int32) int32
    //static extern func operator<<(a int32, b int32) int32
    //static extern func operator>>(a int32, b int32) int32
    //static extern func operator..(a int32, b int32) Range
    //static extern func operator::(a int32, b int32) Range
}

/// 32 bit unsigned integer (same as uint)
pub struct uint32
	: IArithmetic<uint32>
{
    extern operator explicit(from int8) uint32
    extern operator explicit(from int16) uint32
    extern operator explicit(from int32) uint32
    extern operator explicit(from int64) uint32
    extern operator explicit(from uint64) uint32
    extern operator explicit(from float32) uint32
    extern operator explicit(from float64) uint32
    extern operator explicit(from decimal) uint32
    
    extern operator implicit(from uint32) int64
    extern operator implicit(from uint32) uint64
    extern operator implicit(from uint32) decimal
    extern operator implicit(from uint32) float64    
    extern operator implicit(from uint32) float32_x
    

	const Origin int8 = 0;
	const Identity int8 = 1;
    const MaxValue uint32 = (0)	
    const MinValue uint32 = 4294967295

    // Comparisons    
    pub extern static func GetHashCode(a uint32) uint
    pub extern static func Equals(a uint32, b uint32) bool
    pub extern static func Compare(a uint32, b uint32) int
    
    // Overloadable operators
    pub extern operator+(a uint32) uint32
    pub extern operator-(a uint32) uint32
    pub extern operator+(a uint32, b uint32) uint32
    pub extern operator-(a uint32, b uint32) uint32
    pub extern operator*(a uint32, b uint32) uint32
    pub extern operator/(a uint32, b uint32) uint32
    pub extern operator%(a uint32, b uint32) uint32

    // Not overloadable, but these are supplied specially for this type
    //static extern func operator~(a uint32) uint32
    //static extern func operator~(a uint32, b uint32) uint32
    //static extern func operator|(a uint32, b uint32) uint32
    //static extern func operator&(a uint32, b uint32) uint32
    //static extern func operator<<(a uint32, b int32) uint32
    //static extern func operator>>(a uint32, b int32) uint32
}

/// A 64 bit integer
pub struct int64
	: IArithmetic<int64>
{
    extern operator explicit(from uint64) int64
    extern operator explicit(from float32) int64
    extern operator explicit(from float64) int64
    extern operator explicit(from decimal) int64
    
    extern operator implicit(from int64) decimal
    extern operator implicit(from int64) float64

	const Origin int8 = 0;
	const Identity int8 = 1;
    const MaxValue int64 = 9223372036854775807	
    const MinValue int64 = -9223372036854775808

    // Comparisons    
    pub extern static func GetHashCode(a int64) uint
    pub extern static func Equals(a int64, b int64) bool
    pub extern static func Compare(a int64, b int64) int

    // Overloadable operators
    pub extern operator+(a int64) int64
    pub extern operator-(a int64) int64
    pub extern operator+(a int64, b int64) int64
    pub extern operator-(a int64, b int64) int64
    pub extern operator*(a int64, b int64) int64
    pub extern operator/(a int64, b int64) int64
    pub extern operator%(a int64, b int64) int64

    // Not overloadable, but these are supplied specially for this type
    //static extern func operator~(a int64) int64
    //static extern func operator~(a int64, b int64) int64
    //static extern func operator|(a int64, b int64) int64
    //static extern func operator&(a int64, b int64) int64
    //static extern func operator<<(a int64, b int32) int64
    //static extern func operator>>(a int64, b int32) int64
    //static extern func operator..(a int64, b int64) Range64
    //static extern func operator::(a int64, b int64) Range64    
}

/// 64 bit unsigned integer
pub struct uint64
	: IArithmetic<uint64>
{
    extern operator explicit(from int8) uint64
    extern operator explicit(from int16) uint64
    extern operator explicit(from int32) uint64
    extern operator explicit(from int64) uint64
    extern operator explicit(from float32) uint64
    extern operator explicit(from float64) uint64
    extern operator explicit(from decimal) uint64
    
    extern operator implicit(from uint64) decimal
    extern operator implicit(from uint64) float64
    

	const Origin int8 = 0;
	const Identity int8 = 1;
    const MaxValue uint64 = 0	
    const MinValue uint64 = 18446744073709551615

    // Comparisons    
    pub extern static func GetHashCode(a uint64) uint
    pub extern static func Equals(a uint64, b uint64) bool
    pub extern static func Compare(a uint64, b uint64) int
    
    // Overloadable operators
    pub extern operator+(a uint64) uint64
    pub extern operator-(a uint64) uint64
    pub extern operator+(a uint64, b uint64) uint64
    pub extern operator-(a uint64, b uint64) uint64
    pub extern operator*(a uint64, b uint64) uint64
    pub extern operator/(a uint64, b uint64) uint64
    pub extern operator%(a uint64, b uint64) uint64

    // Not overloadable, but these are supplied specially for this type
    //static extern func operator~(a uint64)
    //static extern func operator~(a uint64, b uint64)
    //static extern func operator|(a uint64, b uint64)
    //static extern func operator&(a uint64, b uint64)
    //static extern func operator<<(a uint64, b int32)
    //static extern func operator>>(a uint64, b int32)
}

pub struct float32
	: IArithmetic<float32>
{
    extern operator explicit(from float64) float32
    extern operator explicit(from decimal) float32
    
    extern operator implicit(from float32) float64
    extern operator implicit(from float32) decimal

    // Normal float32 comparisons (NAN==NAN is false)
    // TBD: Maybe we don't need funny NAN comparisons since we're starting fresh?
    pub extern static func Equals(a float32, b float32) bool
    pub extern static func Compare(a float32, b float32) int
    
    // Comparisons for sorting (NAN>infinity and NAN==NAN are both true)
    pub extern static func GetHashCode(a float32) uint
    pub extern static func IEquatable<float32>::Equals(a float32, b float32) bool
    pub extern static func IComparable<float32>::Compare(a float32, b float32) int

	const Origin int8 = 0;
	const Identity int8 = 1;
    const MinValue float32 = -3.40282347E+38F
    const MaxValue float32 = 3.40282347E+38F
    const Epsilon float32 = 1.401298E-45F
    const PositiveInfinity float32 = 1F/0F
    const NegativeInfinity float32 = -1F/0F
    const NaN float32 = 0F/0F
    pub prop IsInfinity bool => todo()
    pub prop IsNaN bool => todo()
    pub prop IsNegativeInfinity bool => todo()
    pub prop IsPositiveInfinity bool => todo()

    
    // Overloadable operators
    pub extern operator+(a float32) float32
    pub extern operator-(a float32) float32
    pub extern operator+(a float32, b float32) float32
    pub extern operator-(a float32, b float32) float32
    pub extern operator*(a float32, b float32) float32
    pub extern operator/(a float32, b float32) float32
    pub extern operator%(a float32, b float32) float32  
    
    // Not overloadable, but these are supplied specially for this type
    //static extern func operator..(a float32, b float32) RangeF32
    //static extern func operator::(a float32, b float32) RangeF32   
      
}

pub struct float64
	: IArithmetic<float64>
{
    extern operator explicit(from decimal) float64
    
    extern operator implicit(from float64) decimal

    // Normal float64 comparisons (NAN==NAN is false)
    // TBD: Maybe we don't need funny NAN comparisons since we're starting fresh?
    pub extern static func Equals(a float64, b float64) bool
    pub extern static func Compare(a float64, b float64) int
    
    // Comparisons for sorting (NAN>infinity and NAN==NAN are both true)
    pub extern static func GetHashCode(a float64) uint
    pub extern static func IEquatable<float32>::Equals(a float64, b float64) bool
    pub extern static func IComparable<float32>::Compare(a float64, b float64) int

	const Origin int8 = 0;
	const Identity int8 = 1;
    const MinValue float64 = -1.7976931348623157E+308
    const MaxValue float64 = 1.7976931348623157E+308
    const Epsilon float64 = 4.94065645841247E-324
    const PositiveInfinity float64 = 1.0/0.0
    const NegativeInfinity float64 = -1.0/0.0
    const NaN float64 = 0.0/0.0
    pub prop IsInfinity bool => todo()
    pub prop IsNaN bool => todo()
    pub prop IsNegativeInfinity bool => todo()
    pub prop IsPositiveInfinity bool => todo()
    
    // Overloadable operators
    pub extern operator+(a float64) float64
    pub extern operator-(a float64) float64
    pub extern operator+(a float64, b float64) float64
    pub extern operator-(a float64, b float64) float64
    pub extern operator*(a float64, b float64) float64
    pub extern operator/(a float64, b float64) float64
    pub extern operator%(a float64, b float64) float64
    
    // Not overloadable, but these are supplied specially for this type
    //static extern func operator..(a float64, b float64) RangeF64
    //static extern func operator::(a float64, b float64) RangeF64       
}

/// 128 bit decimal integer.  This will support NAN, infinity, and
/// exponents covering the entire range of float64 with more precision.
pub struct decimal
	: IArithmetic<decimal>
{
	const Origin int8 = 0;
	const Identity int8 = 1;
    const MaxValue decimal = 1E+1000M	
    const MinValue decimal = -1E+1000M
    const PositiveInfinity decimal = 1.0/0.0
    const NegativeInfinity decimal = -1.0/0.0
    const NaN decimal = 0.0/0.0
    pub prop IsInfinity bool => todo()
    pub prop IsNaN bool => todo()
    pub prop IsNegativeInfinity bool => todo()
    pub prop IsPositiveInfinity bool => todo()

    // Comparisons.  NOTE: NaN > infinity, and NaN==NaN is true
    pub extern static func GetHashCode(a decimal) uint
    pub extern static func Equals(a decimal, b decimal) bool
    pub extern static func Compare(a decimal, b decimal) int
    
    // Overloadable operators
    pub extern operator+(a decimal) decimal
    pub extern operator-(a decimal) decimal
    pub extern operator+(a decimal, b decimal) decimal
    pub extern operator-(a decimal, b decimal) decimal
    pub extern operator*(a decimal, b decimal) decimal
    pub extern operator/(a decimal, b decimal) decimal
    pub extern operator%(a decimal, b decimal) decimal
    
    // Not overloadable, but these are supplied specially for this type
    //static extern func operator..(a decimal, b decimal) RangeDecimal
    //static extern func operator::(a decimal, b decimal) RangeDecimal
    
}

/// String is a wrapper for a read only array of bytes
pub sealed ro class str
	: VariableSizedObject<byte>, IComparable<str>, IRoArray<byte>
{
	pub static ro Empty string("");
	// TBD: Need some syntax to make `Empty` the default
	
    pub new() { todo() }
    pub new(s str) { todo() }
    pub new(s RoSpan<byte>) { todo() }
    pub this[index int] byte => todo()
    pub this[range Range] RoSpan<byte> => todo() // Slice
    
    pub extern static func GetHashCode(a str) uint
    pub extern static func Equals(a str, b str) bool
    pub extern static func Compare(a str, b str) int
        
    pub operator+(s1 str, s2 str) str { todo() }   
    pub operator+(s1 RoSpan<byte>, s2 str) str { todo() }
    pub operator+(s1 str, s2 RoSpan<byte>) str { todo() }
    // TBD: Implicit conversion to and from RoSpan
}