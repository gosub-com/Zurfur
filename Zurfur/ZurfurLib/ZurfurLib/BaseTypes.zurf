/// Define the simple types.
/// i8, u8, i16, u16, i32, u32,
/// i64, u64, f32, f64, decimal.
/// byte, int, uint are aliases for u8, i32, and u32
/// xint and xuint are pointer sized integers (32 or 64 bits)

namespace Zurfur

pub struct void { }
pub struct int = i32
pub struct uint = u32
pub struct byte = u8

// TBD: Needs to be an actual struct to enforce proper typing and casting rules
/// 32 bit or 64 bit integer depending on the platform
pub struct xint = i32 

// TBD: Needs to be an actual struct to enforce proper typing and casting rules
/// 32 bit or 64 bit integer depending on the platform
pub struct xuint = u32

/// bool (true or false)
pub struct bool
    : IEquatable<bool>
{
    pub new (from bool) => extern
    pub static func GetHashCode(a bool) uint => extern
    pub static func Equals(a bool, b bool) bool => extern

    // Not overloadable, but these are supplied specially for this type
    //static func operator!(a bool)
    //static func operator||(a bool, b bool)
    //static func operator&&(a bool, b bool)
}

/// i8 (-128..127)
pub struct i8
    : IComparable<i8>
{
    pub new (from i8) => extern

    operator explicit(from u8) i8 => extern
    operator explicit(from i16) i8 => extern
    operator explicit(from u16) i8 => extern
    operator explicit(from i32) i8 => extern
    operator explicit(from u32) i8 => extern
    operator explicit(from i64) i8 => extern
    operator explicit(from u64) i8 => extern
    operator explicit(from f32) i8 => extern
    operator explicit(from f64) i8 => extern
    operator explicit(from decimal) i8 => extern
    
    operator implicit(from i8) i16 => extern
    operator implicit(from i8) i32 => extern
    operator implicit(from i8) i64 => extern
    operator implicit(from i8) f32 => extern
    operator implicit(from i8) f64 => extern
    operator implicit(from i8) decimal => extern
    

    const Origin i8 = 0;
    const Identity i8 = 1;
    const MaxValue i8 = 127
    const MinValue i8 = -128
    pub static func GetHashCode(a i8) uint => extern
    pub static func Equals(a i8, b i8) bool => extern
    pub static func Compare(a i8, b i8) int => extern
}


/// u8 (0..255) same as byte
pub struct u8
    : IComparable<u8>
{
    pub new (from u8) => extern
    
    operator explicit(from i8) u8 => extern
    operator explicit(from i16) u8 => extern
    operator explicit(from u16) u8 => extern
    operator explicit(from i32) u8 => extern
    operator explicit(from u32) u8 => extern
    operator explicit(from i64) u8 => extern
    operator explicit(from u64) u8 => extern
    operator explicit(from f32) u8 => extern
    operator explicit(from f64) u8 => extern
    operator explicit(from decimal) u8 => extern

    operator implicit(from u8) i16 => extern
    operator implicit(from u8) u16 => extern
    operator implicit(from u8) i32 => extern
    operator implicit(from u8) u32 => extern
    operator implicit(from u8) i64=> extern
    operator implicit(from u8) u64 => extern
    operator implicit(from u8) f32 => extern
    operator implicit(from u8) f64 => extern
    operator implicit(from u8) decimal => extern
    
    const Origin i8 = 0;
    const Identity i8 = 1;
    const MaxValue u8 = 255
    const MinValue u8 = 0
    pub static func GetHashCode(a u8) uint => extern
    pub static func Equals(a u8, b u8) bool => extern
    pub static func Compare(a u8, b u8) int => extern
}

/// i16 (-32768..32768)
pub struct i16
    : IComparable<i16>
{
    pub new (from i16) => extern

    operator explicit(from u16) i16 => extern
    operator explicit(from i32) i16 => extern
    operator explicit(from u32) i16 => extern
    operator explicit(from i64) i16 => extern
    operator explicit(from u64) i16 => extern
    operator explicit(from f32) i16 => extern
    operator explicit(from f64) i16 => extern
    operator explicit(from decimal) i16 => extern

    operator implicit(from i16) i32 => extern
    operator implicit(from i16) i64 => extern
    operator implicit(from i16) f32 => extern
    operator implicit(from i16) f64 => extern
    operator implicit(from i16) decimal => extern

    const Origin i8 = 0;
    const Identity i8 = 1;
    const MaxValue i16 = 32767
    const MinValue i16 = -32768
    pub static func GetHashCode(a i16) uint => extern
    pub static func Equals(a i16, b i16) bool => extern
    pub static func Compare(a i16, b i16) int => extern
}


/// u16 (0..65535)
pub struct u16
    : IComparable<u16>
{
    pub new (from u16) => extern

    operator explicit(from i8) u16 => extern
    operator explicit(from i16) u16 => extern
    operator explicit(from i32) u16 => extern
    operator explicit(from u32) u16 => extern
    operator explicit(from i64) u16 => extern
    operator explicit(from u64) u16 => extern
    operator explicit(from f32) u16 => extern
    operator explicit(from f64) u16 => extern
    operator explicit(from decimal) u16 => extern

    operator implicit(from u16) i32 => extern
    operator implicit(from u16) u32 => extern
    operator implicit(from u16) i64 => extern
    operator implicit(from u16) u64 => extern
    operator implicit(from u16) f32 => extern
    operator implicit(from u16) f64 => extern
    operator implicit(from u16) decimal => extern

    const Origin i8 = 0;
    const Identity i8 = 1;
    const MaxValue u16 = 65535
    const MinValue u16 = 0
    pub static func GetHashCode(a u16) uint => extern
    pub static func Equals(a u16, b u16) bool => extern
    pub static func Compare(a u16, b u16) int => extern
}

/// A 32 bit integer (same as int)
pub struct i32
    : IArithmetic<i32>
{
    pub new (from i32) => extern

    operator explicit(from u32) i32 => extern
    operator explicit(from i64) i32 => extern
    operator explicit(from u64) i32 => extern
    operator explicit(from f32) i32 => extern
    operator explicit(from f64) i32 => extern
    operator explicit(from decimal) i32 => extern
    
    operator implicit(from i32) i64 => extern
    operator implicit(from i32) f32 => extern
    operator implicit(from i32) f64 => extern
    operator implicit(from i32) decimal => extern


    const Origin i8 = 0;
    const Identity i8 = 1;
    const MaxValue i32 = 2147483647
    const MinValue i32 = -2147483648

    // Comparisons    
    pub static func GetHashCode(a i32) uint => extern
    pub static func Equals(a i32, b i32) bool => extern
    pub static func Compare(a i32, b i32) int => extern

    // Overloadable operators
    pub operator+(a i32) i32 => extern
    pub operator-(a i32) i32 => extern
    pub operator+(a i32, b i32) i32 => extern
    pub operator-(a i32, b i32) i32 => extern
    pub operator*(a i32, b i32) i32 => extern
    pub operator/(a i32, b i32) i32 => extern
    pub operator%(a i32, b i32) i32 => extern
    
    // Not overloadable, but these are supplied specially for this type
    //static func operator~(a i32) i32
    //static func operator~(a i32, b i32) i32
    //static func operator|(a i32, b i32) i32
    //static func operator&(a i32, b i32) i32
    //static func operator<<(a i32, b i32) i32
    //static func operator>>(a i32, b i32) i32
    //static func operator..(a i32, b i32) Range
    //static func operator::(a i32, b i32) Range
}

/// 32 bit unsigned integer (same as uint)
pub struct u32
    : IArithmetic<u32>
{
    pub new (from u32) => extern

    operator explicit(from i8) u32 => extern
    operator explicit(from i16) u32 => extern
    operator explicit(from i32) u32 => extern
    operator explicit(from i64) u32 => extern
    operator explicit(from u64) u32 => extern
    operator explicit(from f32) u32 => extern
    operator explicit(from f64) u32 => extern
    operator explicit(from decimal) u32 => extern
    
    operator implicit(from u32) i64 => extern
    operator implicit(from u32) u64 => extern
    operator implicit(from u32) decimal => extern
    operator implicit(from u32) f32 => extern
    operator implicit(from u32) f64 => extern
    

    const Origin i8 = 0;
    const Identity i8 = 1;
    const MaxValue u32 = 4294967295
    const MinValue u32 = 0

    // Comparisons    
    pub static func GetHashCode(a u32) uint => extern
    pub static func Equals(a u32, b u32) bool => extern
    pub static func Compare(a u32, b u32) int => extern
    
    // Overloadable operators
    pub operator+(a u32) u32 => extern
    pub operator-(a u32) u32 => extern
    pub operator+(a u32, b u32) u32 => extern
    pub operator-(a u32, b u32) u32 => extern
    pub operator*(a u32, b u32) u32 => extern
    pub operator/(a u32, b u32) u32 => extern
    pub operator%(a u32, b u32) u32 => extern

    // Not overloadable, but these are supplied specially for this type
    //static func operator~(a u32) u32
    //static func operator~(a u32, b u32) u32
    //static func operator|(a u32, b u32) u32
    //static func operator&(a u32, b u32) u32
    //static func operator<<(a u32, b i32) u32
    //static func operator>>(a u32, b i32) u32
}

/// A 64 bit integer
pub struct i64
    : IArithmetic<i64>
{
    pub new (from i64) => extern

    operator explicit(from u64) i64 => extern
    operator explicit(from f32) i64 => extern
    operator explicit(from f64) i64 => extern
    operator explicit(from decimal) i64 => extern
    
    operator implicit(from i64) decimal => extern
    operator implicit(from i64) f64 => extern

    const Origin i8 = 0;
    const Identity i8 = 1;
    const MaxValue i64 = 9223372036854775807
    const MinValue i64 = -9223372036854775808

    // Comparisons    
    pub static func GetHashCode(a i64) uint => extern
    pub static func Equals(a i64, b i64) bool => extern
    pub static func Compare(a i64, b i64) int => extern

    // Overloadable operators
    pub operator+(a i64) i64 => extern
    pub operator-(a i64) i64 => extern
    pub operator+(a i64, b i64) i64 => extern
    pub operator-(a i64, b i64) i64 => extern
    pub operator*(a i64, b i64) i64 => extern
    pub operator/(a i64, b i64) i64 => extern
    pub operator%(a i64, b i64) i64 => extern

    // Not overloadable, but these are supplied specially for this type
    //static func operator~(a i64) i64
    //static func operator~(a i64, b i64) i64
    //static func operator|(a i64, b i64) i64
    //static func operator&(a i64, b i64) i64
    //static func operator<<(a i64, b i32) i64
    //static func operator>>(a i64, b i32) i64
    //static func operator..(a i64, b i64) Range64
    //static func operator::(a i64, b i64) Range64    
}

/// 64 bit unsigned integer
pub struct u64
    : IArithmetic<u64>
{
    pub new (from u64) => extern

    operator explicit(from i8) u64 => extern
    operator explicit(from i16) u64 => extern
    operator explicit(from i32) u64 => extern
    operator explicit(from i64) u64 => extern
    operator explicit(from f32) u64 => extern
    operator explicit(from f64) u64 => extern
    operator explicit(from decimal) u64 => extern
    
    operator implicit(from u64) decimal => extern
    operator implicit(from u64) f64 => extern
    

    const Origin i8 = 0;
    const Identity i8 = 1;
    const MaxValue u64 = 18446744073709551615
    const MinValue u64 = 0

    // Comparisons    
    pub static func GetHashCode(a u64) uint => extern
    pub static func Equals(a u64, b u64) bool => extern
    pub static func Compare(a u64, b u64) int => extern
    
    // Overloadable operators
    pub operator+(a u64) u64 => extern
    pub operator-(a u64) u64 => extern
    pub operator+(a u64, b u64) u64 => extern
    pub operator-(a u64, b u64) u64 => extern
    pub operator*(a u64, b u64) u64 => extern
    pub operator/(a u64, b u64) u64 => extern
    pub operator%(a u64, b u64) u64 => extern

    // Not overloadable, but these are supplied specially for this type
    //static func operator~(a u64)
    //static func operator~(a u64, b u64)
    //static func operator|(a u64, b u64)
    //static func operator&(a u64, b u64)
    //static func operator<<(a u64, b i32)
    //static func operator>>(a u64, b i32)
}

pub struct f32
    : IArithmetic<f32>
{
    pub new (from f32) => extern

    operator explicit(from f64) f32 => extern
    operator explicit(from decimal) f32 => extern
    
    operator implicit(from f32) f64 => extern
    operator implicit(from f32) decimal => extern

    // Normal f32 comparisons (NAN==NAN is false)
    // TBD: Maybe we don't need funny NAN comparisons since we're starting fresh?
    pub static func Equals(a f32, b f32) bool => extern
    pub static func Compare(a f32, b f32) int => extern
    
    // Comparisons for sorting (NAN>infinity and NAN==NAN are both true)
    pub static func GetHashCode(a f32) uint => extern
    pub static func IEquatable<f32>::Equals(a f32, b f32) bool => extern
    pub static func IComparable<f32>::Compare(a f32, b f32) int => extern

    const Origin i8 = 0;
    const Identity i8 = 1;
    const MaxValue f32 = 3.40282347E+38F
    const MinValue f32 = -3.40282347E+38F
    const Epsilon f32 = 1.401298E-45F
    const PositiveInfinity f32 = 1F/0F
    const NegativeInfinity f32 = -1F/0F
    const NaN f32 = 0F/0F
    pub prop IsInfinity bool => todo()
    pub prop IsNaN bool => todo()
    pub prop IsNegativeInfinity bool => todo()
    pub prop IsPositiveInfinity bool => todo()

    
    // Overloadable operators
    pub operator+(a f32) f32 => extern
    pub operator-(a f32) f32 => extern
    pub operator+(a f32, b f32) f32 => extern
    pub operator-(a f32, b f32) f32 => extern
    pub operator*(a f32, b f32) f32 => extern
    pub operator/(a f32, b f32) f32 => extern
    pub operator%(a f32, b f32) f32 => extern
    
    // Not overloadable, but these are supplied specially for this type
    //static func operator..(a f32, b f32) RangeF32
    //static func operator::(a f32, b f32) RangeF32   
      
}

pub struct f64
    : IArithmetic<f64>
{
    pub new (from f64) => extern

    operator explicit(from decimal) f64 => extern
    
    operator implicit(from f64) decimal => extern

    // Normal f64 comparisons (NAN==NAN is false)
    // TBD: Maybe we don't need funny NAN comparisons since we're starting fresh?
    pub static func Equals(a f64, b f64) bool => extern
    pub static func Compare(a f64, b f64) int => extern
    
    // Comparisons for sorting (NAN>infinity and NAN==NAN are both true)
    pub static func GetHashCode(a f64) uint => extern
    pub static func IEquatable<f32>::Equals(a f64, b f64) bool => extern
    pub static func IComparable<f32>::Compare(a f64, b f64) int => extern

    const Origin i8 = 0;
    const Identity i8 = 1;
    const MaxValue f64 = 1.7976931348623157E+308
    const MinValue f64 = -1.7976931348623157E+308
    const Epsilon f64 = 4.94065645841247E-324
    const PositiveInfinity f64 = 1.0/0.0
    const NegativeInfinity f64 = -1.0/0.0
    const NaN f64 = 0.0/0.0
    pub prop IsInfinity bool => todo()
    pub prop IsNaN bool => todo()
    pub prop IsNegativeInfinity bool => todo()
    pub prop IsPositiveInfinity bool => todo()
    
    // Overloadable operators
    pub operator+(a f64) f64 => extern
    pub operator-(a f64) f64 => extern
    pub operator+(a f64, b f64) f64 => extern
    pub operator-(a f64, b f64) f64 => extern
    pub operator*(a f64, b f64) f64 => extern
    pub operator/(a f64, b f64) f64 => extern
    pub operator%(a f64, b f64) f64 => extern
    
    // Not overloadable, but these are supplied specially for this type
    //static func operator..(a f64, b f64) RangeF64
    //static func operator::(a f64, b f64) RangeF64       
}

/// 128 bit decimal integer.  This will support NAN, infinity, and
/// exponents covering the entire range of f64 with more precision.
pub struct decimal
    : IArithmetic<decimal>
{
    pub new (from decimal) => extern

    const Origin i8 = 0;
    const Identity i8 = 1;
    const MaxValue decimal = 1E+1000M
    const MinValue decimal = -1E+1000M
    const PositiveInfinity decimal = 1.0/0.0
    const NegativeInfinity decimal = -1.0/0.0
    const NaN decimal = 0.0/0.0
    pub prop IsInfinity bool => todo()
    pub prop IsNaN bool => todo()
    pub prop IsNegativeInfinity bool => todo()
    pub prop IsPositiveInfinity bool => todo()

    // Comparisons.  NOTE: NaN > infinity, and NaN==NaN is true
    pub static func GetHashCode(a decimal) uint => extern
    pub static func Equals(a decimal, b decimal) bool => extern
    pub static func Compare(a decimal, b decimal) int => extern
    
    // Overloadable operators
    pub operator+(a decimal) decimal => extern
    pub operator-(a decimal) decimal => extern
    pub operator+(a decimal, b decimal) decimal => extern
    pub operator-(a decimal, b decimal) decimal => extern
    pub operator*(a decimal, b decimal) decimal => extern
    pub operator/(a decimal, b decimal) decimal => extern
    pub operator%(a decimal, b decimal) decimal => extern
    
    // Not overloadable, but these are supplied specially for this type
    //static func operator..(a decimal, b decimal) RangeDecimal
    //static func operator::(a decimal, b decimal) RangeDecimal
    
}