using a.b.c;
using system.gosub.p;

namespace zurfur.example;


// Test class
class Example 
{ 
	static func main(args array<string>)
	{
	}
}

/// Implement IHashable on any object that can be stored in a Map.
/// This is different than implementing just Equals
/// in that NAN must compare to itself as true.
interface IHashable<in T>
{
	static func GetHashCode(a T) uint;
	static func Equals(a T, b T) bool;
}

/// Implement ISortable on any object that can be sorted.
/// This is different than implementing just Compare
/// in that NAN must have a valid sort order.
interface ISortable<in T>
{
	static func Compare(a T, b T) int;
}



pub ro struct string
{
	pub static ro Empty = new Array<byte>[0];
    ro str = Array<byte>;

    pub func new(s string) { todo() }
    pub func new(s Span<byte>) { todo() }
    pub func Slice(start int, length int) RoSpan<byte> { todo() }
    pub func Slice(start int) RoSpan<byte> { todo() }
    
    pub static extern func operator+(s1 string, s2 string);    
    pub static extern func operator+(s1 RoSpan<byte>, s2 string);    
    pub static extern func operator+(s1 string, s2 RoSpan<byte>);
    // TBD: Implicit conversion to and from RoSpan
}

pub ro ref struct Span<T>
{
    pub ro Data  = *T;
    pub ro Length = int;
    pub func get[index int] ref T { todo(); }
    pub func Slice(start int, length int) Span<T> { todo(); }
    // TBD: implicit conversion to RoSpan
}

// TBD: Do we wanto to have "struct ro Span" so we don't need another definition for RoSpan?
pub ro ref struct RoSpan<T>
{
    pub ro Data  = *T;
    pub ro Length = int;
    pub func get[index int] ro ref T { todo(); }
    pub func Slice(start int, length int) RoSpan<T> { todo(); }
}

// All variable sized objects must inherit from this class, must be sealed, and
// must call AllocateObject first thing in the constructor.  For efficiency,
// this class is unsafe and doesn't do any bounds checking.
// The inheriting class must be sealed (that's what sealed1 means)
pub sealed1 unsafe class  VariableSizedObject<T>
{
    pub ro Length = int;

    // Must be called first thing from the constuctor, never called again
    protected unsafe static func AllocateObject(int length) { todo() }

    // Return a pointer to the array
    // { return (T*)((iptr)this + sizeof(this))}
    protected unsafe func get DataPointer() *T {todo()}
}


// Array of constant size
pub sealed class Array<T> : VariableSizedObject<T>
{
    pub static ro MaxSize = int(int.MaxInt/2);
    pub static ro Empty = new T[0];

    pub func new[length int] { todo }
    pub func get[index int] ref T { todo }
    pub func Slice(start int, length int) Span<T> { todo }
    pub func RoSlice(start int, length int) Span<T> { todo }
}

// Note that the list class has a ref return indexer, just like Array
pub sealed class List<T> : VariableSizedObject<T>
{
	pub func new(capacity int) { todo() }
	pub func get[index int] ref T { todo() }
}

pub sealed class Map<TKey, TValue>
{
	pub func new(capacity int) { todo() }
}

// The matrix class is used to implement square 2d arrays
pub sealed class Matrix2d<t> : VariableSizedObject<T>
{
	pub func new[len1 int, len2 int] { todo() }	
    pub func get[i1 int, i2 int] ref T { todo() }
}

interface IGeneric<Q>
{
    func A<T>(Q m) int;
}

class MyGeneric<QQ> : IGeneric<QQ>
{
    func IGeneric<QQ>.A<T>(QQ a) int { }
}


/// Compiler implemented interface created for all structs that are blittable.
/// A blittable struct does not contain references, but may contain pointers.
interface IBlittableStruct { }

// Represents a buffer in un-managed memory.  This class can create and 
// own the memory, or it can be attached to an already existing buffer.
// The GC knows this class and deletes the memory when necessary.
// TBD: Should this whole class be unsafe?
sealed class UnmanagedMemory<T> : UnmanagedHande where T : IBlittableStruct
{
    Memory =ipointer;
    Length = int;
    Allocscheme = AllocationScheme;

    enum AllocationScheme
    {
        GcOwned = 0;
        UnmanagedMemory = 1;
    }

    // Create the buffer, the GC owns it and deletes it when there are no more
    // references to this object.  Be careful that unmanaged code doesn't
    // hold a reference to the memory beyond the lifetime of this object
    pub func new[lenght int] { todo }

    // Attach this object to a buffer allocated by unmanaged code.  Be sure that
    // unmanaged code doesn't delete the object while still in use.
    unsafe pub func new(length int, data ipointer, sizeofbufferinbytes int) { todo() }

    pub func CopyTo() { todo() }

    // I have mixed feelings about Dispose.  On the one hand, shouldn't the
    // GC just deal with all memory objects?  It's good enough for `new
    // int[1000]`.  OTOH, it feels good to allow the user to free up the
    // unused memory.  TBD: Do not implement this for now since we have
    // escape analysis and `owned` to deal with the easy cases.
    // pub func Dispose() { throw new NeverImplemet(); }
}


// An iptr is a pointer that allows arithmetic operations unsing
// integers.  It is 32 bits or 64 bits depending on the implemnetation.
// Currently, WebAssembly has only 1 implementation which is 32 bits.
pub unsafe struct iptr
{
}

// Pointers are not tracked by the GC.  If you have a pointer to an
// object, make sure you also have a managed reference that lives
// as long as the object. 
pub unsafe struct pointer<T> where T : struct
{
    pub Pointer = ipointer;
}

// This is the base for all objects, struct and class alike.
pub class object
{
    pub virtual func GetType() { todo }
    pub virtual func ToString() { todo }
}

// This is the base for all struct objects.
pub class StructObject
{
}

// This is the base for all class objects.  Its only field is
// the vtable pointer, so there is minimal overhead.  All class
// objects are allocated on the managed heap and are subject
// to garbage collection.
pub class ClassObject
{
    // The only member
    protected unsafe ro VT = iptr;

    pub override func GetType() { todo }
}


// Base class for all things that need to notify when they are garbage collected
class FinalizedNotify 
{
    protected func SetFinalizeNotifier(notifierQueue FinalizedNotifyQueue, token IntPtr, memoryPressure int) { todo() }
    protected func ClearFinalizeNotifier() { todo() }
}
class FinalizedNotifyQueue 
{
    func get Count() int { todo() }
    func Dequeue() IntPtr { todo() }
    async func WaitQueueNotEmpty() { todo() }
}

static func memcpy(to IntPtr, from IntPtr, length int)
{
    if length <= 0
    {
        return;
    }

    // Align `to` on int32
    while to & 3 != 0 && length != 0
   	{
   		*(*byte)to = *(*byte)from; to+=1; from+=1; length-=1;
   	}
   	
    if (to|from) & 3 == 0
    {
        memcpya32(to, from, length);
        return;
    }
    
    // Byte copy
    #end = to + length;
    while end-to >= 4
    {
        *(*byte)to = *(*byte)from; to+=1; from+=1;
        *(*byte)to = *(*byte)from; to+=1; from+=1;
        *(*byte)to = *(*byte)from; to+=1; from+=1;
        *(*byte)to = *(*byte)from; to+=1; from+=1;
    } 
    while to != end
    {
    	*(*byte)to = *(*byte)from; to+=1; from+=1;
    }
}

static func memcpya32(to IntPtr, from IntPtr, length int)
{
    if length <= 0
    {
        return
    }
    if (to|from) & 3 != 0
    {
        throw new MisalignedMemoryAccessException();
    }

    // Try 64 bit copy first
    #end = to + length;
    if (to^from) & 7 == 0 && length >= 8
    {
        if to & 7 != 0
        {
            *(*int32)to = *(*int32)from; to+=4; from+=4;
        }
        while end - to >= 32
        {
            *(*int64)to = *(*int64)from; to+=8; from+=8;
            *(*int64)to = *(*int64)from; to+=8; from+=8;
            *(*int64)to = *(*int64)from; to+=8; from+=8;
            *(*int64)to = *(*int64)from; to+=8; from+=8;
        }
        while end - to >= 8
        {
            *(*int64)to = *(*int64)from; to+=8; from+=8;
        }
    }
    while end-to >= 16
    {
        *(*int32)to = *(*int32)from; to+=4; from+=4;
        *(*int32)to = *(*int32)from; to+=4; from+=4;
        *(*int32)to = *(*int32)from; to+=4; from+=4;
        *(*int32)to = *(*int32)from; to+=4; from+=4;
    }
    while end-to >= 4
    {
        *(*int32)to = *(*int32)from; to+=4; from+=4;
    }
    while to != end
    {
        *(*byte)to = *(*byte)from; to+=1; from+=1;
    }
}

 
