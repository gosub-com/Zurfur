
// This defines traits for:
//      Zurfur.Markers
//      Zurfur.Operators
//      Zurfur.Collections

module Zurfur

module Zurfur.Markers

trait pub Copy { }

module Zurfur.Operators

trait pub OpEq<Rhs> { fun opEq(rhs Rhs) bool impl }
trait pub OpCmp<Rhs> { fun opCmp(rhs Rhs) int impl }
trait pub OpIn<Rhs> { type Output impl; fun opIn(rhs Rhs) Output impl }
trait pub OpAdd<Rhs> { type Output impl; fun opAdd(rhs Rhs) Output impl }
trait pub OpSub<Rhs> { type Output impl; fun opSub(rhs Rhs) Output impl }
trait pub OpNeg { type Output impl; fun opNeg() Output impl }
trait pub OpMul<Rhs> { type Output impl; fun opMul(rhs Rhs) Output impl }
trait pub OpDiv<Rhs> { type Output impl; fun opDiv(rhs Rhs) Output impl }
trait pub OpRem<Rhs> { type Output impl; fun opRem(rhs Rhs) Output impl }
trait pub Drop { fun mut drop(flags int) impl }
trait pub Clone
{
    fun mut clone() impl // TBD: Need ThisType type
}

module Zurfur.Collections

trait pub Iterator
{
    type Item impl
    fun mut next() ?ref Item impl
}

module Zurfur
/// Implement IEquatable on any object that can be stored in a Map.
/// This is different than implementing just Equals
/// in that NAN must compare to itself as true.
trait pub static Equatable<T>
{
    fun static GetHashCode(a T) uint impl
    fun static Equals(a T, b T) bool impl
}

/// Implement IComparable on any object that can be sorted.
/// This is different than implementing just Compare
/// in that NAN must have a valid sort order.
trait pub static Comparable<T>
    implements Equatable<T>
{
    fun static Compare(a T, b T) int impl
}

trait pub static IArithmetic<T>
    implements Comparable<T>
{
    fun operator-(a T) T impl
    fun operator-(a T, b T) T impl
    fun operator+(a T, b T) T impl
    fun operator*(a T, b T) T impl
    fun operator/(a T, b T) T impl
    fun operator%(a T, b T) T impl
    get static Identity() T impl
    get static Origin() T impl
}



trait pub Iterator<T>
{
    /// Get the next item from a collection.
    /// Returns null if there are no more items.
    /// Panic if collection is mutated while iterating.
    fun mut Next() ?ref T impl
}

trait pub Iterable<T>
{
    fun GetIterator() Iterator<T> impl
}


trait pub Collection<T>
    implements Iterable<T>
{
    get Count() int impl
    fun GetIterator() Iterator<T> impl
}


trait pub IArray<T>
    implements Collection<T>
{
    get operator[](index int) T impl
}

trait pub IList<T>
    implements Collection<T>
{
    get operator[](index int) T impl
    set operator[](index int, item own T) impl
}


type pub Pair<TKey, TValue>(Key TKey, Value TValue)


/// This is a test
trait pub IGeneric<Q>
{
    fun A<T>(m Q) int:
        return 0
}


/// Compiler implemented trait created for all structs that are blittable.
/// A blittable struct does not contain references, but may contain pointers.
trait pub IBlittableStruct { }