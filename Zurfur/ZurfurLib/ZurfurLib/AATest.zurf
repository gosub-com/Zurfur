// Misc compiler testing
pragma ShowParse
use Zurfur

module AATest

  
trait pub AAOpIn<Rhs> { type Output impl; fun AAopIn(rhs Rhs) Output impl }

impl AAOpInx<i32> for i32
{
    type Output = i32
    fun pub AAopIn(rhs i32) i32 extern
}

fun pub List<T>::Reverse<T>():
    for @i in 0..this.Count/2:
        Swap(ref this[i], ref this[Count-i-1])

fun pub static List<T>::Reverse2<T>():
    for @i in 0..this.Count/2:
        Swap(ref this[i], ref this[Count-i-1])


type pub MyList<T>
{
    fun pub Reverse() {}
    fun pub static ReverseS() {}
}

fun pub int::aaa(){}
type pub AAFun
{

    fun aaaa(a int, b int) int { }
    fun aaaa(a int, b f64) int { }
    fun aaaa(x f64, y int) int { }

    fun aaf1(a int, b int)int { }
    fun aaf2(v AAFunc<int, int>) { }
    fun aaf3<T1,T2>(i T1)T2 { }
    fun static aaf1s(a int, b int)int { }
    fun static aaf2s(v AAFunc<int, int>) { }
    fun static aaf3s<T1,T2>(i T1)T2 { }
    
    @aaf4 fun(a int, b int) int
    @aaf5 AAFunc<int, int>

    @aaf6 fun()->()
    @aaf7 fun()
    @aaf8 fun()int
    @aaf9 fun(a int)
    @aaf9a fun(a int) int
    @aaf9b fun(a int)->(x int)

    fun af6(p fun(v int)bool) {}
    fun af7<X>(p fun(v X)bool) {}


    @af10 fun(v int)int
}



//get PAoint<T>::Size() Size<T> { return Size(X, Y) }
type OneGeneric<T> { } 
type Point<T>(X T, Y T)
{
    get a() int {}
    set a(v int) {}
    fun pub aaa(a Zurfur.Draw2d.Size<int>) {}
    
}
type Size<T>(Width T, Height T)
{
}

get Point<T>::Sizex<T>() Size<T> { return Size(X, Y) }
get Size<T>::Sizex<T>() Size<T> { }

type pub AAFunc<T1,T2>
{
    fun Invoke(v T1) T2 { }
}


type pub AGenericTest<T, QQQ>
    where QQQ is Equatable<QQQ>//: new() where T : new()
{
    
    @af0 fun()->()
    @af1 fun()
    @af2 fun()int
    @af3 fun(a int)
    @af4 fun(a int) int
    @af5 fun(a int)->(x int)

    fun af6(p fun(v int)bool) {}
    fun af7<X>(p fun(v X)bool) {}

    fun af8<T1,T2>(i T1)T2 { }

    fun Q<T1>() {}

    fun pub new():
        nop()

    fun pub new(a int):
        nop()


    fun pub aaa(a Zurfur.Draw2d.Size<int>) {}
   
    fun pub P1() { return 0 }
    fun pub P2()->() { return 0}
    //fun pub P2<Quack>(a Quack, b QQQ) { return (a.ToStr() + b.ToStr()).Length; }
    fun pub P3<Z>() { return 0; }
    fun pub P4<Quack, Quack1>() { return 0; }
    fun pub fun9(a *?OneGeneric<List<int>>) { }


    fun pub GenericTest<Q1, Q2>(a Q1, b Q2):
        return a.ToStr().Length + b.ToStr().Length    

    
    @field0 T = 0
    @field1 Inner1<str, T>
    @field2 Inner1<QQQ,T>
    @field3 AGenericTest<str,str>.Inner1<QQQ, T>.Inner2<int, int>
    @field4 Inner1<str, T>.Inner2<int, int>
    @field5 AATest.AGenericTest<T,QQQ>.Inner1<QQQ, T>.Inner2<int, int>
        = AATest.AGenericTest[T].Inner1[QQQ, T].Inner2[int, int]
    @field6 Inner1<int, int>.Inner2<int, int>
    @Xfield6 Zurfur.int
    @field7 AATest.AGenericTest<int,int>.Inner1<QQQ, T>.Inner2<int, int>


    fun pub UseIt(x Zurfur.int, y List<Inner1<int,int>>, z List<str>)
    {
        XField0.ToStr()
        // Xfield2<str, T>.P3<T>(); - Xfield2 can't use type parameters
        // Xfield2.P3(); - Can't infer P3<type>
        Xfield2.P3<T>()
        @a = List<str, Outer<int, int>>()

        Inner1<str, byte>.Inner2<short, ushort>.Hello = 1
        Outer<T, QQQ>.Inner1<str, byte>.Inner2<short, ushort>.Hello = 2
        Outer<QQQ, T>.Inner1<str, byte>.Inner2<short, ushort>.Hello = 3
        Outer<long, ulong>.Inner1<T, decimal>.Inner2<QQQ, byte>.Hello = 4

        @p = AGenericTest<long, ulong>.Inner1<T, decimal>.Inner2<QQQ, byte>()
        p.P5<short, QQQ, ushort>(3, QQQ(), 0)
    }
    
    type pub Inner1<Ta, Qa>
    {
        fun pub P1() { return 0; }
        fun pub P2<Quack>() { return 0; }
        fun pub P3<Z>() { return 0; }
        fun pub P4<Z, Quack>() { return 0; }
        fun pub P5<Quack, Quack1, Quack3>() { return 0; }

        type pub Inner2<Tb, Qb>
        {
            fun pub P1() { return 0; }
            fun pub P2<Quack>() { return 0; }
            fun pub P3<Z>() { return 0; }
            fun pub P4<Z, Quack>() { return 0; }
            fun pub P5<Quack, Quack1, Quack3>(a int, b Quack1, c u16)
            {
                return InnerP5() + InnerP5() + a + b.ToStr().Length + c

                fun InnerP5():
                    return ToStr().Length
            }

            @X Inner1<byte, uint>
            @Y Inner2<int, str>
            @Hello int // TBD: Allow this to be static?

            type pub Inner3<A, B>
            {
                fun pub P1() { return 0; }
                fun pub P2<Quack>() { return 0; }
                fun pub P3<Z>() { return 0; }
                fun pub P4<Z, Quack>() { return 0; }
                fun pub AAA<Quack, Quack1, Quack3>
                    (a Quack, b Quack1, c Quack3, d A)
                        ->(x T, y QQQ, z List<QQQ>, w List<int>)
                {
                    return InnerP5() + InnerP5() + a + b.ToStr().Length + c
                    
                    fun InnerP5() int:
                        return ToStr().Length
                }

                @X Inner1<byte, uint>
                @Y Inner2<int, str>
                @Hello int // TBD: Allow static?
            }

        }

    }
}