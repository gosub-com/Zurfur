
// Misc compiler testing
module AATest

use Zurfur
use Zurfur[uint, Log]
use Zurfur.Operators[OpEq, OpNeg, OpAdd]
use Zurfur.Math[cos]

pragma ShowParse

fun helloVoid() {}
fun helloInt() int {}
fun cos2(a int) -> (x f64, y int) {}
fun nop() {}
 
fun test(x f64)
    @a = 3
    @b = x
    @c = x == 3.0
    @(y,z) = cos2
    @d = cos2(3)
    @e = d.x
    @f = helloVoid()
    @g = helloInt()
    Log.info("Hello world, 2+2={2+2}")
    @h = cos(2.0+3.0*23.0).toStr()

fun (s Span<byte>) hello()
    nop()

type AAAA<T>
    @v void

type BBBB
    @v void
        
fun (b BBBB) BBBB_fm1() {}
fun (b BBBB) BBBB_fm2(a BBBB) {}
    


fun (a AAAA<int>) AAAA_fm() {}
fun (a AAAA<T>) AAAA_fm() {}
fun (b BBBB) AAAA_fm() {}

fun AAAA_f() {}

fun (b BBBB) AAAA_fe2(a BBBB) {}

// TBD: AAAA should not conflict with AAAA typename
//      must be resolved before moving methods to module level
fun (a aapoint) AAAA() {}
fun (a aapoint) BBBB() {}
fun (a aapoint) AAAB() {}
fun (l List<T>) X() {}
fun (i int) X() {}
fun (b BBBB) hello() {}
    

type aapoint
    @v void
    
type bbpoint
    @v void

fun pub (a aapoint) x() {}

fun pub (b bbpoint) xx() {}

fun pub (a aapoint) y() {}
fun pub (b bbpoint) yy() {}

fun aaa_arith(a int, b int) int
    @x = a+b
    @y = a+x*b
    return y
  
type pub AAFun    
    @aaf4 fun(a int, b int) int
    @aaf5 AAFunc<int, int>
    @aaf6 fun()->()
    @aaf7 fun()
    @aaf8 fun()int
    @aaf9 fun(a int)
    @aaf9a fun(a int) int
    @aaf9b fun(a int)->(x int)
    @af10 fun(v int)int

fun (f AAFun) aaaa(a int, b int) int { }
fun (f AAFun) aaaa(a int, b f64) int { }
fun (f AAFun) aaaa(x f64, y int) int { }
fun (f AAFun) aaf1(a int, b int)int { }
fun (f AAFun) aaf2(v AAFunc<int, int>) { }
fun (f AAFun) aaf3<T1,T2>(i T1)T2 { }
fun (f AAFun) aaf1s(a int, b int)int { }
fun (f AAFun) aaf2s(v AAFunc<int, int>) { }
fun (f AAFun) aaf3s<T1,T2>(i T1)T2 { }
fun (f AAFun) af6(p fun(v int)bool) {}
fun (f AAFun) af7<X>(p fun(v X)bool) {}

//get PAoint<T>::Size() Size<T> { return Size(X, Y) }
type OneGeneric<T> { } 
type Point<T>(x T, y T)
type Size<T>(width T, height T)
get (my Point<T>) toSize() Size<T> { return Size(my.x, my.y) }

type pub AAFunc<T1,T2>
    @Invoke fun (v T1) T2


// TBD: These are identical to the ones defined in the class
fun (a AGenericTest<T, QQQ>) af6(p fun(v int)bool) {}
//fun (AGenericTest<T, QQQ>) af7<X>(p fun(v X)bool) {}
//fun (AGenericTest<T, QQQ>) af8<T1,T2>(i T1)T2 { }
//fun (AGenericTest<T, QQQ>) Q<T1>() {}
//fun pub (AGenericTest<T, QQQ>) new()
//    nop()
//fun pub (AGenericTest<T, QQQ>) new(a int)
//    nop()
//fun pub (AGenericTest<T, QQQ>) aaa(a Zurfur.Draw2d.Size<int>) {}
//fun pub (AGenericTest<T, QQQ>) P1() { return 0 }
//fun pub (AGenericTest<T, QQQ>) P2()->() { return 0}
//fun pub P2<Quack>(a Quack, b QQQ) { return (a.ToStr() + b.ToStr()).Length; }
//fun pub (AGenericTest<T, QQQ>) P3<Z>() { return 0; }
//fun pub (AGenericTest<T, QQQ>) P4<Quack, Quack1>() { return 0; }
//fun pub (AGenericTest<T, QQQ>) fun9(a *?OneGeneric<List<int>>) { }

//fun pub (AGenericTest<T, QQQ>) UseIt(x Zurfur.int, y List<Inner1<int,int>>, z List<str>)
//    XField0.ToStr()
    // Xfield2<str, T>.P3<T>(); - Xfield2 can't use type parameters
    // Xfield2.P3(); - Can't infer P3<type>
//    Xfield2.P3<T>()
//    @a = List<str, Outer<int, int>>()
//    Inner1<str, byte>.Inner2<short, ushort>.Hello = 1
//    Outer<T, QQQ>.Inner1<str, byte>.Inner2<short, ushort>.Hello = 2
//    Outer<QQQ, T>.Inner1<str, byte>.Inner2<short, ushort>.Hello = 3
//    Outer<long, ulong>.Inner1<T, decimal>.Inner2<QQQ, byte>.Hello = 4
//    @p = AGenericTest<long, ulong>.Inner1<T, decimal>.Inner2<QQQ, byte>()
//    p.P5<short, QQQ, ushort>(3, QQQ(), 0)
//fun pub (AGenericTest<T, QQQ>.Inner1<Ta, Qa>) P1(a T, b QQQ, c Ta, d Qa)
//    return 0

fun pub GenericTest<Q1,Q2>(a Q1, b Q2)
    return a.toStr().Length + b.toStr().Length    

type pub AGenericTest<T, QQQ>
    where QQQ is OpEq<T>//: new() where T : new()
    @af0 fun()->()
    @af1 fun()
    @af2 fun()int
    @af3 fun(a int)
    @af4 fun(a int) int
    @af5 fun(a int)->(x int)
    
    @field0 T = 0
    @Xfield6 Zurfur.int

    