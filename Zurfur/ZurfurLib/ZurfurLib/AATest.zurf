
// Misc compiler testing
module AATest

use Zurfur
use Zurfur[Log]
use Zurfur.Operators[OpEq, OpNeg, OpAdd]
use Zurfur.Math[cos]

pragma ShowParse

fun helloVoid() {}
fun helloInt() int {}
fun cos2(a int) -> (x f64, y int) {}
fun nop() {}
 
fun test(x f64)
    @a = 3
    @b = x
    @c = x == 3.0
    @(y,z) = cos2
    @d = cos2(3)
    @e = d.x
    @f = helloVoid()
    @g = helloInt()
    Log.info("Hello world, 2+2={2+2}")
    @h = cos(2.0+3.0*23.0).str()

fun Span<byte>.hello()
    nop()

type AAAA<T>
    @v void

type BBBB
    @v void
        
fun BBBB.BBBB_fm1() {}
fun BBBB.BBBB_fm2(a BBBB) {}
    


fun AAAA<int>.AAAA_fm() {}
fun AAAA<T>.AAAA_fm() {}
fun BBBB.AAAA_fm() {}

fun AAAA_f() {}

fun BBBB.AAAA_fe2(a BBBB) {}

// TBD: AAAA should not conflict with AAAA typename
//      must be resolved before moving methods to module level
fun aapoint.AAAA() {}
fun aapoint.BBBB() {}
fun aapoint.AAAB() {}
fun List<T>.X() {}
fun int.X() {}
fun BBBB.hello() {}
    

type aapoint
    @v void
    
type bbpoint
    @v void

[pub] fun aapoint.x() {}

[pub] fun bbpoint.xx() {}

[pub] fun aapoint.y() {}
[pub] fun bbpoint.yy() {}

fun aaa_arith(a int, b int) int
    @x = a+b
    @y = a+x*b
    return y
  
[pub] type AAFun    
    @aaf4 fun(a int, b int) int
    @aaf5 AAFunc<int, int>
    @aaf6 fun()->()
    @aaf7 fun()
    @aaf8 fun()int
    @aaf9 fun(a int)
    @aaf9a fun(a int) int
    @aaf9b fun(a int)->(x int)
    @af10 fun(v int)int

fun AAFun.aaaa(a int, b int) int { }
fun AAFun.aaaa(a int, b f64) int { }
fun AAFun.aaaa(x f64, y int) int { }
fun AAFun.aaf1(a int, b int)int { }
fun AAFun.aaf2(v AAFunc<int, int>) { }
fun AAFun.aaf3<T1,T2>(i T1)T2 { }
fun AAFun.aaf1s(a int, b int)int { }
fun AAFun.aaf2s(v AAFunc<int, int>) { }
fun AAFun.aaf3s<T1,T2>(i T1)T2 { }
fun AAFun.af6(p fun(v int)bool) {}
fun AAFun.af7<X>(p fun(v X)bool) {}

//get PAoint<T>::Size() Size<T> { return Size(X, Y) }
type OneGeneric<T> { } 
type Point<T>(x T, y T)
type Size<T>(width T, height T)
get Point<T>.toSize() Size<T> { return Size(my.x, my.y) }

[pub] type AAFunc<T1,T2>
    @Invoke fun (v T1) T2


// TBD: These are identical to the ones defined in the class
fun AGenericTest<T, QQQ>.af6(p fun(v int)bool) {}
//fun AGenericTest<T, QQQ>.af7<X>(p fun(v X)bool) {}
//fun AGenericTest<T, QQQ>.af8<T1,T2>(i T1)T2 { }
//fun AGenericTest<T, QQQ>.Q<T1>() {}
//[pub] fun AGenericTest<T, QQQ>.new()
//    nop()
//[pub] fun AGenericTest<T, QQQ>.new(a int)
//    nop()
//[pub] fun AGenericTest<T, QQQ>.aaa(a Zurfur.Draw2d.Size<int>) {}
//[pub] fun AGenericTest<T, QQQ>.P1() { return 0 }
//[pub] fun AGenericTest<T, QQQ>.P2()->() { return 0}
//[pub] fun P2<Quack>(a Quack, b QQQ) { return (a.ToStr() + b.ToStr()).Length; }
//[pub] fun AGenericTest<T, QQQ>.P3<Z>() { return 0; }
//[pub] fun AGenericTest<T, QQQ>.P4<Quack, Quack1>() { return 0; }
//[pub] fun AGenericTest<T, QQQ>.fun9(a *?OneGeneric<List<int>>) { }

//[pub] fun AGenericTest<T, QQQ>.UseIt(x Zurfur.int, y List<Inner1<int,int>>, z List<str>)
//    XField0.ToStr()
    // Xfield2<str, T>.P3<T>(); - Xfield2 can't use type parameters
    // Xfield2.P3(); - Can't infer P3<type>
//    Xfield2.P3<T>()
//    @a = List<str, Outer<int, int>>()
//    Inner1<str, byte>.Inner2<short, ushort>.Hello = 1
//    Outer<T, QQQ>.Inner1<str, byte>.Inner2<short, ushort>.Hello = 2
//    Outer<QQQ, T>.Inner1<str, byte>.Inner2<short, ushort>.Hello = 3
//    Outer<long, ulong>.Inner1<T, decimal>.Inner2<QQQ, byte>.Hello = 4
//    @p = AGenericTest<long, ulong>.Inner1<T, decimal>.Inner2<QQQ, byte>()
//    p.P5<short, QQQ, ushort>(3, QQQ(), 0)
//[pub] fun (AGenericTest<T, QQQ>.Inner1<Ta, Qa>) P1(a T, b QQQ, c Ta, d Qa)
//    return 0

[pub] fun GenericTest<Q1,Q2>(a Q1, b Q2)
    return a.toStr().Length + b.toStr().Length    

[pub] type AGenericTest<T, QQQ>
    where QQQ is OpEq<T>//: new() where T : new()
    @af0 fun()->()
    @af1 fun()
    @af2 fun()int
    @af3 fun(a int)
    @af4 fun(a int) int
    @af5 fun(a int)->(x int)
    
    @field0 T = 0
    @Xfield6 Zurfur.int

    