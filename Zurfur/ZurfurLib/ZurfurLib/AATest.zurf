
// Misc compiler testing
module AATest


use Zurfur
use Zurfur[Log, Xuint, RawPointer, castPointer]
use Zurfur.Operators[OpEq]
use Zurfur.Math[cos]
use Zurfur.Draw2d[Size, Point]

pragma ShowParse

type MyPoint<T1,T2,T3>
    a T1
    b T2
    c T3

fun MyFun1<T1,T2,T3>(a T1, b T2, c T3) T2
    @q = b
    return q

fun MyFun2<I,O>(i I) O
    return O()

fun MyFun3<I,O>(i int) O
    return O()

fun MyFun4<T0,T1,T2,T3>(i int) List<T2>
    return List<T2>()

fun MyFun5<T0,T1,T2,T3>(i int) -> (a List<T1>, b List<T3>)
    return (List<T1>(), List<T3>())

fun Test<X0,X1,X2,X3>()
    @f1 = MyFun2<int, f64>(0)
    @f2 = MyFun3<int,f64>(1)
    @f3 = MyFun3<f64,int>(1)
    @f4 = MyFun4<f64,int,List<X3>,u32>(1)
    @f5 = MyFun5<f64,int,str,u64>(1)
    @a = MyPoint<int,f64,str>()
    @b = MyPoint<X2, List<X3>, Map<X1,X3>>()
    @c = MyFun1<int, MyPoint<int,int,int>, str>(0, MyPoint<int,int,int>(), "hello")
    @d = MyFun1<int, MyPoint<int,X3,int>, str>(0, MyPoint<int,X3,int>(), "hello")
    @e = MyFun2<X2,X3>(0)
    @g = MyFun2<int,f64>(0)
    @h = MyFun2<f64,int>(0.0)
    @f4a = MyFun4<int,str,f32,u64>(0)
    @f5a = MyFun5<int,str,f32,u64>(0) 
    @i Size<int> = Size<int>(0,0)  
    @k f64 = 0.0
    @l f64 = 0f64
    @p1 = Xuint()
    @p2 = castPointer<RawPointer<byte>>(p1)
    @p3 = castPointer<RawPointer<int>>(p2)
    @p4 = castPointer<Xuint>(p3)
    @t = (0,1,2)

type OneGeneric<T> { } 
//type Point<T>(x T, y T)
//type Size<T>(width T, height T)

fun get Point<T>.toSize() Size<T>
    @a = Size<T>(0,0)
    @b = Size<T>()
    @c = Size<T>(my.x, my.y)
    return Size<T>(my.x, my.y)

[pub] fun _opAdd<T>(a Point<T>, b Point<T>) Point<T>
    return Point<T>(a.x+b.x, a.y+b.y)




fun helloVoid() {}
fun helloInt() int {}
fun cos2(a int) -> (x f64, y int) {}
fun nop() {}
 
fun test(x f64)
    @a = 3
    @b = x
    @c = x == 3.0
    @(y,z) = cos2
    @d = cos2(3)
    @e = d.x
    @f = helloVoid()
    @g = helloInt()
    Log.info("Hello world, 2+2={2+2}")
    @h = cos(2.0+3.0*23.0).toStr

fun Span<byte>.hello()
    nop()

type AAAA<T>
    v void

type BBBB
    v void
        
fun BBBB.BBBB_fm1() {}
fun BBBB.BBBB_fm2(a BBBB) {}
    


fun AAAA<int>.AAAA_fm() {}
fun AAAA<T>.AAAA_fm() {}
fun BBBB.AAAA_fm() {}

fun AAAA_f() {}

fun BBBB.AAAA_fe2(a BBBB) {}

// TBD: AAAA should not conflict with AAAA typename
//      must be resolved before moving methods to module level
fun aapoint.AAAA() {}
fun aapoint.BBBB() {}
fun aapoint.AAAB() {}
fun List<T>.X() {}
fun int.X() {}
fun BBBB.hello() {}
    

type aapoint
    v void
    
type bbpoint
    v void

[pub] fun aapoint.x() {}

[pub] fun bbpoint.xx() {}

[pub] fun aapoint.y() {}
[pub] fun bbpoint.yy() {}

fun aaa_arith(a int, b int) int
    @x = a+b
    @y = a+x*b
    return y
  
[pub] type AAFun    
    aaf4 fun(a int, b int) int
    aaf5 AAFunc<int, int>
    aaf6 fun()->()
    aaf7 fun()
    aaf8 fun()int
    aaf9 fun(a int)
    aaf9a fun(a int) int
    aaf9b fun(a int)->(x int)
    af10 fun(v int)int

fun AAFun.aaaa(a int, b int) int { }
fun AAFun.aaaa(a int, b f64) int { }
fun AAFun.aaaa(x f64, y int) int { }
fun AAFun.aaf1(a int, b int)int { }
fun AAFun.aaf2(v AAFunc<int, int>) { }
fun AAFun.aaf3<T1,T2>(i T1)T2 { }
fun AAFun.aaf1s(a int, b int)int { }
fun AAFun.aaf2s(v AAFunc<int, int>) { }
fun AAFun.aaf3s<T1,T2>(i T1)T2 { }
fun AAFun.af6(p fun(v int)bool) {}
fun AAFun.af7<X>(p fun(v X)bool) {}


[pub] type AAFunc<T1,T2>
    Invoke fun (v T1) T2


// TBD: These are identical to the ones defined in the class
fun AGenericTest<T, QQQ>.af6(p fun(v int)bool) {}
//fun AGenericTest<T, QQQ>.af7<X>(p fun(v X)bool) {}
//fun AGenericTest<T, QQQ>.af8<T1,T2>(i T1)T2 { }
//fun AGenericTest<T, QQQ>.Q<T1>() {}
//[pub] fun AGenericTest<T, QQQ>.new()
//    nop()
//[pub] fun AGenericTest<T, QQQ>.new(a int)
//    nop()
//[pub] fun AGenericTest<T, QQQ>.aaa(a Zurfur.Draw2d.Size<int>) {}
//[pub] fun AGenericTest<T, QQQ>.P1() { return 0 }
//[pub] fun AGenericTest<T, QQQ>.P2()->() { return 0}
//[pub] fun P2<Quack>(a Quack, b QQQ) { return (a.ToStr() + b.ToStr()).Length; }
//[pub] fun AGenericTest<T, QQQ>.P3<Z>() { return 0; }
//[pub] fun AGenericTest<T, QQQ>.P4<Quack, Quack1>() { return 0; }
//[pub] fun AGenericTest<T, QQQ>.fun9(a *?OneGeneric<List<int>>) { }

//[pub] fun AGenericTest<T, QQQ>.UseIt(x Zurfur.int, y List<Inner1<int,int>>, z List<str>)
//    XField0.ToStr()
    // Xfield2<str, T>.P3<T>(); - Xfield2 can't use type parameters
    // Xfield2.P3(); - Can't infer P3<type>
//    Xfield2.P3<T>()
//    @a = List<str, Outer<int, int>>()
//    Inner1<str, byte>.Inner2<short, ushort>.Hello = 1
//    Outer<T, QQQ>.Inner1<str, byte>.Inner2<short, ushort>.Hello = 2
//    Outer<QQQ, T>.Inner1<str, byte>.Inner2<short, ushort>.Hello = 3
//    Outer<long, ulong>.Inner1<T, decimal>.Inner2<QQQ, byte>.Hello = 4
//    @p = AGenericTest<long, ulong>.Inner1<T, decimal>.Inner2<QQQ, byte>()
//    p.P5<short, QQQ, ushort>(3, QQQ(), 0)
//[pub] fun (AGenericTest<T, QQQ>.Inner1<Ta, Qa>) P1(a T, b QQQ, c Ta, d Qa)
//    return 0

[pub] fun GenericTest<Q1,Q2>(a Q1, b Q2)
    return a.toStr().Length + b.toStr().Length    

[pub] type AGenericTest<T, QQQ>
    where QQQ has OpEq<T>//: new() where T : new()
    af0 fun()->()
    af1 fun()
    af2 fun()int
    af3 fun(a int)
    af4 fun(a int) int
    af5 fun(a int)->(x int)
    
    field0 T = 0
    Xfield6 Zurfur.int

    