
// Misc compiler testing
mod AATest


use Zurfur
use Zurfur[Log, Xuint, RawPointer, castPointer,
            Iterator, Iterable, OpEq, NumOps]
use Zurfur.Math[cos]
use Zurfur.Draw2d[Size, Point]


pragma ShowParse

fun aaa_arith(a Int, b Int) Int
    Log.info("Hello world: 2+2 is " + (2 + 2).toStr)
    @x = a+b
    @y = a*b
    Log.info("X is " + x.toStr + ", Y is " + y.toStr)
    @hold
    if x < y
        @q = 4+2
        Log.info("if x < y" + q.toStr)
        hold = q
    else
        @q = 23
        Log.info("else x >= y")
        hold = q
    Log.info("Answer" + hold.toStr)
    
    return y


fun test_listMap()
    @a = List<F64>()
    @c = a.map<F64,Int>(@i => i.toIntMask)


fun test_forEach(args Array<Str>)
    @sum = 0
    @list List<Int>
    list.forEach(@item => { sum += item })


// https://stackoverflow.com/questions/1825952/how-to-create-a-generic-extension-method
fun Iterator.alphaLengthWise<Item, L>(lengthProvider fun(t Item) L) Iterator<Item>
    return my.orderBy<Item, L>(@a => lengthProvider(a))
             .thenBy<Item, L>(@a => a)
fun Iterator.orderBy<Source,Key>(keySelector fun(i Source)Key) Iterator<Source>
    extern
fun Iterator.thenBy<Source,Key>(keySelector fun(i Source)Key) Iterator<Source>
    extern

fun mut Iterator.find<T>(f fun(item T) Bool) mut ?ref T
    while my.next()@item
        if f(item)
            return ref item
    return nil


// Simple selection sort
fun Span.test_selectionSort<T>(lessThan fun(a T,b T)Bool)
    for @i in my.len-1
        @lowElem = my[i]
        @lowIndex = i
        for @j in i+1..my.len
            if lessThan(my[j], lowElem)
                lowElem = my[j]
                lowIndex = j
        if lowIndex != i
            my[lowIndex] = my[i]
            my[i] = lowElem

type AA<T1,T2,T3>
    a T1

type MyPoint<T1,T2,T3>
    a T1
    b T2
    c T3
    x (Int, T1, Int)
    y (a Int, b T1, c Int, d (r Int, b Int))

type Iterable2<Item> interface
    fun iterator2() Iterator<Item>

type GetMap<Item1,Item2> interface
    fun getMap() Map<Item1, Item2>
    fun getMapKeys() Iterator<Item1>
    fun getMapValues() Iterator<Item2>

type Getter interface
    fun get myGet() I32
    fun myFun() I32

type Getter2<T> interface
    fun get myGet2() T
    fun myFun2() T
    fun myFun2Ns() T
    [static] fun myFun2Stat() T

type MyAdd<T> interface
    fun myAddNotStatic(a T, b T) T
    [static] fun myAddStatic(a T, b T) T

fun getMapFun<K,V>() Map<V,K>
    return Map<V,K>()

fun myFun2Interf<T>(i T) T extern

fun takeFun(i fun(a Int)Int) extern

type GetHash interface
    fun getHash() U32

fun test_tuples()
    @tuples = List<(Int, Str)>()
    tuples.push((1, "Hello"))
    @tupleElement = tuples[0]
    
    @tuplesNamed = List<(x Int,  y Str)>()
    tuplesNamed.push((1, "Hello"))
    @tuplesNamedElement = tuplesNamed[0]
    @element = tuplesNamedElement.x


fun AAAAA<X, T, Q>(t T, q Q, intf1 Iterator<I32>, intf2 GetHash, mgQ Getter2<Q>, mgF Getter2<F64>, myGetter Getter)
        where T has NumOps<T> + GetHash + Iterable<Int> + Iterable2<Int> + GetMap<F32,F64> + Iterator<Int>
        where Q has NumOps<Q> + Getter + Getter2<Int> + MyAdd<Q>

    // Source code symbols should be non-generic
    @next3 = q.myGet2
    @next4 = q.myFun2Ns()
    @next5 = Q.myFun2Stat()
    @next6 = q.myGet
    @next7 = q.myFun()

    
    @next1 = t.next()
    @gotq = myFun2Interf(q)
    @gotInt = myFun2Interf(3) // myFun2Interf not linked to specialized
    @next2 = intf1.next() // Next is linked to generic
    @myGet = q.myGet
    @myGetter2 = myGetter.myGet
    @myGet2 = q.myGet2
    @mgGet2a = mgQ.myGet2
    @mgGet2F = mgF.myGet2
    @mgFun2F = mgF.myFun2()
    @myPoint = MyPoint<Int,F64,F32>().b

    @intf2b = intf2.getHash()
    @myAddNs = q.myAddNotStatic(Q(),Q())
    @myAdd = Q.myAddStatic(Q(),Q())
    @myFun = q.myFun()
    @myFun2 = q.myFun2()
    @aa = t.getHash()
    @getMap = t.getMap()
    @getMapFunc = getMapFun<I32,U32>()
    @getMapKeys = t.getMapKeys()
    @getMapValues = t.getMapValues()
    @iter1 = t.iterator
    @iter2 = t.iterator2()
    @first = iter1.next()
    @x = 1
    @y = 2
    @z1 = x + y
    @z2 = Int._opAdd(x,y)
    @a = T()
    @b = T()
    @z3 = a + b
    @z4 = T._opAdd(a,b)
    @z6 = T().getHash()
    @z5 = T.One
    @iter3 = t.iterator()

    for @item in t
        @itemt = item


fun MyFun1<T1,T2,T3>(a T1, b T2, c T3)(x T2, y T3)
    @q = b
    return (T2(), T3())

fun MyFun2<I,O>(i I) O
    return O()

fun MyFun3<I,O>(i Int) O
    return O()

fun MyFun4<T0,T1,T2,T3>(i Int) List<T2>
    return List<T2>()

fun MyFun5<T0,T1,T2,T3>(i Int)(a List<T1>, b List<T3>)
    return (List<T1>(), List<T3>())

fun inferMap<T1,T2>(a Map<T1,T2>, b List<T2>)(x T1, y T2)
    return (T1(), T2())

fun Test<X0,X1,X2,X3>()
    @infer1 = MyFun1(0, "", 0.0)
    @infer2 = MyFun1(0, List<Int>(), 0)
    @infer3 = MyFun1(0, List<X2>(), 0.0)
    @infer4 = inferMap(Map<Int,Str>(), List<Str>())
    @f1 = MyFun2<Int, F64>(0)
    @f2 = MyFun3<Int,F64>(1)
    @f3 = MyFun3<F64,Int>(1)
    @f4 = MyFun4<F64,Int,List<X3>,U32>(1)
    @f5 = MyFun5<F64,Int,Str,U64>(1)
    @a = MyPoint<Int,F64,Str>()
    @b = MyPoint<X2, List<X3>, Map<X1,X3>>()
    @c = MyFun1<Int, MyPoint<Int,Int,Int>, Str>(0, MyPoint<Int,Int,Int>(), "hello")
    @d = MyFun1<Int, MyPoint<Int,X3,Int>, Str>(0, MyPoint<Int,X3,Int>(), "hello")
    @e = MyFun2<X2,X3>(X2())
    @g = MyFun2<Int,F64>(0)
    @h = MyFun2<F64,Int>(0.0)
    @f4a = MyFun4<Int,Str,F32,U64>(0)
    @f5a = MyFun5<Int,Str,F32,U64>(0) 
    @i Size<Int> = Size<Int>(0,0)  
    @k F64 = 0.0
    @l F64 = 0F64
    @p1 = Xuint()
    @p2 = castPointer<RawPointer<Byte>>(p1)
    @p3 = castPointer<RawPointer<Int>>(p2)
    @p4 = castPointer<Xuint>(p3)
    @t = (0,1,2)
    @toSize = Point<F32>().toSizeTest

type OneGeneric<T> { } 

fun get Point.toSizeTest<T>() Size<T>
    @a = Size<T>(T(),T())
    @b = Size<T>()
    @c = Size(my.x, my.y)
    @d = Size(0,0)
    return c





fun helloVoid() {}
fun helloInt() Int {}
fun cos2(a Int)(x F64, y Int) {}
fun nop() {}
 
fun test(x F64)
    @a = 3
    @b = x
    @c = x == 3.0
    @z = cos2(1)
    @d = cos2(3)
    @e = d.x
    @f = helloVoid()
    @g = helloInt()
    Log.info("Hello world, 2+2={2+2}")
    @h = cos(2.0+3.0*23.0).toStr

fun Span<Byte>.hello()
    nop()

type AAAA<T>
    v Void

type BBBB
    v Void
        
fun BBBB.BBBB_fm1() {}
fun BBBB.BBBB_fm2(a BBBB) {}
    


fun AAAA<Int>.AAAA_fm() {}
fun AAAA.AAAA_fm<T>() {}
fun BBBB.AAAA_fm() {}

fun AAAA_f() {}

fun BBBB.AAAA_fe2(a BBBB) {}

// TBD: AAAA should not conflict with AAAA typename
//      must be resolved before moving methods to module level
fun aapoint.AAAA() {}
fun aapoint.BBBB() {}
fun aapoint.AAAB() {}
fun List.X<T>() {}
fun Int.X() {}
fun BBBB.hello() {}
    

type aapoint
    v Void
    
type bbpoint
    v Void

[pub] fun aapoint.x() {}

[pub] fun bbpoint.xx() {}

[pub] fun aapoint.y() {}
[pub] fun bbpoint.yy() {}

  
[pub] type AAFun    
    aaf4 fun(a Int, b Int) Int
    aaf5 AAFunc<Int, Int>
    aaf6 fun()()
    aaf7 fun()
    aaf8 fun()Int
    aaf9 fun(a Int)
    aaf9a fun(a Int) Int
    aaf9b fun(a Int)(x Int)
    af10 fun(v Int)Int

fun AAFun.aaaa(a Int, b Int) Int { }
fun AAFun.aaaa(a Int, b F64) Int { }
fun AAFun.aaaa(x F64, y Int) Int { }
fun AAFun.aaf1(a Int, b Int)Int { }
fun AAFun.aaf2(v AAFunc<Int, Int>) { }
fun AAFun.aaf3<T1,T2>(i T1)T2 { }
fun AAFun.aaf1s(a Int, b Int)Int { }
fun AAFun.aaf2s(v AAFunc<Int, Int>) { }
fun AAFun.aaf3s<T1,T2>(i T1)T2 { }
fun AAFun.af6(p fun(v Int)Bool) {}
fun AAFun.af7<X>(p fun(v X)Bool) {}


[pub] type AAFunc<T1,T2>
    Invoke fun (v T1) T2


// TBD: These are identical to the ones defined in the class
fun AGenericTest.af6<T,QQQ>(p fun(v Int)Bool) {}
//fun AGenericTest<T, QQQ>.af7<X>(p fun(v X)Bool) {}
//fun AGenericTest<T, QQQ>.af8<T1,T2>(i T1)T2 { }
//fun AGenericTest<T, QQQ>.Q<T1>() {}
//[pub] fun AGenericTest<T, QQQ>.new()
//    nop()
//[pub] fun AGenericTest<T, QQQ>.new(a Int)
//    nop()
//[pub] fun AGenericTest<T, QQQ>.aaa(a Zurfur.Draw2d.Size<Int>) {}
//[pub] fun AGenericTest<T, QQQ>.P1() { return 0 }
//[pub] fun AGenericTest<T, QQQ>.P2()() { return 0}
//[pub] fun P2<Quack>(a Quack, b QQQ) { return (a.ToStr() + b.ToStr()).Length; }
//[pub] fun AGenericTest<T, QQQ>.P3<Z>() { return 0; }
//[pub] fun AGenericTest<T, QQQ>.P4<Quack, Quack1>() { return 0; }
//[pub] fun AGenericTest<T, QQQ>.fun9(a *?OneGeneric<List<Int>>) { }

//[pub] fun AGenericTest<T, QQQ>.UseIt(x Zurfur.Int, y List<Inner1<Int,Int>>, z List<Str>)
//    XField0.ToStr()
    // Xfield2<Str, T>.P3<T>(); - Xfield2 can't use type parameters
    // Xfield2.P3(); - Can't infer P3<type>
//    Xfield2.P3<T>()
//    @a = List<Str, Outer<Int, Int>>()
//    Inner1<Str, Byte>.Inner2<short, ushort>.Hello = 1
//    Outer<T, QQQ>.Inner1<Str, Byte>.Inner2<short, ushort>.Hello = 2
//    Outer<QQQ, T>.Inner1<Str, Byte>.Inner2<short, ushort>.Hello = 3
//    Outer<long, ulong>.Inner1<T, decimal>.Inner2<QQQ, Byte>.Hello = 4
//    @p = AGenericTest<long, ulong>.Inner1<T, decimal>.Inner2<QQQ, Byte>()
//    p.P5<short, QQQ, ushort>(3, QQQ(), 0)
//[pub] fun (AGenericTest<T, QQQ>.Inner1<Ta, Qa>) P1(a T, b QQQ, c Ta, d Qa)
//    return 0

type ToStr interface
    fun get toStr() Str

[pub] fun GenericTest<Q1,Q2>(a Q1, b Q2) Int
        where Q1 has ToStr
        where Q2 has ToStr
    return a.toStr.len + b.toStr.len    

[pub] type AGenericTest<T, QQQ>
    where QQQ has OpEq<T>//: new() where T : new()
    af0 fun()()
    af1 fun()
    af2 fun()Int
    af3 fun(a Int)
    af4 fun(a Int) Int
    af5 fun(a Int)(x Int)
    
    field0 T = 0
    Xfield6 Zurfur.Int

    