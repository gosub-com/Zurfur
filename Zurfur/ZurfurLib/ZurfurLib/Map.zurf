
module Zurfur

use Zurfur.Operators[OpIn, OpEq, GetHash]
use Zurfur.Collections[GetIter, Iter, Collection]

type KvPair<TKey,TValue>
    @key TKey pub ref
    @value TValue pub ref mut

fun pub KvPair<TKey,TValue>.new(key own TKey, value own TValue)
    this.key = key
    this.value = value


pub type Map<TKey, TValue>
    where This is OpIn<TKey> + GetIter<ref KvPair<TKey, TValue>>
    where TKey is OpEq<TKey> + GetHash
    @items List<str> // TBD: Buffer of items in hash table

fun pub Map<TKey, TValue>.new(capacity int)
    return todo()
fun pub Map<TKey, TValue>.new(keyValues Iter<KvPair<TKey, TValue>>)
    return todo()
get pub Map<TKey, TValue>.count() int
    return todo()

// TBD: Figure out map["Hello"] += 1
get pub Map<TKey, TValue>.op_index(key TKey) ?ref TValue
    return todo()
set pub mut Map<TKey, TValue>.op_index(key TKey) mut ref TValue
    todo()


fun pub Map<TKey, TValue>.contains(key TKey) bool
    return todo()
get pub Map<TKey, TValue>.keys() Collection<TKey>
    return todo()
get pub Map<TKey, TValue>.values() Collection<TValue>
    return todo()
fun pub mut Map<TKey, TValue>.clear()
    return todo()
fun pub mut Map<TKey, TValue>.add(item KvPair<TKey, TValue>)
    return todo()
fun pub mut Map<TKey, TValue>.add(items Iter<KvPair<TKey, TValue>>)
    return todo()
fun pub mut Map<TKey, TValue>.remove(key TKey) bool
    return todo()

    