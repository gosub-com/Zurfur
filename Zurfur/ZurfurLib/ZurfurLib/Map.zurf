
mod Zurfur

use Zurfur.Operators[OpEq]
use Zurfur.Collections[Iterator, Iterable]



// Entries in the bucket list
type MapEntry(index u32, hash u32)


// Key value pair
[pub]
type KvPair<K,V>
        where K has OpEq<K>
    key K pub ref
    value V pub mut

// A map is a hash table
[pub]
type Map<K,V>
        where K has OpEq<K>
    _items List<KvPair<K,V>>
    _buckets List<MapEntry>



// TBD: Need this: fun (kv Map<K,V>.Pair) ...
[pub]
fun KvPair.new(key own My.K, value own My.V)
    my.key = key
    my.value = value


[pub]
fun Map.new(capacity int)
    extern
    
[pub]
fun Map.new(keyValues Iterator<KvPair<My.K, My.V>>)
    extern
    
[pub]
fun get Map.len() int
    extern

// TBD: Figure out map["Hello"] += 1
[pub static]
fun Map._opIndex(map Map<My.K, My.V>, key My.K) mut ?ref My.V
    extern

// TBD: An indexer with 3 inputs???
[pub static]
fun Map._opIndex(map Map<My.K, My.V>, key My.K, item My.V)
    extern

[pub]
fun Map.contains(key My.K) bool
    extern

// TBD: Return Iterable<(K, V)>???
[pub]
fun get Map.iterator() mut Iterator<KvPair<My.K, My.V>>
    extern

[pub]
fun get Map.keys() Iterator<My.K>
    extern

[pub]
fun get Map.values() mut Iterator<My.V>
    extern

[pub]
fun mut Map.clear()
    extern

[pub]
fun mut Map.add(item KvPair<My.K, My.V>)
    extern

[pub]
fun mut Map.add(items Iterator<KvPair<My.K, My.V>>)
    extern

[pub]
fun mut Map.remove(key My.K) bool
    extern

    