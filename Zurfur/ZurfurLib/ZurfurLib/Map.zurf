use Zurfur

module Zurfur

pub type Map<TKey, TValue>
    where TKey is IEquatable<TKey>
{
    pub fun new(capacity int)
        where TKey is IEquatable:
        return todo()
    pub fun new(keyValues Collection<Pair<TKey, TValue>>):
        return todo()
    pub get Count() int:
        return todo()
    pub fun operator in(a TKey) bool:
        return todo()

    // TBD: Figure out map["Hello"] += 1 
    pub get operator[](key TKey) ?ref mut TValue:
        return todo()
    pub set operator[](key TKey, value own TValue):
        return todo()


    pub fun Contains(key TKey) bool:
        return todo()
    pub fun Get(key TKey) TValue:
        return todo()
    pub fun Get(key TKey, defaultValue TValue) TValue:
        return todo()
    pub fun TryGet(key TKey) ?TValue:
        return todo()
    pub get Keys() Collection<TKey>:
        return todo()
    pub get Values() Collection<TValue>:
        return todo()
    pub fun mut Clear():
        return todo()
    pub fun mut Add(item Pair<TKey, TValue>):
        return todo()
    pub fun mut Add(items Collection<Pair<TKey, TValue>>):
        return todo()
    pub fun mut Remove(key TKey) bool:
        return todo()
}