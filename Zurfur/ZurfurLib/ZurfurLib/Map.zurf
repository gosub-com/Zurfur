
module Zurfur

use Zurfur.Operators[OpIn, OpEq]
use Zurfur.Collections[Iterator, Iterable]



[pub]
type Map<K,V>
    items List<str> // TBD: Buffer of items in hash table

    // TBD: Allow this
    //type Pair
    //    key K pub ref
    //    value V pub ref mut

// TBD: This wants to be inside Map<K,V>
[pub]
type KvPair<K,V>
    key K pub ref
    value V pub mut

// TBD: Need this: fun (kv Map<K,V>.Pair) ...
[pub]
fun KvPair<K,V>.new(key own K, value own V)
    my.key = key
    my.value = value


[pub]
fun Map<K,V>.new(capacity int)
    extern
    
[pub]
fun Map<K,V>.new(keyValues Iterator<KvPair<K,V>>)
    extern
    
[pub]
fun get Map<K,V>.count() int
    extern

// TBD: Figure out map["Hello"] += 1
[pub]
fun _opIndex<K,V>(map Map<K,V>, key K) mut ?ref V
    extern

// TBD: An indexer with 3 inputs???
[pub]
fun _opIndex<K,V>(map Map<K,V>, key K, item V)
    extern

[pub]
fun Map<K,V>.contains(key K) bool
    extern

// TBD: Return Iterable<(K, V)>???
[pub]
fun get Map<K,V>.iterator() mut Iterator<KvPair<K,V>>
    extern

[pub]
fun get Map<K,V>.keys() Iterator<K>
    extern

[pub]
fun get Map<K,V>.values() mut Iterator<V>
    extern

[pub]
fun mut Map<K,V>.clear()
    extern

[pub]
fun mut Map<K,V>.add(item KvPair<K,V>)
    extern

[pub]
fun mut Map<K,V>.add(items Iterator<KvPair<K,V>>)
    extern

[pub]
fun mut Map<K,V>.remove(key K) bool
    extern

    