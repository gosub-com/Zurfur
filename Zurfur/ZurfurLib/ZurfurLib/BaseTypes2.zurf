// Define the more complex base types: str, Array, List, Map

namespace Zurfur


/// String is a wrapper for a read only array of bytes
pub class str
    : ArrayBase<byte>, IComparable<str>, IRoArray<byte>
{
    default str = "";
    
    pub new() { todo() }
    pub new(s str) { todo() }
    pub new(s Span<byte>) { todo() }
    pub operator[](index int) byte => todo()
    pub operator[](range Range) Span<byte> => todo() // Slice
    
    pub static func GetHashCode(a str) uint => todo()
    pub static func Equals(a str, b str) bool => todo()
    pub static func Compare(a str, b str) int => todo()
        
    pub operator+(s1 str, s2 str) str { todo() }   
    pub operator+(s1 Span<byte>, s2 str) str { todo() }
    pub operator+(s1 str, s2 Span<byte>) str { todo() }
    // TBD: Implicit conversion to and from Span?
}

// Array of constant size
pub class mut Array<T> 
    : ArrayBase<T>, IArray<T>, IMutArray<T>
{
    const MaxSize int = int.MaxInt/2
    pub static Empty Array<T>()

    pub new(count int) => todo()
    pub new(items ICollection<T>) => todo()
    
    pub operator[](index int) ref T => todo()
    pub operator[](range Range) MutMemory<T> => todo()
}

pub class mut List<T> 
    : IList<T>
{
    pub new() => todo()
    pub new(capacity int) => todo()
    pub new(items ICollection<T>) => todo()
    
    pub prop Count int => todo()

    pub operator[](index int) T { get => todo() set => todo() }
    pub operator[](index Range) IArray<T> => todo()
    pub func mut Add(item T) => todo()
    pub func mut Clear() => todo()
    pub func mut Insert(index int, item T) => todo()
    pub func mut Insert(index int, items ICollection<T>) => todo()
    pub func mut Remove(index int) => todo()
    pub func mut Remove(range Range) => todo()
    
}

pub class mut Map<TKey, TValue> 
    : IMutMap<TKey, TValue>
{
    compareFunc func(a TKey, b TKey) bool;
    hashFunc func(a TKey) bool;
    

    pub new() where TKey : IEquatable<TKey>
    {
        compareFunc = (a, b) -> TKey.Compare(a, b)
        hashFunc = (a) -> TKey.GetHashCode(a)
    }
    pub new(compare func(a TKey, b TKey) bool, 
        getHashCode func(a TKey) uint)
    {
        compareFunc = compare;
        hashFunc = getHashCode;
    }
    pub new(capacity int) where TKey : IEquatable
        => todo()
    pub new(keyValues ICollection<KeyValuePair<TKey, TValue>>) => todo()
    
    pub prop Count int => todo()
    pub operator in(a TKey) bool => todo()
    
    pub func Contains(key TKey) bool => todo()
    pub func Get(key TKey) TValue => todo()
    pub func Get(key TKey, defaultValue TValue) TValue => todo()
    pub func TryGet(key TKey, value out ?TValue) bool => todo()
    pub prop Keys ICollection<TKey> { get => todo() }
    pub prop Values ICollection<TValue> { get => todo() }

    pub operator[](key TKey) TValue { get => todo() set => todo() }
    pub func mut Clear() => todo()
    pub func mut Add(item KeyValue<TKey, TValue>) => todo()    
    pub func mut Add(items ICollection<KeyValue<TKey, TValue>>) => todo()    
    pub func mut Remove(TKey key) bool => todo()
}