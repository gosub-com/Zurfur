// Define the more complex base types: str, Array, List, Map, various spans

namespace Zurfur


/// Read only span
pub ref ro struct RoSpan<T>
{
    ro data ref T
    pub ro Count int
    pub this[index int] ro ref T => todo()
    pub this[index Range] RoSpan<T> => todo()
}

/// Span of contiguous elements in memory or an array
pub ref ro struct Span<T>
{
    ro data ref T
    pub ro Count int
    pub this[index int] ref T => todo()
    pub this[index Range] Span<T> => todo()
    operator implicit(from Span<T>) RoSpan<T> => todo()
}

/// Read only array span
pub ro struct RoASpan<T>
{
    ro data Array<T>
    pub ro Count int
    pub this[index int] T => todo()
    pub this[index Range] RoASpan<T> => todo()
    operator implicit(from RoASpan<T>) RoSpan<T> => todo()
}

/// Array span
pub ro struct ASpan<T>
{
    ro data Array<T>
    pub ro Count int
    pub this[index int] ref T => todo()
    pub this[index Range] ASpan<T> => todo()
    operator implicit(from ASpan<T>) RoASpan<T> => todo()
    operator implicit(from ASpan<T>) RoSpan<T> => todo()
    operator implicit(from ASpan<T>) Span<T> => todo()
}

/// String is a wrapper for a read only array of bytes
pub sealed ro class str
    : ArrayBase<byte>, IComparable<str>, IRoArray<byte>
{
    default string = "";
    
    pub new() { todo() }
    pub new(s str) { todo() }
    pub new(s RoSpan<byte>) { todo() }
    pub this[index int] byte => todo()
    pub this[range Range] RoSpan<byte> => todo() // Slice
    
    pub static func GetHashCode(a str) uint => todo()
    pub static func Equals(a str, b str) bool => todo()
    pub static func Compare(a str, b str) int => todo()
        
    pub operator+(s1 str, s2 str) str { todo() }   
    pub operator+(s1 RoSpan<byte>, s2 str) str { todo() }
    pub operator+(s1 str, s2 RoSpan<byte>) str { todo() }
    // TBD: Implicit conversion to and from RoSpan
}

// Array of constant size
pub sealed class Array<T> 
    : ArrayBase<T>, IArray<T>
{
    const MaxSize int = int.MaxInt/2
    pub static ro Empty Array<T>()

    new(count int) => todo()
    new(items ICollection<T>) => todo()
    
    pub this[index int] ref T => todo()
    pub this[range Range] ASpan<T> => todo()
}

// Note that the List class has a ref return indexer, just like Array
pub class List<T> 
    : IList<T>
{
    new() => todo()
    new(capacity int) => todo()
    new(items ICollection<T>) => todo()
    
    pub this[index int] T { get => todo() set => todo() }
    pub this[index Range] IArray<T> => todo()

    pub prop Count int => todo()
    pub func Add(item T) => todo()
    pub func Clear() => todo()
    pub func Insert(index int, item T) => todo()
    pub func Insert(index int, items ICollection<T>) => todo()
    pub func Remove(index int) => todo()
    pub func Remove(range Range) => todo()
    
}

pub class Map<TKey, TValue> 
    : IMap<TKey, TValue>
{
    compareFunc func(a TKey, b TKey) bool;
    hashFunc func(a TKey) bool;
    

    new() where TKey : IEquatable<TKey>
    {
        compareFunc = (a, b) -> TKey.Compare(a, b);
        hashFunc = (a) -> TKey.GetHashCode(a);		
    }
    new(compare func(a TKey, b TKey) bool, 
        getHashCode func(a TKey) uint)
    {
        compareFunc = compare;
        hashFunc = getHashCode;
    }
    new(capacity int) where TKey : IEquatable
        => todo()
    new(keyValues ICollection<KeyValuePair<TKey, TValue>>) => todo()
    
    pub this[key TKey] TValue { get => todo() set => todo() }
    pub operator in(a TKey) bool => todo()

    pub prop Count int => todo()
    pub func Clear() => todo()
    pub func Contains(key TKey) bool => todo()
    pub func Get(key TKey, defaultValue TValue) TValue => todo()
    pub func TryGet(key TKey, value out TValue) bool => todo()
    pub func Add(item KeyValue<TKey, TValue>) => todo()    
    pub func Add(items ICollection<KeyValue<TKey, TValue>>) => todo()    
    pub func Remove(TKey key) bool => todo()
    pub prop Keys ICollection<TKey> { get => todo() }
    pub prop Values ICollection<TValue> { get => todo() }
}