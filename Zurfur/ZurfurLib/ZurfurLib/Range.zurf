
module Zurfur

use Zurfur[Copy]
use Zurfur.Math[abs]
use Zurfur.Operators[NumOps]
use Zurfur.Collections[Iterator]


[pub]
type Range<T> copy where T has NumOps<T>
    low T pub ro init
    high T pub ro init

[pub]
fun Range<T>.new(low T, high T)
    my.low = low
    my.high = high
    (my.low, my.high) = (low, high) // TBD: Make this work


fun abs(i int) int
    return 3


// TBD: Shortcut syntax
type Abs<T> interface
    [static] fun abs(n T) T


// Absolute length of range: abs(high-low)
// TBD: Allow individual functions in the where clause
[pub]
fun get Range<T>.length() T where T has Abs<T> // TBD: fun abs(n T) T
    // Alternatively:
    //      return if(my.low <= my.high, my.low : my.high) 
    return abs(my.high-my.low)


[pub]
fun get Range<T>.iterator() RangeIterator<T>
    return RangeIterator<T>(my.low, my.high)
        

[pub]
type RangeIterator<T> where T has NumOps<T>
    current T pub init
    high T pub init

[pub]
fun RangeIterator<T>.new(low T, high T)
    (my.current, my.high) = (low, high)    


[pub]
fun mut RangeIterator<T>.next() ?T
    if my.current >= my.high
        return nil
    @r = my.current
    my.current += T.ONE
    return Nullable<T>(my.current)
        