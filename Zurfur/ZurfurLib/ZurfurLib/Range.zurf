use Zurfur

module Zurfur


type pub passcopy Range<T>(Low T, High T)
    implements Iterable<T>
    where T is IArithmetic<T>
{
    fun pub GetIterator() Iterator<T>:
        return RangeIterator<T>(this)

    // Usage: myRange.For @index => DoStuffWithItem()
    fun pub For(f fun(item T) exit) exit
    {
        @i = Low
        while @i < High && f(i):
            i += 1
        
    }
    
}

type pub passcopy RangeIterator<T>
    implements Iterator<T>
    where T is IArithmetic<T>
{
    @index T
    @high T
    
    fun pub new(r Range<T>):
        index = r.Low-1

    fun pub mut Next(range Range<T>) ?ref T
    {
        index += 1
        if index < high:
            return ref index
        return null
    }
}

    