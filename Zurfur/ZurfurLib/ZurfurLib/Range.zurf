
mod Zurfur

use Zurfur[Copy, Iterator, NumOps]
use Zurfur.Math[abs]

[pub]
type Range<T> copy
        where T has NumOps<T>
    low T pub ref init
    high T pub ref init

[pub]
fun Range.new(low My.T, high My.T)
    my.low = low
    my.high = high
    // TBD: (my.low, my.high) = (low, high)

fun abs(i int) int
    return 3

// TBD: Shortcut syntax
type Abs<T> interface
    [static] fun abs(n T) T

// Absolute length of range: abs(high-low)
// TBD: Allow individual functions in the where clause
[pub]
fun get Range.length() My.T
        where My.T has Abs<My.T> + NumOps<My.T> // TBD: Use constraints from `Range`, ALSO: fun abs(n T) T 
    // Alternatively:
    //      return if(my.low <= my.high, my.low : my.high) 
    return My.T.abs(my.high-my.low)

[pub]
fun get Range.iterator() RangeIterator<My.T>
    return RangeIterator<My.T>(my.low, my.high)
        
[pub]
type RangeIterator<T> where T has NumOps<T>
    current T pub init
    high T pub init

[pub]
fun RangeIterator.new(low My.T, high My.T)
    // TBD: (my.current, my.high) = (low, high)
    my.current = low
    my.high = high

[pub]
fun mut RangeIterator.next() ?My.T
        where My.T has Abs<My.T> + NumOps<My.T>
    if my.current >= my.high
        return nil
    @r = my.current
    my.current += My.T.One
    return Nilable<My.T>(my.current)
        