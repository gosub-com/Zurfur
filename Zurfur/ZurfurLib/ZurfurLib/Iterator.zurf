
module Zurfur.Collections

// Implement on containers
interface pub GetIterator<Item>
    fun pub getIterator() Iterator<Item> impl
// TBD: impl pass throughs for all Iterator<T> functions.
//      Use count hint here?



// Implement on containers with a known count
interface pub Collection<Item>
    where Item is GetIterator<Item>
    get pub count() int impl


// Implement this on all iterators
// TBD: `Item` should be an associated type, like in Rust
interface pub Iterator<Item>

    // TBD: Need associated types:
    //type Item


    // Return the next item, or null if it doesn't exist
    fun pub mut next() ?mut ref Item impl
    
    fun pub countHint() int impl // TBD: Default

// Implement this when the container has a known size.
// List uses this as the starting capacity.
get pub (i Iterator<Item>) countHint() int
    return 0

fun pub mut (i Iterator<Item>) toArrayXM() Array<Item>
    return toList().toArray()

fun pub mut (i Iterator<Item>) toList() List<Item>
    @list = List(countHint)
    while next()@item
        list.push(item)
    return list

// TBD: Item should be an associated type,
//      not explicitly passed back from filter
//      This should work exactly thr same as the `filter` method
fun pub mut (i Iterator<Item>) filter(f fun(item Item) bool) FilterIterator<This, Item>
    return FilterIterator<This, Item>(this, f)

fun pub mut (i Iterator<Item>) find(f fun(item Item) bool) ?mut ref Item
    while next()@item
        if f(item)
            return ref item
    return null

//   TBD: Unify extension method here
fun pub mut (i Iterator<Item>) toArrayXE() Array<Item>
    return toList().toArray()

        
// TBD: Item should be an associated type (not passed in here)
type ref FilterIterator<I, Item>
    // TBD: Needed?
    where I is Iterator<Item>

    // Note: The `init` attribute creates a constructor taking
    //       named parameters FilterIterator<T>(iter: v1, f: v2).
    
    @iter ref I pub init
    @f ref fun(item Item) bool pub init

// TBD: There should be shortcut syntax to create
//      a positional constructor, like this:
// fun new(iter _, f _) {}
//
// Instead of this:
fun (f FilterIterator<I, Item>) new(iter mut I, fn fun(item Item)bool)
    this.iter = ref iter
    this.f = ref f

// TBD: This does not implement the interface
fun pub (f mut FilterIterator<I, Item>) next() ?mut ref I
    return iter.find(f)
        
        

// TBD: Check for same symbol name as 'new' method
fun (f FilterIterator<I,Item>) new()
    todo

fun test_Filter() Array<int>
    @listIn = [1,2,3,4,5]
    return listIn.filter(@n => n in 2..5).toArray()
    
    
    