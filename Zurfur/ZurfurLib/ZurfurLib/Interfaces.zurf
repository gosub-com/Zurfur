
namespace Zurfur.Collections;

/// Implement IEquatable on any object that can be stored in a Map.
/// This is different than implementing just Equals
/// in that NAN must compare to itself as true.
pub static interface IEquatable<T>
{
    static fun GetHashCode(a T) uint => impl
    static fun Equals(a T, b T) bool => impl
}

/// Implement IComparable on any object that can be sorted.
/// This is different than implementing just Compare
/// in that NAN must have a valid sort order.
pub static interface IComparable<T>
    implements IEquatable<T>
{
    static fun Compare(a T, b T) int  => impl
}

pub static interface IArithmetic<T>
    implements IComparable<T>
{
    fun operator-(a T) T => impl
    fun operator-(a T, b T) T => impl
    fun operator+(a T, b T) T => impl
    fun operator*(a T, b T) T => impl
    fun operator/(a T, b T) T => impl
    fun operator%(a T, b T) T => impl
    static prop Identity T => impl get
    static prop Origin T => impl get
}

pub interface IEnumerable<out T>
{
    fun GetEnumerator() IEnumerator<T> => impl
}

/// This is the only function needed for standard iterators
pub interface IEnumerator<T>
{
    fun mut GetNext(item ref T) bool => impl
}

pub interface ICollection<T>
    implements IEnumerable<T>
{
    prop Count int => impl get
}

/// This should only be defined for simple types
/// that get inlined, such as int, Range, etc..
/// Otherwise, only define IEnumerator
pub interface IFastEnumerator<T>
    implements IEnumerator<T>
{
    fun HasNext() bool => impl
    prop Current T => impl get

    fun mut Advance() => impl
    
    fun mut GetNext(item ref T) bool
    {
        if HasNext()
        {
            item = Current;
            Advance()
            return true
        }
        return false
    }
}


pub interface IArray<T> 
    implements ICollection<T>
{
    fun operator[](index int) T => impl get set
}


pub interface IList<T>
    implements IArray<T>
{
    fun operator[](index int) T => impl get set
    fun mut Insert(index int, item T) => impl
    fun mut Insert(index int, collection ICollection<T>) => impl
    fun mut Remove(index int) => impl
    fun mut Remove(range Range<int>) => impl
    
    fun mut Clear() { Remove(0..Count) }
    fun mut Add(item T) { Insert(Count, item) }
    fun mut Add(items ICollection<T>) { Insert(Count, items) }
    fun mut Pop() { var item = this[Count-1]; Remove(Count-1);  return item }    
}

pub struct KeyValuePair<TKey, TValue>
{
    pub var Key TKey
    pub var Value TValue

    pub fun new(key TKey, value TValue) { Key = key; Value = value }
}

pub interface IMap<TKey, TValue>
    implements ICollection<KeyValuePair<TKey, TValue>>
{
    fun operator in(a TKey) bool => impl
    fun operator[](key TKey) TValue => impl get set
    fun Contains(key TKey) bool => impl
    fun Get(key TKey, defaultValue TValue) TValue => impl
    fun TryGet(key TKey, value out TValue) bool => impl
    prop Keys ICollection<TKey> => impl get
    prop Values ICollection<TValue> => impl get
    fun mut Remove(TKey key) bool => impl
}

/// This is a test
pub interface IGeneric<Q>
{
    fun A<T>(Q m) int => test()
}

// Test generic class
pub class MyGeneric<QQ>
    implements IGeneric<QQ>
{
    pub fun IGeneric<QQ>::A<T>(QQ a) int { }
}

/// Compiler implemented interface created for all structs that are blittable.
/// A blittable struct does not contain references, but may contain pointers.
pub interface IBlittableStruct { }