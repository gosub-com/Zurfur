
namespace Zurfur

/// Implement IEquatable on any object that can be stored in a Map.
/// This is different than implementing just Equals
/// in that NAN must compare to itself as true.
pub noself interface Equatable<T>
{
    noself fun GetHashCode(a T) uint youdo
    noself fun Equals(a T, b T) bool youdo
}

/// Implement IComparable on any object that can be sorted.
/// This is different than implementing just Compare
/// in that NAN must have a valid sort order.
pub noself interface Comparable<T>
    implements Equatable<T>
{
    noself fun Compare(a T, b T) int youdo
}

pub noself interface IArithmetic<T>
    implements Comparable<T>
{
    fun operator-(a T) T youdo
    fun operator-(a T, b T) T youdo
    fun operator+(a T, b T) T youdo
    fun operator*(a T, b T) T youdo
    fun operator/(a T, b T) T youdo
    fun operator%(a T, b T) T youdo
    noself prop Identity T youdo get
    noself prop Origin T youdo get
}

pub interface Collection<T>
    implements Iterable<T>
{
    prop Count int youdo get
    fun GetIterator() Iterator<T> youdo
}


pub interface Iterable<T>
{
    fun GetIterator() Iterator<T> youdo
}

pub interface Iterator<T>
{
    /// Get the next item from a collection.
    /// Returns null if there are no more items.
    /// Panic if collection is mutated while iterating.
    fun mut Next() ?ref T youdo
}


pub type Pair<TKey, TValue>(Key TKey, Value TValue)


/// This is a test
pub interface IGeneric<Q>
{
    fun A<T>(m Q) int
        return 0
}

// Test generic type
pub type MyGeneric<QQ>
    implements IGeneric<QQ>
{
    pub fun IGeneric<QQ>.A<T>(a QQ) int { }
}

/// Compiler implemented interface created for all structs that are blittable.
/// A blittable struct does not contain references, but may contain pointers.
pub interface IBlittableStruct { }