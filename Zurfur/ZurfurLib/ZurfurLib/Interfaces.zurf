
namespace Zurfur.Collections;

/// Implement IEquatable on any object that can be stored in a Map.
/// This is different than implementing just Equals
/// in that NAN must compare to itself as true.
pub interface IEquatable<T>
{
    // TBD: These functions are `ro` including all in the base class
    static func GetHashCode(a T) uint => youdo
    static func Equals(a T, b T) bool => youdo
}

/// Implement IComparable on any object that can be sorted.
/// This is different than implementing just Compare
/// in that NAN must have a valid sort order.
pub interface IComparable<T>
    : IEquatable<T>
{
    static func Compare(a T, b T) int  => youdo
}

pub interface IArithmetic<T>
    : IComparable<T>
{
    operator-(a T) T => youdo
    operator-(a T, b T) T => youdo
    operator+(a T, b T) T => youdo
    operator*(a T, b T) T => youdo
    operator/(a T, b T) T => youdo
    operator%(a T, b T) T => youdo
    static prop Identity T => youdo get
    static prop Origin T => youdo get
}

pub interface IEnumerator<out T>
{
    func MoveNext() bool => youdo
    prop Current T => youdo get
}

pub interface IEnumerable<out T>
{
    func GetEnumerator() IEnumerator<T> => youdo
}

/// Base class for all collections.
/// Collections are immutable until proven otherwise.
pub interface ICollection<T>
    : IEnumerable<T>
{
    prop Count int => youdo get
}

/// Base class for all mutable collections.
pub interface IMutableCollection<T>
    : ICollection<T>
{
    func Clear() => youdo
    func Add(item T) => youdo
    func Add(items ICollection<T>) => youdo
    // NOTE: 'Remove' and 'Contains' are not included because
    //		each collection may have a different idea about
    //	    how to compare and find objects.  
    //		TBD: Consider adding them back in.  With constraint?
    //		func RemoveObject(item T) where T : IEquatable
}

pub interface IRoArray<T> 
    : ICollection<T>
{
    this[index int] T => youdo get
}


pub interface IArray<T> 
    : ICollection<T>
{
    this[index int] T => youdo get set
    this[range Range] IArray => todo()
}

pub interface IList<T>
    : IMutableCollection<T>, IArray<T>, IRoArray<T>
{
    func Insert(index int, item T) => youdo
    func Insert(index int, collection ICollection<T>) => youdo
    func Remove(index int) => youdo
    func Remove(range Range) => youdo

    pub func Add(item T) { Insert(Count, item) }
    pub func Add(items ICollection<T>) { Insert(Count, items) }
}

pub struct KeyValuePair<TKey, TValue>
{
    pub new(key TKey, value TValue) { Key = key; Value = value }
    pub Key TKey
    pub Value TValue
}

pub interface IRoMap<TKey, TValue>
    : ICollection<KeyValuePair<TKey, TValue>>
{
    operator in(a TKey) bool => youdo
    this[key TKey] TValue => youdo get
    pub func Contains(key TKey) bool => youdo
    func Get(key TKey, defaultValue TValue) TValue => youdo
    func TryGet(key TKey, value out TValue) bool => youdo
    prop Keys ICollection<TKey> => youdo get
    prop Values ICollection<TValue> => youdo get
}

pub interface IMap<TKey, TValue> 
    : IRoMap<KeyValuePair<TKey, TValue>>,
      IMutableCollection<KeyValuePair<TKey, TValue>>
            
{
    this[key TKey] TValue => youdo get set
    func Remove(TKey key) bool => youdo
}

/// This is a test
pub interface IGeneric<Q>
{
    func A<T>(Q m) int => test()
}

// Test generic class
pub class MyGeneric<QQ> : IGeneric<QQ>
{
    pub func IGeneric<QQ>::A<T>(QQ a) int { }
}

/// Compiler implemented interface created for all structs that are blittable.
/// A blittable struct does not contain references, but may contain pointers.
pub interface IBlittableStruct { }