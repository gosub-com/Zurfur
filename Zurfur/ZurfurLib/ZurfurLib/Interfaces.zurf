
namespace Zurfur.Collections;


pub interface IEnumerator<out T>
{
    func MoveNext() bool
    prop Current T { get }
}

pub interface IEnumerable<out T>
{
    func GetEnumerator() IEnumerator<T>;
}

pub interface ICollection<T>
    : IEnumerable<T>
{
    prop Count int { get }
    prop IsReadOnly bool { set }
}

pub interface IArray<T> 
    : ICollection<T>
{
    this[index int] T { get set }
    func Fill(f T);
}

pub interface IList<T>
    : IArray<T>
{
    func Clear();
    func Insert(index int, item T);
    func Insert(index int, collection ICollection<T>)
    func Remove(range Range);
    func Remove(index int);

    pub func Add(item T) { Insert(Count, item) }
    pub func Add(items collection<T>) { Insert(Count, items) }
}

pub struct KeyValuePair<TKey, TValue>
{
    pub new(key TKey, value TValue) { Key = key; Value = value }
    pub Key TKey;
    pub Value TValue;
}


pub interface IMap<TKey, TValue> 
    : ICollection<KeyValuePair<TKey, TValue>>
{
    this[key TKey] TValue { get set }
	operator in(a TKey) bool

    func Clear()
    func Get(key TKey, defaultValue TValue) TValue;
    func TryGet(key TKey, value out TValue) bool    
    func Add(keyValuesvs ICollection<KeyValue<TKey, TValue>>)
    func Remove(TKey key) bool
    prop Keys ICollection<TKey> { get }
    prop Values ICollection<TValue> { get }
}

/// Implement IHashable on any object that can be stored in a Map.
/// This is different than implementing just Equals
/// in that NAN must compare to itself as true.
pub interface IHashable<in T>
{
    static func GetHashCode(a T) uint;
    static func Equals(a T, b T) bool;
}

/// Implement ISortable on any object that can be sorted.
/// This is different than implementing just Compare
/// in that NAN must have a valid sort order.
pub interface ISortable<in T>
{
    static func Compare(a T, b T) int;
}

pub interface IGeneric<Q>
{
    func A<T>(Q m) int;
}

// Test generic class
pub class MyGeneric<QQ> : IGeneric<QQ>
{
    pub func IGeneric<QQ>::A<T>(QQ a) int { }
}

/// Compiler implemented interface created for all structs that are blittable.
/// A blittable struct does not contain references, but may contain pointers.
pub interface IBlittableStruct { }