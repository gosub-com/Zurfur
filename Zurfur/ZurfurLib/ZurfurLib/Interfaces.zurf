
// This defines interfaces for:
//      Zurfur.Markers
//      Zurfur.Operators
//      Zurfur.Collections

module Zurfur

module Zurfur.Markers



interface pub Copy { }

/// NOTE: The compiler automatically generates the 'Op'
///       interfaces if the 'op_' function is defined.
module Zurfur.Operators

// TBD: Is it OK to have nan==nan for floats?
// TBD: Is it OK to have nan ordered for floats?
//      -inf < MinValue < 0 < MaxValue < nan < inf

interface pub OpEq<Rhs> { fun op_eq(rhs Rhs) bool impl }
interface pub OpCmp<Rhs> where Rhs is OpEq<Rhs>
{ fun op_cmp(rhs Rhs) int impl }
interface pub OpIn<Rhs> { fun op_in(rhs Rhs) bool impl }

interface pub OpAdd<Rhs, Out> { fun op_add(rhs Rhs) Out impl }
interface pub OpSub<Rhs, Out> { fun op_sub(rhs Rhs) Out impl }
interface pub OpNeg<Out> { fun op_neg() Out impl }
interface pub OpMul<Rhs, Out> { fun op_mul(rhs Rhs) Out impl }
interface pub OpDiv<Rhs, Out> { fun op_div(rhs Rhs) Out impl }
interface pub OpRem<Rhs, Out> { fun op_rem(rhs Rhs) Out impl }

interface pub GetHash { fun getHash() int impl }
interface pub Drop { fun mut drop(flags int) impl }
interface pub Clone
{
    fun mut clone() This impl
}

// Common addition operations
interface pub AddOps
    where This is OpEq<This>
                + OpCmp<This>
                + OpAdd<This,This>
                + OpSub<This,This>
                + OpNeg<This>
{
    const MAX This
    const MIN This
    const ZERO This
    const ONE This
}

/// Common number operations
interface pub NumOps
    where This is AddOps
                + OpMul<This,This>
                + OpDiv<This,This>
                + OpRem<This,This>
{
}


module Zurfur.Collections


interface pub Iterator<Item>
{
    /// Return the next item, or null if it doesn't exist
    fun mut next() ?Item impl

    /// Implement this so 
    get pub countHint() int { return 0 }
}

interface pub GetIterator<T>
{
    fun getIterator() Iterator<T> impl
}

interface Collection<Item>
{
    get count() int impl
}