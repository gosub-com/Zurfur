
namespace Zurfur.Collections;

/// Implement IEquatable on any object that can be stored in a Map.
/// This is different than implementing just Equals
/// in that NAN must compare to itself as true.
pub interface IEquatable<T>
{
    static func GetHashCode(a T) uint;
    static func Equals(a T, b T) bool;
}

/// Implement IComparable on any object that can be sorted.
/// This is different than implementing just Compare
/// in that NAN must have a valid sort order.
pub interface IComparable<T>
	: IEquatable<T>
{
    static func Compare(a T, b T) int;
}

pub interface IArithmetic<T>
	: IComparable<T>
{
	operator-(a T) T;
	operator-(a T, b T) T;
	operator+(a T, b T) T;
	operator*(a T, b T) T;
	operator/(a T, b T) T;
	operator%(a T, b T) T;
	static prop Identity T { get }
	static prop Origin T { get }
}

pub interface IEnumerator<out T>
{
    func MoveNext() bool
    prop Current T { get }
}

pub interface IEnumerable<out T>
{
    func GetEnumerator() IEnumerator<T>;
}

/// Base class for all collections.
/// Collections are immutable until proven otherwise.
pub interface ICollection<T>
    : IEnumerable<T>
{
    prop Count int { get }
}

/// Base class for all mutable collections.
pub interface IMutableCollection<T>
	: ICollection<T>
{
	func Clear()
	func Add(item T)
	func Add(items ICollection<T>)
	// NOTE: 'Remove' and 'Contains' are not included because
	//		each collection may have a different idea about
	//	    how to compare and find objects.  
	//		TBD: Consider adding them back in.  With constraint?
	//		func RemoveObject(item T) where T : IEquatable
}

pub interface IRoArray<T> 
    : ICollection<T>
{
    this[index int] T { get }
}


pub interface IArray<T> 
    : ICollection<T>
{
    this[index int] T { get set }
}

pub interface IList<T>
    : IMutableCollection<T>, IArray<T>, IRoArray<T>
{
    func Insert(index int, item T);
    func Insert(index int, collection ICollection<T>)
    func Remove(index int);
    func Remove(range Range);

    pub func Add(item T) { InsertAt(Count, item) }
    pub func Add(items ICollection<T>) { InsertAt(Count, items) }
}

pub struct KeyValuePair<TKey, TValue>
{
    pub new(key TKey, value TValue) { Key = key; Value = value }
    pub Key TKey;
    pub Value TValue;
}

pub interface IRoMap<TKey, TValue>
	: ICollection<KeyValuePair<TKey, TValue>>
{
	operator in(a TKey) bool
    this[key TKey] TValue { get }
    pub func Contains(key TKey) bool => todo();    
    func Get(key TKey, defaultValue TValue) TValue;
    func TryGet(key TKey, value out TValue) bool    
    prop Keys ICollection<TKey> { get }
    prop Values ICollection<TValue> { get }
}

pub interface IMap<TKey, TValue> 
    : IRoMap<KeyValuePair<TKey, TValue>>,
      IMutableCollection<KeyValuePair<TKey, TValue>>
    		
{
    this[key TKey] TValue { set }
    func Remove(TKey key) bool
}

pub interface IGeneric<Q>
{
    func A<T>(Q m) int;
}

// Test generic class
pub class MyGeneric<QQ> : IGeneric<QQ>
{
    pub func IGeneric<QQ>::A<T>(QQ a) int { }
}

/// Compiler implemented interface created for all structs that are blittable.
/// A blittable struct does not contain references, but may contain pointers.
pub interface IBlittableStruct { }