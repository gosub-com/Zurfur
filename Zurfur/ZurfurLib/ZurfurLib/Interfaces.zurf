
// This defines interfaces for:
//      Zurfur.Markers
//      Zurfur.Operators
//      Zurfur.Collections

module Zurfur

module Zurfur.Markers



pub interface Copy { }

/// NOTE: The compiler automatically generates the 'Op'
///       interfaces if the 'op_' function is defined.
module Zurfur.Operators

// TBD: Is it OK to have nan==nan for floats?
// TBD: Is it OK to have nan ordered for floats?
//      -inf < MinValue < 0 < MaxValue < nan < inf

pub interface OpEq<Rhs> { fun op_eq(rhs Rhs) bool impl }

pub interface OpCmp<Rhs>
    where Rhs is OpEq<Rhs>
    fun op_cmp(rhs Rhs) int impl

pub interface OpIn<Rhs> { fun op_in(rhs Rhs) bool impl }
pub interface OpAdd<Rhs, Out> { fun op_add(rhs Rhs) Out impl }
pub interface OpSub<Rhs, Out> { fun op_sub(rhs Rhs) Out impl }
pub interface OpNeg<Out> { fun op_neg() Out impl }
pub interface OpMul<Rhs, Out> { fun op_mul(rhs Rhs) Out impl }
pub interface OpDiv<Rhs, Out> { fun op_div(rhs Rhs) Out impl }
pub interface OpRem<Rhs, Out> { fun op_rem(rhs Rhs) Out impl }

pub interface GetHash { fun getHash() int impl }
pub interface Drop { fun mut drop(flags int) impl }
pub interface Clone
    fun mut clone() This impl

// Common addition operations
pub interface AddOps
    where This is OpEq<This>
                + OpCmp<This>
                + OpAdd<This,This>
                + OpSub<This,This>
                + OpNeg<This>
    const MAX This
    const MIN This
    const ZERO This
    const ONE This

/// Common number operations
pub interface NumOps
    where This is AddOps
                + OpMul<This,This>
                + OpDiv<This,This>
                + OpRem<This,This>
{
}


module Zurfur.Collections


pub interface Iterator<Item>

    /// Return the next item, or null if it doesn't exist
    fun mut next() ?Item impl

    /// Implement this so 
    pub get countHint() int
        return 0

pub interface GetIterator<T>
    fun getIterator() Iterator<T> impl


interface Collection<Item>
    get count() int impl