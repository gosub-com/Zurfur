
namespace Zurfur.Collections;


pub interface IEnumerator<out T>
{
    // NOTE: Do not need to implement Reset() or Dispose()
    func MoveNext();
    prop Current T { get; }
}

pub interface IEnumerable<out T>
{
    func GetEnumerator() IEnumerator<T>;
}

pub interface ICollection<T>
    : IEnumerable<T>
{
    prop Count int { get; }
    prop IsReadOnly bool { set; }
    func Add(item T);
    func Clear();
    func Contains(item T) bool;
    func CopyTo(array []T, arrayIndex int);
    func Remove(item T) bool;
}

pub interface IList<T>
    : ICollection<T>
{
    this[int index] T { get; set; }
    func Insert(int index, T item);
    func RemoveAt(int index);
    func IndexOf(T item) int;
}

pub struct KeyValuePair<TKey, TValue>
{
    pub new(TKey key, TValue value) { todo() };
    pub prop Key TKey => todo();
    pub prop Value TValue => todo();
}


pub interface IDictionary<TKey, TValue> 
    : ICollection<KeyValuePair<TKey, TValue>>, 
               IEnumerable<KeyValuePair<TKey, TValue>>
{
    this[key TKey] TValue { get; set; }
    this[key TKey, defaultValue TValue] TValue { get; }
    
    prop Keys ICollection<TKey> { get; }
    prop Values ICollection<TValue> { get; }
    func Add(key TKey, value TValue);
    func ContainsKey(TKey key) bool;
    func Remove(TKey key) bool;
    func TryGet(key TKey, value out TValue) bool;
}

/// Implement IHashable on any object that can be stored in a Map.
/// This is different than implementing just Equals
/// in that NAN must compare to itself as true.
pub interface IHashable<in T>
{
    static func GetHashCode(a T) uint;
    static func Equals(a T, b T) bool;
}

/// Implement ISortable on any object that can be sorted.
/// This is different than implementing just Compare
/// in that NAN must have a valid sort order.
pub interface ISortable<in T>
{
    static func Compare(a T, b T) int;
}

pub interface IGeneric<Q>
{
    func A<T>(Q m) int;
}

// Test generic class
pub class MyGeneric<QQ> : IGeneric<QQ>
{
    pub func IGeneric<QQ>::A<T>(QQ a) int { }
}

/// Compiler implemented interface created for all structs that are blittable.
/// A blittable struct does not contain references, but may contain pointers.
pub interface IBlittableStruct { }