
// This defines interfaces for:
//      Zurfur.Markers
//      Zurfur.Operators
//      Zurfur.Collections

module Zurfur

type This {}

module Zurfur.Markers



interface pub Copy { }

module Zurfur.Operators

// Define individual operators

/// TBD: Is it OK to have nan==nan for floats?
interface pub OpEquals<Rhs> { fun equals(rhs Rhs) bool impl }

/// TBD: Is it OK to have nan ordered for floats?
///      -inf < MinValue < 0 < MaxValue < nan < inf
interface pub OpCompare<Rhs> impl OpEquals<Rhs>
{ fun compare(rhs Rhs) int impl }

interface pub OpContains<Lhs> { fun contains(rhs Lhs) bool impl }
interface pub OpAdd<Rhs, Out> { fun add(rhs Rhs) Out impl }
interface pub OpSub<Rhs, Out> { fun sub(rhs Rhs) Out impl }
interface pub OpNeg<Out> { fun neg() Out impl }
interface pub OpMul<Rhs, Out> { fun mul(rhs Rhs) Out impl }
interface pub OpDiv<Rhs, Out> { fun div(rhs Rhs) Out impl }
interface pub OpRem<Rhs, Out> { fun rem(rhs Rhs) Out impl }
interface pub OpIndex<I, Out> { fun index(i I) Out impl }
interface pub OpIndex2<I1, I2, Out> { fun index(i1 I1, i2 I2) Out impl }
interface pub OpIndex3<I1, I2, I3, Out> { fun index(i1 I1, i2 I2, i3 I3) Out impl }
interface pub OpIndex4<I1, I2, I3, I4, Out> { fun index(i1 I1, i2 I2, i3 I3, i4 I4) Out impl }
interface pub GetHash { fun getHash() int impl }
interface pub Drop { fun mut drop(flags int) impl }
interface pub Clone
{
    fun mut clone() This impl
}

/// Define the standard associative math operators operators
interface pub NumOps impl OpEquals<This,This>, OpCompare<This,This>,
                            OpAdd<This,This>, OpSub<This,This>,
                            OpNeg<This>, OpMul<This,This>,
                            OpDiv<This,This>, OpRem<This,This>
{
    const MaxValue This
    const MinValue This
    const Zero This
    const One This
}


module Zurfur.Collections


interface pub Iterator<Item>
{
    /// Return the next item, or null if it doesn't exist
    fun mut next() ?Item impl

    /// Implement this so 
    get pub countHint() int { return 0 }
}

interface pub GetIterator<T>
{
    fun getIterator() Iterator<T> impl
}

interface Collection<Item>
{
    get count() int impl
}
