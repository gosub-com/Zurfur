
namespace Zurfur.Collections;


pub interface IEnumerator<out T>
{
    func MoveNext() bool
    prop Current T { get }
}

pub interface IEnumerable<out T>
{
    func GetEnumerator() IEnumerator<T>;
}

/// Base class for all collections
pub interface ICollection<T>
    : IEnumerable<T>
{
    prop Count int { get }
}

/// Base class for all mutable collections
pub interface IMutableCollection<T>
	: ICollection<T>
{
	func Clear()
	func Add(item T)
	func Add(items ICollection<T>)
	func Remove(item T)
}

pub interface IRoArray<T> 
    : ICollection<T>
{
    this[index int] T { get }
}


pub interface IArray<T> 
    : ICollection<T>
{
    this[index int] T { get set }
}

pub interface IList<T>
    : IMutableCollection<T>, IArray<T>, IRoArray<T>
{
    func InsertAt(index int, item T);
    func InsertAt(index int, collection ICollection<T>)
    func RemoveAt(index int);
    func RemoveAt(range Range);

    pub func Add(item T) { InsertAt(Count, item) }
    pub func Add(items ICollection<T>) { InsertAt(Count, items) }
}

pub struct KeyValuePair<TKey, TValue>
{
    pub new(key TKey, value TValue) { Key = key; Value = value }
    pub Key TKey;
    pub Value TValue;
}

pub interface IRoMap<TKey, TValue>
	: ICollection<KeyValuePair<TKey, TValue>>
{
	operator in(a TKey) bool
    this[key TKey] TValue { get }

    func Get(key TKey, defaultValue TValue) TValue;
    func TryGet(key TKey, value out TValue) bool    
    prop Keys ICollection<TKey> { get }
    prop Values ICollection<TValue> { get }
}

pub interface IMap<TKey, TValue> 
    : IRoMap<KeyValuePair<TKey, TValue>>,
      IMutableCollection<KeyValuePair<TKey, TValue>>
    		
{
    this[key TKey] TValue { set }
    func Remove(TKey key) bool
}

/// Implement IHashable on any object that can be stored in a Map.
/// This is different than implementing just Equals
/// in that NAN must compare to itself as true.
pub interface IHashable<in T>
{
    static func GetHashCode(a T) uint;
    static func Equals(a T, b T) bool;
}

/// Implement ISortable on any object that can be sorted.
/// This is different than implementing just Compare
/// in that NAN must have a valid sort order.
pub interface ISortable<in T>
{
    static func Compare(a T, b T) int;
}

pub interface IGeneric<Q>
{
    func A<T>(Q m) int;
}

// Test generic class
pub class MyGeneric<QQ> : IGeneric<QQ>
{
    pub func IGeneric<QQ>::A<T>(QQ a) int { }
}

/// Compiler implemented interface created for all structs that are blittable.
/// A blittable struct does not contain references, but may contain pointers.
pub interface IBlittableStruct { }