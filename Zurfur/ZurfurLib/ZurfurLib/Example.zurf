pragma ShowParse        // Show the parse tree (hover over a symbol)
//pragma ShowMeta       // Show parser symbols
//pragma NoParse

// Press F4 to see header file report


use Zurfur

// http://zurfur.com
module TestExample

// Get this to work
type Point(X int, Y int)
get Point<T>::Size() Point<T> { return Point(X, Y) }


// Simple types, fields are public:
pub type SimpleType(FirstName str, LastName str)
pub type ro SimpleImmutableType(FirstName str, LastName str)

pub type ComplexType
{
    // Fields are private (the last two have public properties)
    @map Map<str,int> = ["A":1, "B":2]  // Private, read/write
    @list ro List<int> = [1,2,3]        // Private, read only
    @Header str pub ro = "Zurfur"  // Private with public read
    @Text str pub mut = "fun"      // Public read and write

    // Properties are public by default
    get MapProperty() ref Map<str, int>:
        return ref map // Return a read only reference
    set MapProperty(v own Map<str, int>):
        map = v
        MapChangedEvent()

    /// Public function.  This is a public comment.
    pub fun CountToTen() str:
        Log.Info("Hello world.  Let's count to 10.")
        for @a in 1..11:
            Log.info("Count={a}, Text={text}")
}



fun test_HelloWorld():
    while a == 3:
        doit()
        doit2()
    Console.Log("Hello World.  Let's count from 1 to 10.")
    for @a in 1..11:
        doita
        doitb
        while a == 3:
            doit1
            doit2
        hello
        if a:
            doit4
            

pub type boxed AGenericType<Q>(FirstName str, LastName str)
{
    pub fun Circle1(a f64, r f64) -> (x f64, y f64):
        return Cos(a)*r, Sin(a)*r

    pub fun Circle2(a int, r int) int:
        return Cos(a)*r, Sin(a)*r


    pub fun Circle3(a f64, r f64) -> (x f64, y f64):
        return Cos(a)*r, Sin(a)*r

    pub fun MyVoid1():
        return 0

    pub fun MyVoid2() int:
        return 0
       
}


pub fun Circle3(a f64, b f64) -> (c int, d int):
    return 0

// https://stackoverflow.com/questions/1825952/how-to-create-a-generic-extension-method
pub fun Iterable<T>::AlphaLengthWise<T, L>(
               lengthProvider fun(t T) L) Iterable<T>:
    return this
        .OrderBy(@a => lengthProvider(a))
        .ThenBy(@a => a)

    F(t).AW(T,L).q

pub type Example
{
    pub get MyConst() str:
        return "Hello"
    
    @a1 str
    @a2 str = "Hello"
    @a3 List<str> = ["Hello", "World"]
    @a4 List<int> = [1,2]
    @a5 List<int> pub get
    @a6 List<int> pub mut
    @a7 List<int> pub get set
    //pub a8 List<int>
    //pub a9 private set List<int>
    //pub private set a9 List<int>

    @map1 ro Map<str,int> = ["A":1,"B":2]        // Immutable map
    @map2 ro mut Map<str,int> = ["A":1,"B":2]    // Can't be assigned, can be mutated
    @map3 ro Map<str,int> pub init               // Read only, init in constructor or allow public init
    

    pub fun GetInfo(a int) str:
        return info+a
    pub fun GetInfo(a str) str:
        return a
    pub get Info() str:
        return info

    @a Zim<void>
    @b Zim<object>
    @c Zim<i8>
    @e Zim<byte>
    @f Zim<i16>
    @g Zim<u16>
    @h Zim<i32>
    @i Zim<u32>
    @j Zim<int>
    @m Zim<f64>
    @n Zim<f32>
    @o Zim<str>
    @p Zim<Decimal>
    
}

pub type Zim<T>
{
    @q T pub get set
}


/// This is a public documentation comment.  Do not use XML.
/// Use `name` to refer to variables in the code.
pub fun test_Main(args Array<str>)
{
    test_compose()

    // This is a regular private comment
    Log.Info("Hello World, 2+2={2+2}")

    @v = ""

    if myString[32]@q == "x":
        v = "x"
    elif q == "y"  || q=="z":
        v = "y or z"
    elif q >= "a" || q <= "z":
        v = "lower"
    elif q >= "A" || q <= "Z":
        v = "upper"
    else:
        v = "none"
    

    a = tr"Column 1{\t}Column 2{\rn}"
    data = "Name:{name}{\t}Occupation:{lastName}{\rn}"
    
    while stream.Read(buffer)@size != 0:
        @a = MyFun as Hello


    // AcceptMatch returns ?Token = (bool, Token)
    // @Token captures the token, leaving the bool
    if AcceptMatch("(")@Token
    {
        // We got a token
    }

    // list.For takes a lambda with one parameter
    // @item captures the lambda parameter
    @sum = 0
    list.For() @item =>
    {
        sum += item
    }

    return

    fun test_compose()
    {
        @squareTriple = compose(&square, &triple)
        Debug.Assert(squareTriple(2) == 36)
    
        for @v in 1..23:
            Log.Info("Count={v}")
    }

    /// Compose f(g(x))
    fun compose(f fun(x int) int,
                g fun(x int) int) fun(x int) int
    {
        return @x => f(g(x))
    }

    fun triple(x int) int:
        return x*3
    fun square(x int) int:
        return x*x
}

pub type Token(a str)

pub fun AcceptMatch(name str) ?Token:
    return name == "(" ? Token() : null

// Regular static function
pub fun add(a int, b int) int:
    return a + b

// Multiple returns
pub fun Circle(a f64, r f64) -> (x f64, y f64):
    return Cos(a)*r, Sin(a)*r


// Mutable point
pub type MyMutablePoint(X int, Y int)
{
    pub fun mut SetY(y int):
        Y = y
        
    pub get PropX() int:
        return x
    pub set PropX(value int):
        X = value
}


pub type PointXY<T>(X int, Y int)
    implements IArithmetic<T>
{
    pub fun operator+(a PointXY<T>, b PointXY<T>) PointXY<T>:
        return todo()
}

type MyStruct(a int)

pub fun Sort<T>(s mut Span<T>, lessThan fun(a T,b T)bool):
    // Simple selection sort
    for @i in s.Count-1:
        @lowElem = s[i]
        @lowIndex = i
        for @j in i+1..s.Count:
            if lessThan(s[j], lowElem):
                lowElem = s[j]
                lowIndex = j
        if lowIndex != i:
            s[lowIndex] = s[i]
            s[i] = lowElem


pub fun MemCopy(dest *void, source *void, length xint):
    @d = cast(xint)dest
    @s = cast(xint)source
    
    if length <= 0:
        return

    // Align `d` on i32
    while d & 3 != 0 && length != 0:
        dref(cast(*byte)d) = dref(cast(*byte)s)
        d+=1;  s+=1;  length-=1
    
    if s & 3 == 0:
        MemCopy32(cast(*void)d, cast(*void)s, length)
        return
    
    // Byte copy
    @end = d + length
    while end-d >= 4:
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
    while d != end:
        dref(cast(*byte)d) = dref(castx<*byte>(s)); d+=1; s+=1

pub fun MemCopy32(dest *void, source *void, length xint):
    @d = cast (xint)dest
    @s = cast (xint)source

    if length <= 0:
        return

    // Try 64 bit copy first
    @end = d + length
    if (d~s) & 4 == 0 && length >= 8:
        if d & 4 != 0
            { dref(cast(*i32)d) = dref(cast(*i32)s); d+=4; s+=4 }
        while end - d >= 8
            { dref(cast(*i64)d) = dref(cast(*i64)s); d+=8; s+=8 }
    while end-d >= 4:
        dref(cast(*i32)d) = dref(cast(*i32)s); d+=4; s+=4
    while d != end:
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1