using a.b.c
using system.gosub.p

namespace Zurfur.Example

pub class Example
{
	info str 					// Private string initialized to ""
    f1 Array<int>({1,2,3})      			// Initialized array
    f2 List<str>({"Hello", "World"})    	// Initialized list
    f3 Map<str,int>({{"A",1},{"B",2}})  	// Initialized map
    pub ro Header str("Zurfur") 			// Public read only string
    pub func Func(a int) str => Header+a	// Member function
    pub prop Prop str => Header + info  	// Property
}
pub func Example::MyExtension() => Func1(10) // Extension method

pub func Example::Extension() 
{ 
	for @a in 1..23
	{
		F(out @b, c)
		@a+24 = 23 // TBD: Fix @ expression target
		a + 55 = 23 // TBD: Fix 
	}
}

// Test class
pub class Example2
{ 
    // Todo List:
    //    .. operator doesn't need parameters at beginning or end
    //    Support for :: operator (start::count)
    //    Editor should always use spaces (or tabs, just pick one and be done)
    //    Editor should comment out blocks with CTRL-'/'
    //    Implement switch (doesn't use break)
    //    Switch statement

    // Fields initialized to zero, null, or "" for string
    f1 int			// Initialized to 0
    f2 float32		// Initialized to 0.0
    f3 str          // Initialized to "", not NULL
    
    // Fields initialized to null
    f4 Array<int>
    f5 Array<Array<int>> 
    f6 []int       // Same as Array<int>
    f7 Map<str,List<int>>
    f8 Pointer<int>
    f9 *int        // Same as Pointer<int>
    
    // Fields initialized via constructor
    f10 int(FuncReturnsInt())
    f11 Array<int>()          // Array, Count=0
    f12 Array<int>(32)        // Array, Count=32
    f13 Array<int>({1,2,3})   // Array initialized with 1, 2, 3
    f13 List<int>(32)         // Empty List, Capacity=32
    f14 Map<str,str>()  	// Empty map
    
    // Fields initialized via assignment
    f15 int = 32
    f16 int = FuncReturnsInt() >> 4
    f17 float32 = FuncReturnsFloat32orInt()
    f18 str = "Hello"
    f19 *int = GetIntPtr()			// Same as Pointer<int> = `GetIntPtr()`
    
    // Properties
    pub prop P1 int => 1
    pub prop P2 float =>  f1 + f2
    pub prop P3 int { get { return 3 } }
    pub prop P4 int = 3 { get set } // Initialized to 3
    pub prop P5 int(3) // Initializes p1 to 3
    {
        get { return p1 }
        set { p1 = value }
    }
    
    pub this[index i] int => i
    
    // Function
    func fun1(a int) float => f1 + f2 + a
    func func1(a int) { }
    func func2(a out str) bool {}
    func func4(a ref MyStruct) {}
    func func5(a [][]int) {} 
    func func5(a Array<Array<int>>) {}
    func func7(a List<int>) { }
    func func8(a out List<List<int>>) { }
    func func10(a Map<str,List<int>>) { }
    
    pub func Sort<T>(greaterThan func(a T, b T) bool) { }
    pub MyFieldFunc func(sender object, message str)


    pub func M<A,B>(a A, b B, c List<int>) List<int> {}
    
    func func8(a out List<List<int>>) { }
    func func8(a out MyList<int,x,y,z>){ }
    
    pub func Main(args Array<str>)
    {
        // Function calls vs parameter lists
        @a1 = MyType<a,b,c>()
        @a2 = MyType(a,b,c)()
        @a3 = List<List<int>>()
        @a4 = List(List(int))()
        @a5 = M<str,int.x<T>.y>.Hello2<x.x>()
        @a6 = M(str,int.x(T).y).Hello2(x.x)()     
        @a7 = f(f<a>())(a+b)

        // Casts
	    @a = #int(a+b+myFloat)*23+4        // Prefix, operator
	    @a = (a+b+myFloat).#(int)*23+4     // Postfix, operator
	    @a = cast int(a+b+myFloat)*23+4    // Prefix, keyword
	    @a = (a+b+myFloat).cast(int)*23+4  // Postfix, keyword
		@a = #List<Stuff>(yourStuff.SeeMyStuff).Add(Stuff())    // Prefix
		@a = yourStuff.SeeMyStuff.#(List<Stuff>).Add(Stuff())    // Postfix
		@a = yourStuff.SeeMyStuff.cast(List<Stuff>).Add(Stuff()) // Postfix
	    @b = #*int(myVoidPointer).*      // Prefix
	    @b = myVoidPointer.#(*int).*     // Postfix
        @c1 = #M<str,int.x<T>.y>.Hello2(A)
        @c2 = #M<str,int.x<T>.y>.Hello2<x.x>(A)
        @c3 = #List<int,y,z>(A)
        @a = #int(a+b+myFloat)
	    @a = #List<Stuff>(yourStuff.SeeMyStuff).Add(Stuff())
	    @a = (#List<Stuff>(yourStuff.SeeMyStuff)).Add(Stuff())
        @b = #*int(myVoidPointer).*
	    #List<Stuff>(yourStuff.SeeMyStuff)[23] = 4

        // Static assigments
        M<str>.Hello = 6
        M<str,int.x<T>.y>.Hello2 = f(1, 2, "Jeremy")
        M<str,int>.Hello2 = f(1, 2, (x, y) => x < y)
        
        @a = x>y
        if MyFieldFunc != null
            { MyFieldFunc(this, "hello") }

        @l1 = (a) => { return 23 }
        @l2 = (a) => 23
        list.Sort((a, b) => a < b)
        list.Sort((a, b) => { return a < b })

		// In operator
		if myStr in myMap || myIn in 1..23
		{
			DoSomething();
		}

        // Switch expressions
        @num = switch myConstant { 23 => a, 27 => b, default => 0}

        // Switch statement
		switch a
		{
		case 1:
            DoIt(1) // No break necessary, always breaks unless there are no statements                
		case 2: // Empty case does fall through
        case 3:
            DoIt2()
        default: doit3();
		}
		        
    }
}

pub struct MyPoint
{
	pub X int
	pub Y int
	pub override func ToStr() => "(" + X + "," + Y + ")"
}


pub enum MyEnum
{	
	A 			// A=0
	B; C		// B=1, C=2
	D = 23		// D=23
	E; F; G		// E=24, F=25, G=26
}


pub interface MyInterfaceTest
{
    func A() int;
    pub func B() int => A() + 1;
    protected func C() int;
    pub struct Astruct { pub int a; };
    pub enum Aenum { a; b; c};
    pub class Aclass { pub int a;  };
}

pub class MyClass1 : MyInterfaceTest
{
    pub func A() int => 3;
    pub func MyInterfaceTest::C() int => 3;

}


pub static func Sort<T>(s Span<T>, lessThan func(a T, b T) bool)
{
    // Simple selection sort
    for @i in s.Count-1
    {
        @lowElem = s[i]
        @lowIndex = i
        for @j in i+1..s.Count
        {
            if lessThan(s[j], lowElem)
            {
                lowElem = s[j]
                lowIndex = j
            }
        }
        if lowIndex != i
        {
            s[lowIndex] = s[i]
            s[i] = lowElem
        }
    }
}

pub ref struct Span<T>
{
    ro data ref T
    pub ro Count int
    pub this[index int] ref T => todo()
    pub this[index Range] Span<T> => todo(); // Slice
    pub prop Ro Span<T> => todo() // Covert to RoSpan (TBD: Implicit)
}

pub ref struct RoSpan<T>
{
    ro data ref T
    pub ro Count int
    pub this[index int] ro ref T => todo()
    pub this[index Range] RoSpan<T> => todo(); // Slice
    // TBD: implicit conversion to RoSpan?
}


// All variable sized objects must inherit from this class, must be sealed, and
// must call AllocateObject first thing in the constructor.  For efficiency,
// this class is unsafe and doesn't do any bounds checking.
// The inheriting class must be sealed (that's what sealed1 means)
pub unsafe sealed1 class VariableSizedObject<T>
{
    pub ro Count int

    // Must be called first thing from the constuctor, never called again
    protected unsafe static func AllocateObject(count int) { todo() }

    // Return a pointer to the Array
    // { return (T^)((^void)this + sizeof(this))}
    protected unsafe prop DataPointer *T => todo()
}


// Array of constant size
pub sealed class Array<T> 
	: VariableSizedObject<T>, IArray<T>
{
    const MaxSize int = int.MaxInt/2
    pub static ro Empty Array<T>()

    new(count int) => todo()
    new(items ICollection<T>) => todo()
    
    pub this[index int] ref T => todo()
    pub this[range Range] Span<T> => todo()
}

// Note that the List class has a ref return indexer, just like Array
pub class List<T> 
	: IList<T>
{
	new() => todo()
    new(capacity int) => todo()
    new(items ICollection<T>) => todo()
    
    // NOTE: Ref return satisfies both indexer get and set
    pub this[index int] ref T => todo()
    pub this[range Range] Span<T> => todo()

    // NOTE: `Add` not needed because of default implementation
    pub prop Count int { get }
    pub func Clear() => todo()
    pub func Insert(index int, item T) => todo()
    pub func Insert(index int, items ICollection<T>) => todo()
    pub func Remove(index int) => todo()
    pub func Remove(range Range) => todo()
    
}

pub class Map<TKey, TValue> 
	: IMap<TKey, TValue>
{
	comparer func(a TKey, b TKey) bool;
	getHashCOde func(a TKey, b TKey) bool;
	comparer IComparer;
	

    new() where TKey : IEquatable
    {
    	comparer = (a, b) => TKey.compare(a, b);
    	getHashCode = (a) => TKey.getHashCode(a);
    	comparer = TKey;
		
    }
    new(comparer IEquatable)
    {
    	comparer = this.comparer;
    }
    new(compare func(a TKey, b TKey) bool, 
    	getHashCode func(a TKey, b TKey) uint)
    {
    	comparer = compare;
    }
    new(capacity int) where TKey : IEquatable
    	=> todo()
    new(keyValues ICollection<KeyValuePair<TKey, TValue>>) => todo()
    
    pub this[key TKey] TValue { get => todo() set => todo() }
	pub operator in(a TKey) bool => todo()

    pub prop Count int { get }
    pub func Clear() => todo()
    pub func Contains(key TKey) bool => todo();    
    pub func Get(key TKey, defaultValue TValue) TValue => todo()
    pub func TryGet(key TKey, value out TValue) bool => todo()
    pub func Add(item KeyValue<TKey, TValue>) => todo()    
    pub func Add(items ICollection<KeyValue<TKey, TValue>>) => todo()    
    pub func Remove(TKey key) bool => todo()
    pub prop Keys ICollection<TKey> { get => todo() }
    pub prop Values ICollection<TValue> { get => todo() }
}

// The matrix class is used to implement square 2d arrays
pub sealed class Matrix2d<t> : VariableSizedObject<T>
{
    new(len1 int, len2 int) { todo() }	
    pub this[i1 int, i2 int] ref T => todo()
}

// Represents a buffer in un-managed memory.  This class can create and 
// own the memory, or it can be attached to an already existing buffer.
// The GC knows this class and deletes the memory when necessary.
pub sealed class UnmanagedMemory<T> : UnmanagedHande 
				where T : IBlittableStruct
{
    pub ro Memory *void
    pub ro Capacity int
    pub ro OwnedByGc bool
    count int
    
    pub prop Count int
    {
        get { todo() }
        set { todo() }
    }
        
    // Create the buffer, the GC owns it and deletes it when there are no more
    // references to this object.  Be careful that unmanaged code doesn't
    // hold a reference to the memory beyond the lifetime of this object
    new(count int) { todo() }
    new(count int, capacity int) { todo() }

    // Attach this object to a buffer allocated by unmanaged code.  
    // Lenght and Capacity are set automatically. Be sure that
    // unmanaged code doesn't delete the object while still in use.  
    unsafe new(data *void, sizeOfBufferInBytes int) { todo() }

    pub func CopyTo() { todo() }
}


// This is the base for all objects, struct and class alike.
pub class object
{
    pub virtual func GetType() { todo() }
    pub virtual func ToStr() { todo() }
}

// This is the base for all struct objects.
pub class StructObject
{
}

// This is the base for all class objects.  Its only field is
// the vtable pointer, so there is minimal overhead.  All class
// objects are allocated on the managed heap and are subject
// to garbage collection.
pub class ClassObject
{
    // The only member
    protected unsafe ro VT *void

    pub override func GetType() { todo() }
}

// Base class for all things that need to notify when they are garbage collected
pub class FinalizedNotify 
{
    protected func SetFinalizeNotifier(notifierQueue FinalizedNotifyQueue, token IntPtr, memoryPressure int) { todo() }
    protected func ClearFinalizeNotifier() { todo() }
}

pub class FinalizedNotifyQueue 
{
    pub prop Count int => todo()
    pub func Dequeue() IntPtr { todo() }
    pub afunc WaitQueueNotEmpty() { todo() }
}

pub static func MemCopy(dest *void, source *void, length xint)
{
	@to = #xint(dest)
	@from = #xint(source)
	
    if length <= 0
    {
        return
    }
    // Align `to` on int32
    while to & 3 != 0 && length != 0
    {
        #*byte(to).* = #*byte(from).*; to+=1; from+=1; length-=1
    }
    
    if from & 3 == 0
    {
        MemCopy32(#*void(to), #*void(from), length)
        return
    }
    
    // Byte copy
    @end = to + length
    while end-to >= 4
    {
        #*byte(to).* = #*byte(from).*; to+=1; from+=1
        #*byte(to).* = #*byte(from).*; to+=1; from+=1
        #*byte(to).* = #*byte(from).*; to+=1; from+=1
        #*byte(to).* = #*byte(from).*; to+=1; from+=1
    } 
    while to != end
    {
        #*byte(to).* = #*byte(from).*; to+=1; from+=1
    }
}

pub static func MemCopy32(dest *void, source *void, length xint)
{
	@to = #xint(dest)
	@from = #xint(source)

    if length <= 0
    {
        return
    }

    // Try 64 bit copy first
    @end = to + length
    if (to^from) & 4 == 0 && length >= 8
    {
        if to & 4 != 0
        {
            #*int32(to).* = #*int32(from).*; to+=4; from+=4
        }
        while end - to >= 8  
        {
            #*int64(to).* = #*int64(from).*; to+=8; from+=8
        }
    }
    while end-to >= 4
    {
        #*int32(to).* = #*int32(from).*; to+=4; from+=4
    }
    while to != end
    {
        #*byte(to).* = #*byte(from).*; to+=1; from+=1
    }
}

 