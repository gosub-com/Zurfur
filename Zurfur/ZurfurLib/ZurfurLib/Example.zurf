use a.b.c
use system.gosub.p


// http://zurfur.com
namespace Zurfur.Example

pub class Example
{
    var info str                    // Private string initialized to ""
    var f1 Array<int> = [1,2,3]             // Initialized array
    var f2 List<str> = ["Hello", "World"]   // Initialized list
    ro  f3 Map<str,int> = {"A":1, "B":2}    // Initialized immutable map
    pub ro Header str = "Zurfur"            // Public read only string
    pub func F(this, a int) str => Header+a // Public member function
    pub prop P str => Header + info         // Public property
}

/// Example class, a test of hover comments and `code` comments
pub class Example_x
{
    pub const CONST_FIELD int = 234
    pub var field1 f32
    pub var field2 int    
    pub prop Prop str => Header + info      // Property
    pub func A(this, a int, b int, c f32) f32 => a+1
    pub func A(this, a f32) f32 => a+1
    pub func B(this, a f32) f32 => a+1
    pub prop ChangedTime DateTime = DateTime.Now
        => default get private set
        
    pub func E()
    {
        const MY_CONST = 23
        var a = f(x)
        mut b = f(MY_CONST)
    }
    
}
pub func Example::MyExtension(this) => Func1(10) // Extension method


pub struct PointXY<T>
    implements IArithmetic<T>
    where f is IAritmetic<T>
{
    pub var x int
    pub var y int
    
    pub func operator+(a PointXY<T>, b PointXY<T>) PointXY<T> => todo()
}

pub func Example::Extension(this) 
{ 
    for a in 1..23
    {
        F(out var x, a)
        F(out mut y, a)
    }
    var i = 32
    mut j = 15
    mut k int = 64
}

// Test class
pub class Example2  // YES, errors working
{ 
    // Todo List:
    //    .. operator doesn't need parameters at beginning or end
    //    Support for :: operator (start::count)
    //    Editor should always use spaces (or tabs, just pick one and be done)
    //    Editor should comment out blocks with CTRL-'/'
    //    Implement switch (doesn't use break)
    //    Switch statement

    // Fields initialized to zero, null, or "" for string
    var f1 int          // Initialized to 0
    var f2 f32      // Initialized to 0.0
    var f3 str          // Initialized to "", not NULL
    
    // Fields initialized to null
    var f4 Array<int> = [1,2,3,4]
    var f5 Array<Array<int>> 
    var f7 Map<str,List<int>>
    var f8 Pointer<int>
    var f9 *int        // Same as Pointer<int>
    
    // Fields initialized via constructor
    var f10 int(FuncReturnsInt())
    var f11 Array<int>()            // Array, Count=0
    var f12 Array<int>(32)          // Array, Count=32
    var f13 Array<int>([1,2,3])     // Array initialized with 1, 2, 3
    var f13a List<int>(32)          // Empty List, Capacity=32
    var f14 Map<str,str>()          // Empty map
    
    // Fields initialized via assignment
    var f15 int = 32
    var f16 int = FuncReturnsInt() >> 4
    var f17 f32 = FuncReturnsf32orInt()
    var f18 str = "Hello"
    var f19 *int = GetIntPtr()      // Same as Pointer<int> = `GetIntPtr()`
    
    // Properties
    pub prop P1 int => 1
    pub prop P2 f32 =>  f1 + f2
    pub prop P3 int { get { return 3 } }
    pub prop P4 int = 3 => default get set // Initialized to 3
    pub prop P5 int(3) // Initializes p1 to 3
    {
        get { return p1 } 
        set { p1 = value }
    }
    
    pub func operator[](this, index i) int => i
    
    // Function
    func fun1(this, a int) f32 => f1 + f2 + a
    func func1(this, a int) { }
    func func2(this, a out str) bool {}
    func func4(this, a ref MyStruct) {}
    func func5(this, a Array<Array<int>>) {}
    func func7(this, a List<int>) { }
    func func8(this, a out List<List<int>>) { }
    func func10(this, a Map<str,List<int>>) { }
    
    pub func Sort<T>(greaterThan func(a T, b T) bool) { }
    pub var MyFieldFunc func(sender object, message str)


    pub func M<A,B>(this, a A, b B, c List<int>) List<int> {}
    
    func func8(this, a out List<List<int>>) { }
    func func8(this, a out MyList<int,x,y,z>){ }
    
    pub func Main(args Array<str>)
    {
        use mut a = OpenFile("My File");
        defer file.close();
        
        // Function calls vs parameter lists
        var a1 = MyType<a,b,c>()
        mut a2 = MyType(a,b,c)()
        var a3 = List<List<int>>()
        var a4 = List(List(int))()
        var a5 = M<str,int.x<T>.y>.Hello2<x.x>()
        var a6 = M(str,int.x(T).y).Hello2(x.x)()     
        var a7 = f(f<a>())(a+b)

        // Casts
        var a = #int(a+b+myFloat32)*23+4        // Prefix, operator
        var a = #List<Stuff>(yourStuff.SeeMyStuff).Add(Stuff())    // Prefix
        var b = *#*int(myVoidPointer)      // Prefix
        var c1 = #M<str,int.x<T>.y>.Hello2(A)
        var c2 = #M<str,int.x<T>.y>.Hello2<x.x>(A)
        var c3 = #List<int,y,z>(A)
        var a = #int(a+b+myFloat32)
        var a = #List<Stuff>(yourStuff.SeeMyStuff).Add(Stuff())
        var a = (#List<Stuff>(yourStuff.SeeMyStuff)).Add(Stuff())
        var b = *#*int(myVoidPointer)
        #List<Stuff>(yourStuff.SeeMyStuff)[23] = 4


        // Local variables declared in a function
        var myString = "Hello World"
        var myInt = 3
        var myList = List<int>([1,2,3])
        var myMap = Map<str,int>({"A":1,"B":2})
        var myOtherMap = MyMapReturningFunction()
       
        var myStr str = MyStrFunc()    // Error if MyStrFunc returns an int
        var myInt int = MyIntFunc()    // Error if MyIntFunc returns a f32
        var a str                      // `a` is a string, initialized to ""
        var b List<int>                // `b` is a List<int>, initialized to empty
    
        var myNullStr ?str         // String is null
        var myEmptyStr ?str()      // String is ""
        
        var myTranslation = tr"jeremy"

        // Static assigments
        M<str>.Hello = 6
        M<str,int.x<T>.y>.Hello2 = f(1, 2, "Jeremy")
        M<str,int>.Hello2 = f(1, 2, (x, y) -> x < y)
        
        var a = x>y
        if MyFieldFunc != null
            { MyFieldFunc(this, "hello") }

        var l1 = (a) -> { return 23 }
        var l2 = (a) -> 23
        list.Sort((a, b) -> a < b)
        list.Sort((a, b) -> { return a < b })

        // In operator
        if myStr in myMap || myIn in 1..23
        {
            DoSomething();
        }

        // Switch expressions
        var num = switch myConstant { 23 => a, 27 => b, default => 0}

        // Switch statement
        switch a
        {
        case 1:
            DoIt(1) // No break necessary         
        case 2: // Empty case is the only time it falls through
        case 3:
            DoIt2()
        default: doit3();
        }
                
    }
}


pub func Example::IfTests() 
{ 
    // In operator
    if myStr in myMap || myIn in 1..23
    {
        DoSomething()
        break
        return
    }
    
    while f(x)
    {
        x = x + 1
    }
    
    if myStr in myMap || myIn in 1..23
    {
        DoSomething()
        hello()
    }
    
    if a
    {
        todo()
        todo()
    }
    else if b
    {
        todo()
    }
    else if c
    {
        todo()
    }
    
    if a
    {
        f(x)
    }
    

    if myStr in myMap || myIn in 1..23
    {
      DoSomething()
      hello()
    }
    else
    {
        f(a)
    }

    if myStr in myMap || myIn in 1..23
    {
        DoSomething()
        hello()
    }
    else 
    {
        f(a)
    }
        

    for a in 1..23
    {
      F(out var b, c)
    }


    for a in 1..23
    {
        F(out mut b, c)
    }
}

pub struct MyPoint
{
    pub var X int
    pub var Y int
    pub override func ToStr(this) => "(" + X + "," + Y + ")"
}


pub enum MyEnum
{
    A          // A=0
    B; C      // B=1, C=2
    D = 23
    E = 48
    F; G  // F=49, G=50
}


pub interface MyInterfaceTest
{
    func A(this) int => imp
    protected func C(this ) int => imp
        
    pub func B(this) int => A() + 1
    pub struct Astruct { pub var a int }
    pub enum Aenum { a; b; c}
    pub class Aclass { pub var a int  }
}

pub class MyClass1 
    implements MyInterfaceTest
{
    pub func A() int => 3
    pub func MyInterfaceTest::C(this) int => 3

}


pub func Sort<T>(s MutSpan<T>, lessThan func(a T, b T) bool)
{
    // Simple selection sort
    for i in s.Count-1
    {
        mut lowElem = s[i]
        mut lowIndex = i
        for j in i+1..s.Count
        {
            if lessThan(s[j], lowElem)
            {
                lowElem = s[j]
                lowIndex = j
            }
        }
        if lowIndex != i
        {
            s[lowIndex] = s[i]
            s[i] = lowElem
        }
    }
}

// The matrix class is used to implement square 2d arrays
pub class Matrix2d<t>
    extends VariableSizedObject<T>
{
    func new(len1 int, len2 int) { todo() }
    pub func operator[](i1 int, i2 int) ref T => todo()
}



pub func MemCopy(dest *void, source *void, length xint)
{
    var d = #xint(dest)
    var s = #xint(source)
    
    if length <= 0
    {
        return
    }
    // Align `d` on i32
    while d & 3 != 0 && length != 0
    {
        *#*byte(d) = *#*byte(s); d+=1; s+=1; length-=1
    }
    
    if s & 3 == 0
    {
        MemCopy32(#*void(d), #*void(s), length)
        return
    }
    
    // Byte copy
    var end = d + length
    while end-d >= 4
    {
        *#*byte(d) = *#*byte(s); d+=1; s+=1
        *#*byte(d) = *#*byte(s); d+=1; s+=1
        *#*byte(d) = *#*byte(s); d+=1; s+=1
        *#*byte(d) = *#*byte(s); d+=1; s+=1
    } 
    while d != end
    {
        *#*byte(d) = *#*byte(s); d+=1; s+=1
    }
}

pub func MemCopy32(dest *void, source *void, length xint)
{
    var d = #xint(dest)
    var s = #xint(source)

    if length <= 0
    {
        return
    }

    // Try 64 bit copy first
    var end = d + length
    if (d~s) & 4 == 0 && length >= 8
    {
        if d & 4 != 0
        {
            *#*i32(d) = *#*i32(s); d+=4; s+=4
        }
        while end - d >= 8  
        {
            *#*i64(d) = *#*i64(s); d+=8; s+=8
        }
    }
    while end-d >= 4
    {
        *#*i32(d) = *#*i32(s); d+=4; s+=4
    }
    while d != end
    {
        *#*byte(d) = *#*byte(s); d+=1; s+=1
    }
}

namespace ExampleNs1.HelloWorld
{
    func F1() => todo
    
    class ClassEx1
    {
        var a int;
        var b int;
    }
}


namespace ExampleNs1
{
    func F1() => todo
    
    namespace InnerEx1
    {

    }

    namespace InnerEx2
    {
    }

    class ClassEx1
    {
        var a int;
        var b int;
        class Inner1
        {
        }
    
        class Inner2
        {
        }
    }
    class ClassEx2
    {
        class Inner1
        {
        }
    
        class Inner2
        {
        }
    }
}

namespace ExampleNs2
{
    func F1() => todo
    
    class ClassEx1
    {
        var a int
        var b int
        class Inner1
        {
        }
    
        class Inner2
        {
        }
    }
    class ClassEx2
    {
        class Inner1
        {
        }
    
        class Inner2
        {
        }
    }
}