//pragma ShowParse        // Show the parse tree (hover over a symbol)
//pragma ShowMeta       // Show parser symbols
//pragma NoParse
//pragma RequireBraces

// Press F4 to see header file report


// http://zurfur.com
mod TestExample

use Zurfur
use Zurfur[Decimal, Log]
use Zurfur.Collections[Iterator]
use Zurfur.Math[cos,sin]
use Zurfur.ConvertBytes[bytesToHex]


// Simple types have public fields:
[pub] type SimpleType(firstName str, lastName str)
[pub] type SimpleImmutableType ro(firstName str, fastName str)


// Define a type
[pub]
type MyType
    text str                // Public
    _misc str               // Private
    _list List<int> pub ref // Private with pub ro

// Method
[pub]
fun MyType.countToTen()
    Log.info("Hello world.  Let's count to 10.")
    for @i in 1..+10
        Log.info("Count=${i}, text=${my.text}")

// Setter for list, which is already public read-only
[pub]
fun set MyType.list(v own List<int>)
    my._list = v
    my.mapChangedEvent()



fun MyType.mapChangedEvent() {}



fun doit() {}
fun hello() {}

fun test_HelloWorld()
    Log.info("Hello World.  Let's count from 1 to 10.")
    for @a in 1..11
        Log.info("Hello world.  count=${a}")
        doit()
        doit()
        hello()
        if a == 3
            doit()
        elif a == 4
            doit()
        elif a == 5
            doit()
        else
            doit()
            
[pub]
type AGenericType<Q>
    a int

[pub]
fun circle(a f64, r f64) -> (x f64, y f64)
    return (cos(a)*r, sin(a)*r)


[pub] type Example
    
    a1 str
    a2 str = "Hello"
    a3 List<str> = ["Hello", "World"]
    a4 List<int> = [1,2]
    a5 List<int> pub ref
    a6 List<int> pub mut
    a7 List<int> pub mut
    //pub a8 List<int>
    //pub a9 private set List<int>
    //pub private set a9 List<int>

    map1 ro Map<str,int> = ["A":1,"B":2]        // Immutable map
    map2 ro mut Map<str,int> = ["A":1,"B":2]    // Can't be assigned, can be mutated
    map3 ro Map<str,int> pub init               // Read only, init in constructor or allow public init
    
    a Zim<void>
    b Zim<object>
    c Zim<i8>
    e Zim<byte>
    f Zim<i16>
    g Zim<u16>
    h Zim<i32>
    i Zim<u32>
    j Zim<int>
    m Zim<f64>
    n Zim<f32>
    o Zim<str>
    p Zim<Decimal>
    


[pub]
type Zim<T>
    q T pub mut

// Type test for test_main
type Token(a int)
fun AcceptMatch(m str) Token {}

// This is a public documentation comment.  Do not use XML.
// Use `name` to refer to variables in the code.
[pub] fun test_Main(args Array<str>, stream Zurfur.Io.Reader)


    // This is a regular private comment
    Log.info("Hello World, 2+2=${2+2}")

    @v = ""
    //@myStrings = ["a", "b", "c"]
    @myStrings = Array<str>()

    if myStrings[1]@q == "x"
        v = "x"
    elif q == "y" or q=="z"
        v = "y or z"
    elif q >= "a" or q <= "z"
        v = "lower"
    elif q >= "A" or q <= "Z"
        v = "upper"
    else
        v = "none"
    

    @a = tr"Column 1${\t}Column 2${\rn}"
    @data = "Name:${name}${\t}Occupation:${lastName}${\rn}"
    @buffer = Buffer<byte>()
    
    while stream.read(buffer[0..4])@size == 4
        @bytes = buffer[0..4].bytesToHex(false) // TBD: Scan use statements for extension methods


    // AcceptMatch returns ?Token = (bool, Token)
    // @Token captures the token, leaving the bool
    if AcceptMatch("(")@Token
    {
        // We got a token
    }

    @sum = 0
    @list List<int>
    list.forEach(@item =>
    {
        sum += item
    })

    return

    fun test_compose()
        Log.info("Count=${v}")
        //@squareTriple = compose(&square, &triple)
        //Debug.Assert(squareTriple(2) == 36)
        //    
        //for @v in 1..23
        //    Log.Info("Count=${v}")

    // Compose f(g(x))
    fun compose(f fun(x int) int,
                g fun(x int) int) fun(x int) int
        return //@x => f(g(x))

    fun triple(x int) int
        return x*3
    fun square(x int) int
        return x*x

// https://stackoverflow.com/questions/1825952/how-to-create-a-generic-extension-method
// PREVIOUSLY: [pub] fun GetIterator<T>.AlphaLengthWise<T,L>(lengthProvider fun(t T) L) GetIterator<T>
[pub] fun Iterator<Item>.alphaLengthWise<L>(lengthProvider fun(t Item) L) Iterator<Item>
    return my.orderBy(@a => lengthProvider(a))
             .thenBy(@a => a)

fun Iterator<Item>.orderBy() Iterator<Item>
    extern


type MyStruct(a int)

[pub] fun sort<T>(s mut Span<T>, lessThan fun(a T,b T)bool)
    // Simple selection sort
    for @i in s.length-1
        @lowElem = s[i]
        @lowIndex = i
        for @j in i+1..s.length
            if lessThan(s[j], lowElem)
                lowElem = s[j]
                lowIndex = j
        if lowIndex != i
            s[lowIndex] = s[i]
            s[i] = lowElem


        