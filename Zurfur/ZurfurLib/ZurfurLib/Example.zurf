pragma ShowParse        // Show the parse tree (hover over a symbol)
//pragma ShowMeta       // Show parser symbols
//pragma NoParse

// Press F4 to see header file report

TBD
// Move impl methods into group directly under SymModule
// Figure out where impl's live (types, or method groups)
// Unify extension methods and impl's:
//      See code with comment "First parameter is "$this"
//      Add method parameter for impl (add interface type parameter)
//
// Sort out "This" usage in interfaces.
//      May need to pass explicit <T> for everything (e.g. OpEq<Lhs, Rhs>)
// In Range<T>, will this do what I want it to do:
//      where This is GetIterator<T> + OpIn<Range<T>>
// And also Point<T> where T is NumOps
//
// Operators static with explicit types?


use Zurfur
use Zurfur.Collections

// http://zurfur.com
module TestExample

// Get this to work
type Point(X int, Y int)
//get Point<T>::Size() Point<T> { return Point(X, Y) }


// Simple types have public fields:
pub type SimpleType(firstName str, lastName str)
pub type ro SimpleImmutableType(firstName str, fastName str)

pub type ComplexType
    // Fields are private, but may have public properties
    @map Map<str,int> = ["A":1, "B":2]  // Private, mutable
    @list ro List<int> = [1,2,3]       // Private, read-only
    @header str pub get = "Zurfur" // Private, public get
    @text str pub get set          // Private, public get/set
    @myList List<int> pub ref   // Has public `ro` reference

    // Properties are public by default
    get myMap() ref Map<str, int>
        return ref map // Return a read only reference
    set myMap(v own Map<str, int>)
        map = v
        mapChanged()

    /// This is a public documentation comment.
    /// Functions are private by default.
    pub fun countToTen() str
        Log.info("Hello world.  Let's count to 10.")
        for @a in 1..11
            Log.info("Count={a}, Text={text}")



// Need to figure out placeholder types:
//      https://doc.rust-lang.org/book/ch19-03-advanced-traits.html
//
// In the example on that page, the associate type is Item,
// and should translate to Iterator<Item>.  So why do we
// need the type argument on its own line?
//
// But on this page:
//      https://medium.com/@jreem/advanced-rust-using-traits-for-argument-overloading-c6a6c8ba2e17
// Does the associate type translate to IntoReader<OutReader>?
//
//pub trait RustSend { }
//pub trait RustReader
//{
//    pub fun mut Read(buffer []byte) int error youdo
//}
//pub trait RustIntoReader<OutReader>
//    where OutReader is RustReader
//{
//    fun ToReader() OutReader youdo
//}
//type RustResponse
//{
//    @body ^RustReader
//    pub fun mut SetBody<I>(data I)
//            where I is IntoReader, I.OutReader is RustSend:
//        _body = data.ToReader()
//}


fun test_HelloWorld()
    while a == 3
        doit()
        doit2()
    Console.Log("Hello World.  Let's count from 1 to 10.")
    for @a in 1..11
        doita
        doitb
        while a == 3
            doit1
            doit2
        hello
        if a
            doit4
            

pub type boxed AGenericType<Q>

    pub fun Circle1(a f64, r f64) -> (x f64, y f64)
        return Cos(a)*r, Sin(a)*r

    pub fun Circle2(a int, r int) int
        return Cos(a)*r, Sin(a)*r


    pub fun Circle3(a f64, r f64) -> (x f64, y f64)
        return Cos(a)*r, Sin(a)*r

    pub fun MyVoid1()
        return 0

    pub fun MyVoid2() int
        return 0



pub fun Circle3(a f64, b f64) -> (c int, d int)
    return 0

// https://stackoverflow.com/questions/1825952/how-to-create-a-generic-extension-method
pub fun GetIterator<T>::AlphaLengthWise<T, L>(
               lengthProvider fun(t T) L) GetIterator<T>
    return this
        .OrderBy(@a => lengthProvider(a))
        .ThenBy(@a => a)

    F(t).AW(T,L).q

pub type Example

    get MyConst() str
        return "Hello"
    
    @a1 str
    @a2 str = "Hello"
    @a3 List<str> = ["Hello", "World"]
    @a4 List<int> = [1,2]
    @a5 List<int> pub get
    @a6 List<int> pub mut
    @a7 List<int> pub get set
    //pub a8 List<int>
    //pub a9 private set List<int>
    //pub private set a9 List<int>

    @map1 ro Map<str,int> = ["A":1,"B":2]        // Immutable map
    @map2 ro mut Map<str,int> = ["A":1,"B":2]    // Can't be assigned, can be mutated
    @map3 ro Map<str,int> pub init               // Read only, init in constructor or allow public init
    

    pub fun GetInfo(a int) str
        return info+a
    pub fun GetInfo(a str) str
        return a
    get Info() str
        return info

    @a Zim<void>
    @b Zim<object>
    @c Zim<i8>
    @e Zim<byte>
    @f Zim<i16>
    @g Zim<u16>
    @h Zim<i32>
    @i Zim<u32>
    @j Zim<int>
    @m Zim<f64>
    @n Zim<f32>
    @o Zim<str>
    @p Zim<Decimal>
    


pub type Zim<T>
    @q T pub get set


/// This is a public documentation comment.  Do not use XML.
/// Use `name` to refer to variables in the code.
pub fun test_Main(args Array<str>)

    test_compose()

    // This is a regular private comment
    Log.Info("Hello World, 2+2={2+2}")

    @v = ""

    if myString[32]@q == "x"
        v = "x"
    elif q == "y"  || q=="z"
        v = "y or z"
    elif q >= "a" || q <= "z"
        v = "lower"
    elif q >= "A" || q <= "Z"
        v = "upper"
    else
        v = "none"
    

    a = tr"Column 1{\t}Column 2{\rn}"
    data = "Name:{name}{\t}Occupation:{lastName}{\rn}"
    
    while stream.Read(buffer)@size != 0
        @a = MyFun as Hello


    // AcceptMatch returns ?Token = (bool, Token)
    // @Token captures the token, leaving the bool
    if AcceptMatch("(")@Token
    {
        // We got a token
    }

    // list.For takes a lambda with one parameter
    // @item captures the lambda parameter
    @sum = 0
    list.For() @item =>
    {
        sum += item
    }

    return

    fun test_compose()
   
        @squareTriple = compose(&square, &triple)
        Debug.Assert(squareTriple(2) == 36)
    
        for @v in 1..23
            Log.Info("Count={v}")

    /// Compose f(g(x))
    fun compose(f fun(x int) int,
                g fun(x int) int) fun(x int) int
        return @x => f(g(x))

    fun triple(x int) int
        return x*3
    fun square(x int) int
        return x*x


pub type Token(a str)

pub fun AcceptMatch(name str) ?Token
    return name == "(" ? Token() : null

// Regular static function
pub fun add(a int, b int) int
    return a + b

// Multiple returns
pub fun Circle(a f64, r f64) -> (x f64, y f64)
    return Cos(a)*r, Sin(a)*r


type MyStruct(a int)

pub fun Sort<T>(s mut Span<T>, lessThan fun(a T,b T)bool)
    // Simple selection sort
    for @i in s.Count-1
        @lowElem = s[i]
        @lowIndex = i
        for @j in i+1..s.Count
            if lessThan(s[j], lowElem)
                lowElem = s[j]
                lowIndex = j
        if lowIndex != i
            s[lowIndex] = s[i]
            s[i] = lowElem


pub fun MemCopy(dest *void, source *void, length xint)
    @d = cast(xint)dest
    @s = cast(xint)source
    
    if length <= 0
        return

    // Align `d` on i32
    while d & 3 != 0 && length != 0
        dref(cast(*byte)d) = dref(cast(*byte)s)
        d+=1;  s+=1;  length-=1
    
    if s & 3 == 0
        MemCopy32(cast(*void)d, cast(*void)s, length)
        return
    
    // Byte copy
    @end = d + length
    while end-d >= 4
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
    while d != end
        dref(cast(*byte)d) = dref(castx<*byte>(s)); d+=1; s+=1

pub fun MemCopy32(dest *void, source *void, length xint)
    @d = cast (xint)dest
    @s = cast (xint)source

    if length <= 0
        return

    // Try 64 bit copy first
    @end = d + length
    if (d~s) & 4 == 0 && length >= 8
        if d & 4 != 0
            dref(cast(*i32)d) = dref(cast(*i32)s); d+=4; s+=4
        while end - d >= 8
            dref(cast(*i64)d) = dref(cast(*i64)s); d+=8; s+=8
    while end-d >= 4
        dref(cast(*i32)d) = dref(cast(*i32)s); d+=4; s+=4
    while d != end
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1