pragma ShowParse        // Show the parse tree (hover over a symbol)
//pragma ShowMeta       // Show parser symbols
//pragma NoParse

// Press F4 to see header file report

TBD:
// Finish constraints
// For fields, move "pub get" to before type definition

use Zurfur
use Zurfur.Collections

// http://zurfur.com
module TestExample

// Get this to work
type Point(X int, Y int)
//get Point<T>::Size() Point<T> { return Point(X, Y) }


// Simple types have public fields:
type pub SimpleType(firstName str, lastName str)
type pub ro SimpleImmutableType(firstName str, fastName str)

type pub ComplexType
{
    // Fields are private, but may have public properties
    @map Map<str,int> = ["A":1, "B":2]  // Private, mutable
    @list ro List<int> = [1,2,3]       // Private, read-only
    @header str pub get = "Zurfur" // Private, public get
    @text str pub get set          // Private, public get/set
    @myList List<int> pub ref   // Has public `ro` reference

    // Properties are public by default
    get myMap() ref Map<str, int>:
        return ref map // Return a read only reference
    set myMap(v own Map<str, int>):
        map = v
        mapChanged()

    /// This is a public documentation comment.
    /// Functions are private by default.
    fun pub countToTen() str:
        Log.info("Hello world.  Let's count to 10.")
        for @a in 1..11:
            Log.info("Count={a}, Text={text}")
}


// Need to figure out placeholder types:
//      https://doc.rust-lang.org/book/ch19-03-advanced-traits.html
//
// In the example on that page, the associate type is Item,
// and should translate to Iterator<Item>.  So why do we
// need the type argument on its own line?
//
// But on this page:
//      https://medium.com/@jreem/advanced-rust-using-traits-for-argument-overloading-c6a6c8ba2e17
// Does the associate type translate to IntoReader<OutReader>?
//
//pub trait RustSend { }
//pub trait RustReader
//{
//    fun pub mut Read(buffer []byte) int error youdo
//}
//pub trait RustIntoReader<OutReader>
//    where OutReader is RustReader
//{
//    fun ToReader() OutReader youdo
//}
//type RustResponse
//{
//    @body ^RustReader
//    fun pub mut SetBody<I>(data I)
//            where I is IntoReader, I.OutReader is RustSend:
//        _body = data.ToReader()
//}


fun test_HelloWorld():
    while a == 3:
        doit()
        doit2()
    Console.Log("Hello World.  Let's count from 1 to 10.")
    for @a in 1..11:
        doita
        doitb
        while a == 3:
            doit1
            doit2
        hello
        if a:
            doit4
            

type pub heap AGenericType<Q>(FirstName str, LastName str)
{
    fun pub Circle1(a f64, r f64) -> (x f64, y f64):
        return Cos(a)*r, Sin(a)*r

    fun pub Circle2(a int, r int) int:
        return Cos(a)*r, Sin(a)*r


    fun pub Circle3(a f64, r f64) -> (x f64, y f64):
        return Cos(a)*r, Sin(a)*r

    fun pub MyVoid1():
        return 0

    fun pub MyVoid2() int:
        return 0
       
}


fun pub Circle3(a f64, b f64) -> (c int, d int):
    return 0

// https://stackoverflow.com/questions/1825952/how-to-create-a-generic-extension-method
fun pub GetIterator<T>::AlphaLengthWise<T, L>(
               lengthProvider fun(t T) L) GetIterator<T>:
    return this
        .OrderBy(@a => lengthProvider(a))
        .ThenBy(@a => a)

    F(t).AW(T,L).q

type pub Example
{
    get MyConst() str:
        return "Hello"
    
    @a1 str
    @a2 str = "Hello"
    @a3 List<str> = ["Hello", "World"]
    @a4 List<int> = [1,2]
    @a5 List<int> pub get
    @a6 List<int> pub mut
    @a7 List<int> pub get set
    //pub a8 List<int>
    //pub a9 private set List<int>
    //pub private set a9 List<int>

    @map1 ro Map<str,int> = ["A":1,"B":2]        // Immutable map
    @map2 ro mut Map<str,int> = ["A":1,"B":2]    // Can't be assigned, can be mutated
    @map3 ro Map<str,int> pub init               // Read only, init in constructor or allow public init
    

    fun pub GetInfo(a int) str:
        return info+a
    fun pub GetInfo(a str) str:
        return a
    get Info() str:
        return info

    @a Zim<void>
    @b Zim<object>
    @c Zim<i8>
    @e Zim<byte>
    @f Zim<i16>
    @g Zim<u16>
    @h Zim<i32>
    @i Zim<u32>
    @j Zim<int>
    @m Zim<f64>
    @n Zim<f32>
    @o Zim<str>
    @p Zim<Decimal>
    
}

type pub Zim<T>
{
    @q T pub get set
}


/// This is a public documentation comment.  Do not use XML.
/// Use `name` to refer to variables in the code.
fun pub test_Main(args Array<str>)
{
    test_compose()

    // This is a regular private comment
    Log.Info("Hello World, 2+2={2+2}")

    @v = ""

    if myString[32]@q == "x":
        v = "x"
    elif q == "y"  || q=="z":
        v = "y or z"
    elif q >= "a" || q <= "z":
        v = "lower"
    elif q >= "A" || q <= "Z":
        v = "upper"
    else:
        v = "none"
    

    a = tr"Column 1{\t}Column 2{\rn}"
    data = "Name:{name}{\t}Occupation:{lastName}{\rn}"
    
    while stream.Read(buffer)@size != 0:
        @a = MyFun as Hello


    // AcceptMatch returns ?Token = (bool, Token)
    // @Token captures the token, leaving the bool
    if AcceptMatch("(")@Token
    {
        // We got a token
    }

    // list.For takes a lambda with one parameter
    // @item captures the lambda parameter
    @sum = 0
    list.For() @item =>
    {
        sum += item
    }

    return

    fun test_compose()
    {
        @squareTriple = compose(&square, &triple)
        Debug.Assert(squareTriple(2) == 36)
    
        for @v in 1..23:
            Log.Info("Count={v}")
    }

    /// Compose f(g(x))
    fun compose(f fun(x int) int,
                g fun(x int) int) fun(x int) int
    {
        return @x => f(g(x))
    }

    fun triple(x int) int:
        return x*3
    fun square(x int) int:
        return x*x
}

type pub Token(a str)

fun pub AcceptMatch(name str) ?Token:
    return name == "(" ? Token() : null

// Regular static function
fun pub add(a int, b int) int:
    return a + b

// Multiple returns
fun pub Circle(a f64, r f64) -> (x f64, y f64):
    return Cos(a)*r, Sin(a)*r


// Mutable point
type pub MyMutablePoint(X int, Y int)
{
    fun pub mut SetY(y int):
        Y = y
        
    get PropX() int:
        return x
    set PropX(value int):
        X = value
}


type MyStruct(a int)

fun pub Sort<T>(s mut Span<T>, lessThan fun(a T,b T)bool):
    // Simple selection sort
    for @i in s.Count-1:
        @lowElem = s[i]
        @lowIndex = i
        for @j in i+1..s.Count:
            if lessThan(s[j], lowElem):
                lowElem = s[j]
                lowIndex = j
        if lowIndex != i:
            s[lowIndex] = s[i]
            s[i] = lowElem


fun pub MemCopy(dest *void, source *void, length xint):
    @d = cast(xint)dest
    @s = cast(xint)source
    
    if length <= 0:
        return

    // Align `d` on i32
    while d & 3 != 0 && length != 0:
        dref(cast(*byte)d) = dref(cast(*byte)s)
        d+=1;  s+=1;  length-=1
    
    if s & 3 == 0:
        MemCopy32(cast(*void)d, cast(*void)s, length)
        return
    
    // Byte copy
    @end = d + length
    while end-d >= 4:
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1
    while d != end:
        dref(cast(*byte)d) = dref(castx<*byte>(s)); d+=1; s+=1

fun pub MemCopy32(dest *void, source *void, length xint):
    @d = cast (xint)dest
    @s = cast (xint)source

    if length <= 0:
        return

    // Try 64 bit copy first
    @end = d + length
    if (d~s) & 4 == 0 && length >= 8:
        if d & 4 != 0
            { dref(cast(*i32)d) = dref(cast(*i32)s); d+=4; s+=4 }
        while end - d >= 8
            { dref(cast(*i64)d) = dref(cast(*i64)s); d+=8; s+=8 }
    while end-d >= 4:
        dref(cast(*i32)d) = dref(cast(*i32)s); d+=4; s+=4
    while d != end:
        dref(cast(*byte)d) = dref(cast(*byte)s); d+=1; s+=1