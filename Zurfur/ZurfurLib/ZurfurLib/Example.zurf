use a.b.c
use system.gosub.p


// http://zurfur.com
namespace Zurfur.Example

static fun test_HelloWorld()
{
    Console.Log("Hello World.  Let's count from 1 to 10.")
    for @a in 1..11
    {
        Console.Log("Count=" a)
    }
}

pub class Example
{
    info str                             // Initialized string
    list List<str> = ["Hello", "World"]  // Mutable list
    ro map Map<str,int> = ["A":1,"B":2]  // Immutable map
    pub fun GetInfo(a int) str => info+a // Public function
    pub prop Info str => info            // Public property
    
    pub fun Test()
    {
        a = tr"Column 1"\tab"Column 2"\crlf
        data = "Name:"name\tab"Occupation:"lastName\crlf
        
        while stream.Read(buffer)@size != 0
        {
            @a = MyFun as Hello
        }
    }
}

/// This is a public documentation comment.  Do not use XML.
/// Use `name` to refer to variables in the code.
pub static fun Main(args Array<str>)
{
    // This is a regular private comment
    Log.Info("Hello World, 2+2=" add(2,2))
}

// Regular static function
pub static fun add(a int, b int) int
    => a + b

// Multiple returns
pub static fun Circle(a f64, r f64) : (x f64, y f64)
{
    return Cos(a)*r, Sin(a)*r
}


pub class MutableTest
{
    a MyObject
    b List<MyObject>

    ro c mut MyObject
    ro d mut List<MyObject>
    ro e mut List<MyObject>


    pub fun getMyObjectAt(i index) mut MyObject => todo()
    pub fun getMyObjects() List<mut MyObject> => todo()
    pub fun getMyObjects() mut List<MyObject> => todo()
    pub prop P1 MyObject => i
    pub prop P2 mut MyObject => i
    
    pub prop P mut str => Header + info       // Public property
    fun getListObject(i mut index) mut MyObject => a[i]

}

// Mutable point (each mutable function must also be marked)
pub struct MyMutablePoint
{
    pub X int
    pub Y int
    pub fun new(x int, y int) { X = x; Y = y}
    pub mut fun SetY(y int) { Y = y }
    pub prop PropX int
    {
    get:
        return X
    set:
        X = value
    }
}


/// Example class, a test of hover comments and `code` comments
pub class Example_x
{
    pub const CONST_FIELD int = 234
    pub field1 f32
    pub field2 int
    pub prop Prop str => Header + info      // Property
    pub fun A(a int, b int, c f32) f32 => a+1
    pub fun A(a f32) f32 => a+1
    pub fun B(a f32) f32 => a+1
    pub prop ChangedTime DateTime get set = DateTime.Now
        
    pub fun E()
    {
        list.binarysearch(1,23)(a,b) ->   {  a.compare(b) }
        const MY_CONST = 23
        @a = f(x)
        @b = f(MY_CONST)
    }
    
}
pub fun Example::MyExtension() => Func1(10) // Extension method


pub fun Example::MyExtension()
{
    @a = Map<str,int>(["A":1, "B":2, "C":3])
    @b Map<str,int> = ["A":1, "B":2, "C":3]
    @c Map<int,PointXY> = [0:(3,4), 1:(5,6)]
    
    @d = 3                              // `a` is an int
    @e = "Hello World"                  // `b` is a str
    @f = MyFunction()                   // `c` is whatever type is returned by MyFunction
    @g = List<int>([1,2,3])             // `d` is a list of integers, intialized with {1,2,3}
    @h = Map<str,int>(["A":1,"B":2])    // `e` is a map of <str, int>
    @i = Json(["A":1,"B":[1,2,3]])      // `f` is a Json object containing a number and an array
   
    @j int = MyIntFunc()                // Error if MyIntFunc returns a float
    @k str                              // `b` is a string, initialized to ""
    @l List<int>                        // `c` is an empty List<int>
    @m List<int> = [1, 2, 3]
    @n Map<str,int> = MyMapFunc()       // Error if MyMapFunc doesn't return Map<str,int>
    @o Map<int,str> = [0:"a", 1:"b"]
    
}


pub struct PointXY<T>
    implements IArithmetic<T>
    where f is IAritmetic<T>
{
    pub x int
    pub y int
    
    pub fun operator+(a PointXY<T>, b PointXY<T>) PointXY<T> => todo()
}

pub fun Example::Extension()
{
    for @a in 1..23
    {
        F(out @x, a)
        F(out mut @y, a)
    }
    @i = 32
    @j = 15
    @k int = 64
}

// Test class
pub class Example2  // YES, errors working
{
    // Todo List:
    //    .. operator doesn't need parameters at beginning or end
    //    Support for :: operator (start::count)
    //    Editor should always use spaces (or tabs, just pick one and be done)
    //    Editor should comment out blocks with CTRL-'/'
    //    Implement switch (doesn't use break)
    //    Switch statement

    // Fields initialized to zero, null, or "" for string
    f1 int          // Initialized to 0
    f2 f32      // Initialized to 0.0
    f3 str          // Initialized to "", not NULL
    
    f4 Array<int> = [1,2,3,4]
    f5 Array<Array<int>>
    f7 Map<str,List<int>>
    f8 Pointer<int>
    f9 *int        // Same as Pointer<int>
    
    f10 = int(FuncReturnsInt())
    f11 = Array<int>()            // Array, Count=0
    f12 = Array<int>(32)          // Array, Count=32
    f13 = Array<int>([1,2,3])     // Array initialized with 1, 2, 3
    f13a = List<int>(32)          // Empty List, Capacity=32
    f14 = Map<str,str>()          // Empty map
    
    f15 int = 32
    f16 int = FuncReturnsInt() >> 4
    f17 f32 = FuncReturnsf32orInt()
    f18 str = "Hello"
    f19 *int = GetIntPtr()      // Same as Pointer<int> = `GetIntPtr()`
    
    // Properties
    pub prop P1 int => 1
    pub prop P2 f32 =>  f1 + f2
    pub prop P4 int get set = 3
    pub prop P5 int
    {
    get:
        return p1
    set:
        p1 = value
    }
    
    pub fun operator[](index i) int => i
    
    // Function
    fun fun1(a int) f32 => f1 + f2 + a
    fun fun2(a int) { }
    fun fun3(a out str) bool {}
    fun fun4(a ref MyStruct) {}
    fun fun5(a Array<Array<int>>) {}
    fun fun6(a List<int>) { }
    fun fun7(a out List<List<int>>) { }
    fun fun8(a Map<str,List<int>>) { }
    
    pub fun Sort<T>(greaterThan fun(T,T)bool) { }
    pub MyFieldFunc fun(object,str)void


    pub fun M<A,B>(a A, b B, c List<int>) List<int> {}
    
    fun fun9(a out List<List<int>>) { }
    fun fun10(a out MyList<int,x,y,z>){ }
    
    pub static fun Main(args Array<str>)
    {
        @a = use OpenFile("My File")
        defer file.close()
        
        // Function calls vs parameter lists
        @a1 = MyType<a,b,c>()
        @a2 = MyType(a,b,c)()
        @a3 = List<List<int>>()
        @a4 = List(List(int))()
        @a5 = M<str,int.x<T>.y>.Hello2<x.x>()
        @a6 = M(str,int.x(T).y).Hello2(x.x)()
        @a7 = f(f<a>())(a+b)

        // Casts
        @b = *cast(*int)myVoidPointer


        // Local variables declared in a function
        @myString = "Hello World"
        @myInt = 3
        @myList1 = [1,2,3]
        @myMap1 = ["A":1,"B":2]
        @myList2 = List<int>([1,2,3])
        @myMap = Map<str,int>(["A":1,"B":2])
        @myOtherMap = MyMapReturningFunction()
       
        @myStr str = MyStrFunc()    // Error if MyStrFunc returns an int
        @myInt int = MyIntFunc()    // Error if MyIntFunc returns a f32
        @a str                      // `a` is a string, initialized to ""
        @b List<int>                // `b` is a List<int>, initialized to empty
    
        @myNullStr ?str         // String is null
        @myEmptyStr ?str = ""   // String is ""
        
        @myTranslation = tr"jeremy"

        // Static assigments
        M<str>.Hello = 6
        M<str,int.x<T>.y>.Hello2 = f(1, 2, "Jeremy")
        M<str,int>.Hello2 = f(1, 2, (x, y) -> x < y)
        
        @a = x>y
        if MyFieldFunc != null
            { MyFieldFunc(this, "hello") }

        @l1 = (a) -> { return 23 }
        @l2 = (a) -> 23
        list.Sort((a, b) -> a < b)
        list.Sort((a, b) -> { return a < b })

        // In operator
        if myStr in myMap || myIn in 1..23
        {
            DoSomething()
        }

        // Switch expressions
        @num = 3 + match(myConstant)[1:a, 2..5:b, 6:myFunc(), default: 0]

        // Switch statement
        switch a
        {
        case 1:
            DoIt(1) // No break necessary
        case 2, 3:
            DoIt2()
        default:
            doit3()
        }
        
        @a json = [
             "TestArray": [
                 [
                     "Field1": "A",
                     "Field2": "B",
                     "Field3": "C"
                 ],
                 [
                     "Field1": "A",
                     "Field2": "B",
                     "Field3": "C"
                 ]
             ]
         ]
        
                
    }
}


pub fun Example::IfTests()
{
    // In operator
    if myStr in myMap || myIn in 1..23
    {
        DoSomething()
        break
        return
    }
    
    while f(x)
    {
        x = x + 1
    }
    
    if myStr in myMap || myIn in 1..23
    {
        DoSomething()
        hello()
    }
    
    if a
    {
        todo()
        todo()
    }
    else if b
    {
        todo()
    }
    else if c
    {
        todo()
    }
    
    if a
    {
        f(x)
    }
    

    if myStr in myMap || myIn in 1..23
    {
      DoSomething()
      hello()
    }
    else
    {
        f(a)
    }

    if myStr in myMap || myIn in 1..23
    {
        DoSomething()
        hello()
    }
    else
    {
        f(a)
    }
        

    for @a in 1..23
    {
      F(out @b, c)
    }


    for @a in 1..23
    {
        F(out mut @b, c)
    }
}

pub struct MyPoint
{
    pub X int
    pub Y int
    pub override fun ToStr() => "(" X ", " Y ")"
}


pub enum MyEnum
{
    A          // A=0
    B; C      // B=1, C=2
    D = 23
    E = 48
    F; G  // F=49, G=50
}


pub interface MyInterfaceTest
{
    fun A() int => imp
    protected fun C() int => imp
        
    pub fun B() int => A() + 1
    pub struct Astruct { pub a int }
    pub enum Aenum { a; b; c}
    pub class Aclass { pub a int  }
}

pub class MyClass1
    implements MyInterfaceTest
{
    pub fun A() int => 3
    pub fun MyInterfaceTest::C() int => 3

}


pub static fun Sort<T>(s MutSpan<T>, lessThan fun(T,T)bool)
{
    // Simple selection sort
    for @i in s.Count-1
    {
        @lowElem = s[i]
        @lowIndex = i
        for @j in i+1..s.Count
        {
            if lessThan(s[j], lowElem)
            {
                lowElem = s[j]
                lowIndex = j
            }
        }
        if lowIndex != i
        {
            s[lowIndex] = s[i]
            s[i] = lowElem
        }
    }
}

// The matrix class is used to implement square 2d arrays
pub class Matrix2d<t>
    extends VariableSizedObject<T>
{
    fun new(len1 int, len2 int) { todo() }
    pub fun operator[](i1 int, i2 int) ref T => todo()
}



pub static fun MemCopy(dest *void, source *void, length xint)
{
    @d = cast(xint)dest
    @s = cast(xint)source
    
    if length <= 0
    {
        return
    }
    // Align `d` on i32
    while d & 3 != 0 && length != 0
    {
        *cast(*byte)d = *cast(*byte)s; d+=1; s+=1; length-=1
    }
    
    if s & 3 == 0
    {
        MemCopy32(cast(*void)d, cast(*void)s, length)
        return
    }
    
    // Byte copy
    @end = d + length
    while end-d >= 4
    {
        *cast(*byte)d = *cast(*byte)s; d+=1; s+=1
        *cast(*byte)d = *cast(*byte)s; d+=1; s+=1
        *cast(*byte)d = *cast(*byte)s; d+=1; s+=1
        *cast(*byte)d = *cast(*byte)s; d+=1; s+=1
    }
    while d != end
    {
        *cast(*byte)d = *cast(*byte)s; d+=1; s+=1
    }
}

pub static fun MemCopy32(dest *void, source *void, length xint)
{
    @d = cast (xint)dest
    @s = cast (xint)source

    if length <= 0
    {
        return
    }

    // Try 64 bit copy first
    @end = d + length
    if (d~s) & 4 == 0 && length >= 8
    {
        if d & 4 != 0
        {
            *cast(*i32)d = *cast(*i32)s; d+=4; s+=4
        }
        while end - d >= 8
        {
            *cast(*i64)d = *cast(*i64)s; d+=8; s+=8
        }
    }
    while end-d >= 4
    {
        *cast(*i32)d = *cast(*i32)s; d+=4; s+=4
    }
    while d != end
    {
        *cast(*byte)d = *cast(*byte)s; d+=1; s+=1
    }
}

namespace ExampleNs1.HelloWorld
{
    static fun F1() => todo
    
    class ClassEx1
    {
        a int
        b int
    }
}


namespace ExampleNs1
{
    static fun F1() => todo
    
    namespace InnerEx1
    {

    }

    namespace InnerEx2
    {
    }

    class ClassEx1
    {
        a int
        b int
        class Inner1
        {
        }
    
        class Inner2
        {
        }
    }
    class ClassEx2
    {
        class Inner1
        {
        }
    
        class Inner2
        {
        }
    }
}

namespace ExampleNs2
{
    static fun F1() => todo
    
    class ClassEx1
    {
        a int
        b int
        class Inner1
        {
        }
    
        class Inner2
        {
        }
    }
    class ClassEx2
    {
        class Inner1
        {
        }
    
        class Inner2
        {
        }
    }
}