//pragma ShowParse        // Show the parse tree (hover over a symbol)
//pragma ShowMeta       // Show parser symbols
//pragma NoParse
//pragma RequireBraces

// Press F4 to see header file report


// http://zurfur.com
module TestExample

use Zurfur[Decimal, Log]
use Zurfur.Collections[GetIterator, Iterator]
use Zurfur.Math[cos,sin]


// Simple types have public fields:
type pub SimpleType(firstName str, lastName str)
type pub ro SimpleImmutableType(firstName str, fastName str)

type pub ComplexType
    // Fields are private, but may have public properties
    
    @map Map<str,int> = ["A":1, "B":2]  // Private, mutable
    @list ro List<int> = [1,2,3]       // Private, read-only
    @header str pub get = "Zurfur" // Private, public get
    @text str pub get set          // Private, public get/set
    @myList List<int> pub ref   // Has public `ro` reference
    @mapChanged fun()

// Properties are public by default
get (ComplexType) myMap() ref Map<str, int>
    return ref my.map // Return a read only reference
    
set (ComplexType) myMap(v own Map<str, int>)
    my.map = v
    my.mapChanged()


// This is a public documentation comment.
// Functions are private by default.
fun pub countToTen() str
    Log.info("Hello world.  Let's count to 10.")
    for @a in 1..11
        Log.info("Count={a}, Text={text}")

fun doit() {}
fun hello() {}

fun test_HelloWorld()
    @a = 3
    while a == 3
        doit()
        doit()
        a += 1
    Log.info("Hello World.  Let's count from 1 to 10.")
    for @a in 1..11
        doit()
        doit()
        while a == 3
            doit()
            doit()
        hello()
        if a
            doit()
            
type pub owned box AGenericType<Q>
    @a int

fun pub circle1(a f64, r f64) -> (x f64, y f64)
    return cos(a)*r, sin(a)*r

fun pub circle2(a f32, r f32) int
    return cos(a)*r, sin(a)*r

fun pub circle3(a f64, r f64) -> (x f64, y f64)
    return cos(a)*r, sin(a)*r

fun pub circle3(a f64, b f64) -> (c int, d int)
    return 0

// https://stackoverflow.com/questions/1825952/how-to-create-a-generic-extension-method
// PREVIOUSLY: fun pub GetIterator<T>.AlphaLengthWise<T,L>(lengthProvider fun(t T) L) GetIterator<T>
fun pub (Iterator<Item>) alphaLengthWise<L>(lengthProvider fun(t Item) L) Iterator<Item>
    return my.orderBy(@a => lengthProvider(a))
             .thenBy(@a => a)

type pub Example
    
    @a1 str
    @a2 str = "Hello"
    @a3 List<str> = ["Hello", "World"]
    @a4 List<int> = [1,2]
    @a5 List<int> pub get
    @a6 List<int> pub mut
    @a7 List<int> pub get set
    //pub a8 List<int>
    //pub a9 private set List<int>
    //pub private set a9 List<int>

    @map1 ro Map<str,int> = ["A":1,"B":2]        // Immutable map
    @map2 ro mut Map<str,int> = ["A":1,"B":2]    // Can't be assigned, can be mutated
    @map3 ro Map<str,int> pub init               // Read only, init in constructor or allow public init
    
    @a Zim<void>
    @b Zim<object>
    @c Zim<i8>
    @e Zim<byte>
    @f Zim<i16>
    @g Zim<u16>
    @h Zim<i32>
    @i Zim<u32>
    @j Zim<int>
    @m Zim<f64>
    @n Zim<f32>
    @o Zim<str>
    @p Zim<Decimal>
    


type pub Zim<T>
    @q T pub get set


// This is a public documentation comment.  Do not use XML.
// Use `name` to refer to variables in the code.
fun pub test_Main(args Array<str>)


    // This is a regular private comment
    Log.info("Hello World, 2+2={2+2}")

    @v = ""

    if myString[32]@q == "x"
        v = "x"
    elif q == "y" or q=="z"
        v = "y or z"
    elif q >= "a" or q <= "z"
        v = "lower"
    elif q >= "A" or q <= "Z"
        v = "upper"
    else
        v = "none"
    

    @a = tr"Column 1{\t}Column 2{\rn}"
    @data = "Name:{name}{\t}Occupation:{lastName}{\rn}"
    
    while stream.Read(buffer)@size != 0
        @a = MyFun as Hello


    // AcceptMatch returns ?Token = (bool, Token)
    // @Token captures the token, leaving the bool
    if AcceptMatch("(")@Token
    {
        // We got a token
    }

    @sum = 0
    list.forEach(@item =>
    {
        sum += item
    })

    return

    fun test_compose()
   
        @squareTriple = compose(&square, &triple)
        Debug.Assert(squareTriple(2) == 36)
    
        for @v in 1..23
            Log.Info("Count={v}")

    // Compose f(g(x))
    fun compose(f fun(x int) int,
                g fun(x int) int) fun(x int) int
        return @x => f(g(x))

    fun triple(x int) int
        return x*3
    fun square(x int) int
        return x*x


type MyStruct(a int)

fun pub sort<T>(s mut Span<T>, lessThan fun(a T,b T)bool)
    // Simple selection sort
    for @i in s.count-1
        @lowElem = s[i]
        @lowIndex = i
        for @j in i+1..s.count
            if lessThan(s[j], lowElem)
                lowElem = s[j]
                lowIndex = j
        if lowIndex != i
            s[lowIndex] = s[i]
            s[i] = lowElem


fun pub memCopy(dest ^void, source ^void, length xint)
    @d = cast(xint)dest
    @s = cast(xint)source
    
    if length <= 0
        return

    // Align `d` on i32
    while d & 3 != 0 and length != 0
        (cast(^byte)d).* = (cast(^byte)s).*
        d+=1;  s+=1;  length-=1
    
    if s & 3 == 0
        memCopy32(cast(^void)d, cast(^void)s, length)
        return
    
    // Byte copy
    @end = d + length
    while end-d >= 4
        (cast(^byte)d).* = (cast(^byte)s).*; d+=1; s+=1
        (cast(^byte)d).* = (cast(^byte)s).*; d+=1; s+=1
        (cast(^byte)d).* = (cast(^byte)s).*; d+=1; s+=1
        (cast(^byte)d).* = (cast(^byte)s).*; d+=1; s+=1
    while d != end
        (cast(^byte)d).* = (cast(^byte)s).*; d+=1; s+=1

fun pub memCopy32(dest ^void, source ^void, length xint)
    @d = cast (xint)dest
    @s = cast (xint)source

    if length <= 0
        return

    // Try 64 bit copy first
    @end = d + length
    if (d~s) & 4 == 0 and length >= 8
        if d & 4 != 0
            (cast(^i32)d).* = (cast(^i32)s).*; d+=4; s+=4
        while end - d >= 8
            (cast(^i64)d).* = (cast(^i64)s).*; d+=8; s+=8
    while end-d >= 4
        (cast(^i32)d).* = (cast(^i32)s).*; d+=4; s+=4
    while d != end
        (cast(^byte)d).* = (cast(^byte)s).*; d+=1; s+=1
        